Countless programmers have learned C++ from previous editions of C++ Primer . During that time, C++ has matured greatly: Its focus, and that of its programming community, has widened from looking mostly at machine efficiency to devoting more attention to programmer efficiency. In 2011, the C++ standards committee issued a major revision to the ISO C++ standard. This revised standard is latest step in C++¡¯s evolution and continues the emphasis on programmer efficiency. The primary goals of the new standard are to ? Make the language more uniform and easier to teach and to learn ? Make the standard libraries easier, safer, and more efficient to use ? Make it easier to write efficient abstractions and libraries In this edition, we have completely revised the C++ Primer to use the latest standard. You can get an idea of how extensively the new standard has affected C++ by reviewing the New Features Table of Contents, which lists the sections that cover new material and appears on page xxi. Some additions in the new standard, such as auto for type inference, are pervasive. These facilities make the code in this edition easier to read and to understand. Programs (and programmers!) can ignore type details, which makes it easier to concentrate on what the program is intended to do. Other new features, such as smart pointers and move-enabled containers, let us write more sophisticated classes without having to contend with the intricacies of resource management. As a result, we can start to teach how to write your own classes much earlier in the book than we did in the Fourth Edition. We¡ªand you¡ªno longer have to worry about many of the details that stood in our way under the previous standard.
 
We¡¯ve marked those parts of the text that cover features defined by the new standard, with a marginal icon. We hope that readers who are already familiar with the core of C++ will find these alerts useful in deciding where to focus their attention. We also expect that these icons will help explain error messages from compilers that
C++ Primer, Fifth Edition
might not yet support every new feature. Although nearly all of the examples in this book have been compiled under the current release of the GNU compiler, we realize some readers will not yet have access to completely updated compilers. Even though numerous capabilities have been added by the latest standard, the core language remains unchanged and forms the bulk of the material that we cover. Readers can use these icons to note which capabilities may not yet be available in their compiler.
 Why Read This Book?
 
Modern C++ can be thought of as comprising three parts: ? The low-level language, much of which is inherited from C ? More advanced language features that allow us to define our own types and to organize large-scale programs and systems ? The standard library, which uses these advanced features to provide useful data structures and algorithms Most texts present C++ in the order in which it evolved. They teach the C subset of C++ first, and present the more abstract features of C++ as advanced topics at the end of the book. There are two problems with this approach: Readers can get bogged down in the details inherent in low-level programming and give up in frustration. Those who do press on learn bad habits that they must unlearn later. We take the opposite approach: Right from the start, we use the features that let programmers ignore the details inherent in low-level programming. For example, we introduce and use the library string and vector types along with the built-in arithmetic and array types. Programs that use these library types are easier to write, easier to understand, and much less error-prone. Too often, the library is taught as an ¡°advanced¡± topic. Instead of using the library, many books use low-level programming techniques based on pointers to character arrays and dynamic memory management. Getting programs that use these low-level techniques to work correctly is much harder than writing the corresponding C++ code using the library. Throughout C++ Primer , we emphasize good style: We want to help you, the reader, develop good habits immediately and avoid needing to unlearn bad habits as you gain more sophisticated knowledge. We highlight particularly tricky matters and warn about common misconceptions and pitfalls. We also explain the rationale behind the rules¡ªexplaining the why not just the what. We believe that by understanding why things work as they do, readers can more quickly cement their grasp of the language. Although you do not need to know C in order to understand this book, we assume you know enough about programming to write, compile, and run a program in at least one modern block-structured language. In particular, we assume you have used
C++ Primer, Fifth Edition
variables, written and called functions, and used a compiler.
 Changes to the Fifth Edition
 
New to this edition of C++ Primer are icons in the margins to help guide the reader. C++ is a large language that offers capabilities tailored to particular kinds of programming problems. Some of these capabilities are of great import for large project teams but might not be necessary for smaller efforts. As a result, not every programmer needs to know every detail of every feature. We¡¯ve added these marginal icons to help the reader know which parts can be learned later and which topics are more essential.
 
We¡¯ve marked sections that cover the fundamentals of the language with an image of a person studying a book. The topics covered in sections marked this way form the core part of the language. Everyone should read and understand these sections. We¡¯ve also indicated those sections that cover advanced or special-purpose topics. These sections can be skipped or skimmed on a first reading. We¡¯ve marked such sections with a stack of books to indicate that you can safely put down the book at that point. It is probably a good idea to skim such sections so you know that the capability exists. However, there is no reason to spend time studying these topics until you actually need to use the feature in your own programs.
 
To help readers guide their attention further, we¡¯ve noted particularly tricky concepts with a magnifying-glass icon. We hope that readers will take the time to understand thoroughly the material presented in the sections so marked. In at least some of these sections, the import of the topic may not be readily apparent; but we think you¡¯ll find that these sections cover topics that turn out to be essential to understanding the language.
 
Another aid to reading this book, is our extensive use of cross-references. We hope these references will make it easier for readers to dip into the middle of the book, yet easily jump back to the earlier material on which later examples rely. What remains unchanged is that C++ Primer is a clear, correct, and thorough tutorial guide to C++. We teach the language by presenting a series of increasingly sophisticated examples, which explain language features and show how to make the best use of C++.
 Structure of This Book
 
We start by covering the basics of the language and the library together in Parts I and
C++ Primer, Fifth Edition
II. These parts cover enough material to let you, the reader, write significant programs. Most C++ programmers need to know essentially everything covered in this portion of the book. In addition to teaching the basics of C++, the material in Parts I and II serves another important purpose: By using the abstract facilities defined by the library, you will become more comfortable with using high-level programming techniques. The library facilities are themselves abstract data types that are usually written in C++. The library can be defined using the same class-construction features that are available to any C++ programmer. Our experience in teaching C++ is that by first using well-designed abstract types, readers find it easier to understand how to build their own types. Only after a thorough grounding in using the library¡ªand writing the kinds of abstract programs that the library allows¡ªdo we move on to those C++ features that will enable you to write your own abstractions. Parts III and IV focus on writing abstractions in the form of classes. Part III covers the fundamentals; Part IV covers more specialized facilities. In Part III, we cover issues of copy control, along with other techniques to make classes that are as easy to use as the built-in types. Classes are the foundation for object-oriented and generic programming, which we also cover in Part III. C++ Primer concludes with Part IV, which covers features that are of most use in structuring large, complicated systems. We also summarize the library algorithms in Appendix A.
 Aids to the Reader
 
Each chapter concludes with a summary, followed by a glossary of defined terms, which together recap the chapter¡¯s most important points. Readers should use these sections as a personal checklist: If you do not understand a term, restudy the corresponding part of the chapter. We¡¯ve also incorporated a number of other learning aids in the body of the text: ? Important terms are indicated in bold; important terms that we assume are already familiar to the reader are indicated in bold italics . Each term appears in the chapter¡¯s Defined Terms section. ? Throughout the book, we highlight parts of the text to call attention to important aspects of the language, warn about common pitfalls, suggest good programming practices, and provide general usage tips. ? To make it easier to follow the relationships among features and concepts, we provide extensive forward and backward cross-references. ? We provide sidebar discussions on important concepts and for topics that new C++ programmers often find most difficult.
 
C++ Primer, Fifth Edition
? Learning any programming language requires writing programs. To that end, the Primer provides extensive examples throughout the text. Source code for the extended examples is available on the Web at the following URL: http://www.informit.com/title/032174113
 A Note about Compilers
 
As of this writing (July, 2012), compiler vendors are hard at work updating their compilers to match the latest ISO standard. The compiler we use most frequently is the GNU compiler, version 4.7.0. There are only a few features used in this book that this compiler does not yet implement: inheriting constructors, reference qualifiers for member functions, and the regular-expression library.
 Acknowledgments
 
In preparing this edition we are very grateful for the help of several current and former members of the standardization committee: Dave Abrahams, Andy Koenig, Stephan T. Lavavej, Jason Merrill, John Spicer, and Herb Sutter. They provided invaluable assistance to us in understanding some of the more subtle parts of the new standard. We¡¯d also like to thank the many folks who worked on updating the GNU compiler making the standard a reality. As in previous editions of C++ Primer , we¡¯d like to extend our thanks to Bjarne Stroustrup for his tireless work on C++ and for his friendship to the authors during most of that time. We¡¯d also like to thank Alex Stepanov for his original insights that led to the containers and algorithms at the core of the standard library. Finally, our thanks go to all the C++ Standards committee members for their hard work in clarifying, refining, and improving C++ over many years. We extend our deep-felt thanks to our reviewers, whose helpful comments led us to make improvements great and small throughout the book: Marshall Clow, Jon Kalb, Nevin Liber, Dr. C. L. Tondo, Daveed Vandevoorde, and Steve Vinoski. This book was typeset using LATEX and the many packages that accompany the LATEX distribution. Our well-justified thanks go to the members of the LATEX community, who have made available such powerful typesetting tools. Finally, we thank the fine folks at Addison-Wesley who have shepherded this edition through the publishing process: Peter Gordon, our editor, who provided the impetus for us to revise C++ Primer once again; Kim Boedigheimer, who keeps us all on schedule; Barbara Wood, who found lots of editing errors for us during the copy-edit phase, and Elizabeth Ryan, who was again a delight to work with as she guided us through the design and production process.
 Chapter 1. Getting Started
C++ Primer, Fifth Edition
 
Contents Section 1.1 Writing a Simple C++ Program Section 1.2 A First Look at Input/Output Section 1.3 A Word about Comments Section 1.4 Flow of Control Section 1.5 Introducing Classes Section 1.6 The Bookstore Program Chapter Summary Defined Terms
 This chapter introduces most of the basic elements of C++: types, variables, expressions, statements, and functions. Along the way, we¡¯ll briefly explain how to compile and execute a program. After having read this chapter and worked through the exercises, you should be able to write, compile, and execute simple programs. Later chapters will assume that you can use the features introduced in this chapter, and will explain these features in more detail.
 The way to learn a new programming language is to write programs. In this chapter, we¡¯ll write a program to solve a simple problem for a bookstore. Our store keeps a file of transactions, each of which records the sale of one or more copies of a single book. Each transaction contains three data elements:
 0-201-70353-X 4 24.99
 The first element is an ISBN (International Standard Book Number, a unique book identifier), the second is the number of copies sold, and the last is the price at which each of these copies was sold. From time to time, the bookstore owner reads this file and for each book computes the number of copies sold, the total revenue from that book, and the average sales price. To be able to write this program, we need to cover a few basic C++ features. In addition, we¡¯ll need to know how to compile and execute a program. Although we haven¡¯t yet designed our program, it¡¯s easy to see that it must ? Define variables ? Do input and output ? Use a data structure to hold the data ? Test whether two records have the same ISBN ? Contain a loop that will process every record in the transaction file
C++ Primer, Fifth Edition
 
We¡¯ll start by reviewing how to solve these subproblems in C++ and then write our bookstore program.
 1.1. Writing a Simple C++ Program
 
Every C++ program contains one or more functions , one of which must be named main. The operating system runs a C++ program by calling main. Here is a simple version of main that does nothing but return a value to the operating system: int main() {    return 0; } A function definition has four elements: a return type , a function name , a (possibly empty) parameter list enclosed in parentheses, and a function body . Although main is special in some ways, we define main the same way we define any other function. In this example, main has an empty list of parameters (shown by the () with nothing inside). ¡ì 6.2.5 (p. 218) will discuss the other parameter types that we can define for main. The main function is required to have a return type of int, which is a type that represents integers. The int type is a built-in type, which means that it is one of the types the language defines. The final part of a function definition, the function body, is a block of statements starting with an open curly brace and ending with a close curly: {    return 0; }
 The only statement in this block is a return, which is a statement that terminates a function. As is the case here, a return can also send a value back to the function¡¯s caller. When a return statement includes a value, the value returned must have a type that is compatible with the return type of the function. In this case, the return type of main is int and the return value is 0, which is an int.
 
 Note Note the semicolon at the end of the return statement. Semicolons mark the end of most statements in C++. They are easy to overlook but, when forgotten, can lead to mysterious compiler error messages.
 
 
On most systems, the value returned from main is a status indicator. A return value of 0 indicates success. A nonzero return has a meaning that is defined by the system.
C++ Primer, Fifth Edition
Ordinarily a nonzero return indicates what kind of error occurred.
 
Key Concept: Types Types are one of the most fundamental concepts in programming and a concept that we will come back to over and over in this Primer. A type defines both the contents of a data element and the operations that are possible on those data. The data our programs manipulate are stored in variables and every variable has a type. When the type of a variable named v is T, we often say that ¡°v has type T¡± or, interchangeably, that ¡°v is a T.¡±
 
 
1.1.1. Compiling and Executing Our Program
 
Having written the program, we need to compile it. How you compile a program depends on your operating system and compiler. For details on how your particular compiler works, check the reference manual or ask a knowledgeable colleague. Many PC-based compilers are run from an integrated development environment (IDE) that bundles the compiler with build and analysis tools. These environments can be a great asset in developing large programs but require a fair bit of time to learn how to use effectively. Learning how to use such environments is well beyond the scope of this book. Most compilers, including those that come with an IDE, provide a command-line interface. Unless you already know the IDE, you may find it easier to start with the command-line interface. Doing so will let you concentrate on learning C++ first. Moreover, once you understand the language, the IDE is likely to be easier to learn.
 
Program Source File Naming Convention
 
Whether you use a command-line interface or an IDE, most compilers expect program source code to be stored in one or more files. Program files are normally referred to as a source files . On most systems, the name of a source file ends with a suffix, which is a period followed by one or more characters. The suffix tells the system that the file is a C++ program. Different compilers use different suffix conventions; the most common include .cc, .cxx, .cpp, .cp, and .C.
 Running the Compiler from the Command Line
 
If we are using a command-line interface, we will typically compile a program in a console window (such as a shell window on a UNIX system or a Command Prompt window on Windows). Assuming that our main program is in a file named prog1.cc,
C++ Primer, Fifth Edition
we might compile it by using a command such as $ CC prog1.cc
 where CC names the compiler and $ is the system prompt. The compiler generates an executable file. On a Windows system, that executable file is named prog1.exe. UNIX compilers tend to put their executables in files named a.out. To run an executable on Windows, we supply the executable file name and can omit the .exe file extension:
 $ prog1
 On some systems you must specify the file¡¯s location explicitly, even if the file is in the current directory or folder. In such cases, we would write $ .\prog1
 The ¡°.¡± followed by a backslash indicates that the file is in the current directory. To run an executable on UNIX, we use the full file name, including the file extension:
 $ a.out
 If we need to specify the file¡¯s location, we¡¯d use a ¡°.¡± followed by a forward slash to indicate that our executable is in the current directory: $ ./a.out The value returned from main is accessed in a system-dependent manner. On both UNIX and Windows systems, after executing the program, you must issue an appropriate echo command. On UNIX systems, we obtain the status by writing
 $ echo $?
 To see the status on a Windows system, we write $ echo %ERRORLEVEL%
 
Running the GNU or Microsoft Compilers The command used to run the C++ compiler varies across compilers and operating systems. The most common compilers are the GNU compiler and the Microsoft Visual Studio compilers. By default, the command to run the GNU compiler is g++:
 Click here to view code image $ g++ -o prog1 prog1.cc Here $ is the system prompt. The -o prog1 is an argument to the compiler
C++ Primer, Fifth Edition
and names the file in which to put the executable file. This command generates an executable file named prog1 or prog1.exe, depending on the operating system. On UNIX, executable files have no suffix; on Windows, the suffix is .exe. If the -o prog1 is omitted, the compiler generates an executable named a.out on UNIX systems and a.exe on Windows. (Note: Depending on the release of the GNU compiler you are using, you may need to specify -std=c++0x to turn on C++ 11 support.) The command to run the Microsoft Visual Studio 2010 compiler is cl:
 Click here to view code image C:\Users\me\Programs> cl /EHsc prog1.cpp Here C:\Users\me\Programs> is the system prompt and \Users\me\Programs is the name of the current directory (aka the current folder). The cl command invokes the compiler, and /EHsc is the compiler option that turns on standard exception handling. The Microsoft compiler automatically generates an executable with a name that corresponds to the first source file name. The executable has the suffix .exe and the same name as the source file name. In this case, the executable is named prog1.exe. Compilers usually include options to generate warnings about problematic constructs. It is usually a good idea to use these options. Our preference is to use -Wall with the GNU compiler, and to use /W4 with the Microsoft compilers. For further information consult your compiler¡¯s user¡¯s guide.
 
 
Exercises Section 1.1.1 Exercise 1.1: Review the documentation for your compiler and determine what file naming convention it uses. Compile and run the main program from page 2. Exercise 1.2: Change the program to return -1. A return value of -1 is often treated as an indicator that the program failed. Recompile and rerun your program to see how your system treats a failure indicator from main.
 
 
1.2. A First Look at Input/Output
 
The C++ language does not define any statements to do input or output (IO). Instead, C++ includes an extensive standard library that provides IO (and many other facilities). For many purposes, including the examples in this book, one needs to
C++ Primer, Fifth Edition
know only a few basic concepts and operations from the IO library. Most of the examples in this book use the iostream library. Fundamental to the iostream library are two types named istream and ostream, which represent input and output streams, respectively. A stream is a sequence of characters read from or written to an IO device. The term stream is intended to suggest that the characters are generated, or consumed, sequentially over time.
 Standard Input and Output Objects
 
The library defines four IO objects. To handle input, we use an object of type istream named cin (pronounced see-in ). This object is also referred to as the standard input. For output, we use an ostream object named cout (pronounced see-out ). This object is also known as the standard output. The library also defines two other ostream objects, named cerr and clog (pronounced see-err and see-log , respectively). We typically use cerr, referred to as the standard error, for warning and error messages and clog for general information about the execution of the program. Ordinarily, the system associates each of these objects with the window in which the program is executed. So, when we read from cin, data are read from the window in which the program is executing, and when we write to cout, cerr, or clog, the output is written to the same window.
 A Program That Uses the IO Library
 
In our bookstore problem, we¡¯ll have several records that we¡¯ll want to combine into a single total. As a simpler, related problem, let¡¯s look first at how we might add two numbers. Using the IO library, we can extend our main program to prompt the user to give us two numbers and then print their sum:
 Click here to view code image #include <iostream> int main() {    std::cout << "Enter two numbers:" << std::endl;    int v1 = 0, v2 = 0;    std::cin >> v1 >> v2;    std::cout << "The sum of " << v1 << " and " << v2              << " is " << v1 + v2 << std::endl;    return 0; }
 This program starts by printing Enter two numbers:
 on the user¡¯s screen and then waits for input from the user. If the user enters
C++ Primer, Fifth Edition
 3 7
 followed by a newline, then the program produces the following output: The sum of 3 and 7 is 10
 The first line of our program #include <iostream>
 tells the compiler that we want to use the iostream library. The name inside angle brackets (iostream in this case) refers to a header. Every program that uses a library facility must include its associated header. The #include directive must be written on a single line¡ªthe name of the header and the #include must appear on the same line. In general, #include directives must appear outside any function. Typically, we put all the #include directives for a program at the beginning of the source file.
 Writing to a Stream
 
The first statement in the body of main executes an expression. In C++ an expression yields a result and is composed of one or more operands and (usually) an operator. The expressions in this statement use the output operator (the ? operator) to print a message on the standard output:
 Click here to view code image std::cout << "Enter two numbers:" << std::endl;
 The << operator takes two operands: The left-hand operand must be an ostream object; the right-hand operand is a value to print. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand. That is, the result is the ostream on which we wrote the given value. Our output statement uses the << operator twice. Because the operator returns its left-hand operand, the result of the first operator becomes the left-hand operand of the second. As a result, we can chain together output requests. Thus, our expression is equivalent to
 Click here to view code image (std::cout << "Enter two numbers:") << std::endl;
 Each operator in the chain has the same object as its left-hand operand, in this case std::cout. Alternatively, we can generate the same output using two statements:
 Click here to view code image std::cout << "Enter two numbers:"; std::cout << std::endl; The first output operator prints a message to the user. That message is a string
C++ Primer, Fifth Edition
literal, which is a sequence of characters enclosed in double quotation marks. The text between the quotation marks is printed to the standard output. The second operator prints endl, which is a special value called a manipulator. Writing endl has the effect of ending the current line and flushing the buffer associated with that device. Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.
 
 Warning Programmers often add print statements during debugging. Such statements should always flush the stream. Otherwise, if the program crashes, output may be left in the buffer, leading to incorrect inferences about where the program crashed.
 
 
Using Names from the Standard Library
 
Careful readers will note that this program uses std::cout and std::endl rather than just cout and endl. The prefix std:: indicates that the names cout and endl are defined inside the namespace named std. Namespaces allow us to avoid inadvertent collisions between the names we define and uses of those same names inside a library. All the names defined by the standard library are in the std namespace. One side effect of the library¡¯s use of a namespace is that when we use a name from the library, we must say explicitly that we want to use the name from the std namespace. Writing std::cout uses the scope operator (the :: operator) to say that we want to use the name cout that is defined in the namespace std. ¡ì 3.1 (p. 82) will show a simpler way to access names from the library.
 Reading from a Stream
 
Having asked the user for input, we next want to read that input. We start by defining two variables named v1 and v2 to hold the input: int v1 = 0, v2 = 0;
 We define these variables as type int, which is a built-in type representing integers. We also initialize them to 0. When we initialize a variable, we give it the indicated value at the same time as the variable is created. The next statement std::cin >> v1 >> v2;
 
C++ Primer, Fifth Edition
reads the input. The input operator (the ? operator) behaves analogously to the output operator. It takes an istream as its left-hand operand and an object as its right-hand operand. It reads data from the given istream and stores what was read in the given object. Like the output operator, the input operator returns its left-hand operand as its result. Hence, this expression is equivalent to (std::cin >> v1) >> v2;
 Because the operator returns its left-hand operand, we can combine a sequence of input requests into a single statement. Our input operation reads two values from std::cin, storing the first in v1 and the second in v2. In other words, our input operation executes as std::cin >> v1; std::cin >> v2;
 Completing the Program
 
What remains is to print our result:
 Click here to view code image std::cout << "The sum of " << v1 << " and " << v2          << " is " << v1 + v2 << std::endl;
 This statement, although longer than the one that prompted the user for input, is conceptually similar. It prints each of its operands on the standard output. What is interesting in this example is that the operands are not all the same kinds of values. Some operands are string literals, such as "The sum of ". Others are int values, such as v1, v2, and the result of evaluating the arithmetic expression v1 + v2. The library defines versions of the input and output operators that handle operands of each of these differing types.
 
Exercises Section 1.2 Exercise 1.3: Write a program to print Hello, World on the standard output. Exercise 1.4: Our program used the addition operator, +, to add two numbers. Write a program that uses the multiplication operator, *, to print the product instead. Exercise 1.5: We wrote the output in one large statement. Rewrite the program to use a separate statement to print each operand. Exercise 1.6: Explain whether the following program fragment is legal.
 Click here to view code image std::cout << "The sum of " << v1;          << " and " << v2;          << " is " << v1 + v2 << std::endl;
C++ Primer, Fifth Edition
 If the program is legal, what does it do? If the program is not legal, why not? How would you fix it?
 
 
1.3. A Word about Comments
 
Before our programs get much more complicated, we should see how C++ handles comments . Comments help the human readers of our programs. They are typically used to summarize an algorithm, identify the purpose of a variable, or clarify an otherwise obscure segment of code. The compiler ignores comments, so they have no effect on the program¡¯s behavior or performance. Although the compiler ignores comments, readers of our code do not. Programmers tend to believe comments even when other parts of the system documentation are out of date. An incorrect comment is worse than no comment at all because it may mislead the reader. When you change your code, be sure to update the comments, too!
 Kinds of Comments in C++
 
There are two kinds of comments in C++: single-line and paired. A single-line comment starts with a double slash (//) and ends with a newline. Everything to the right of the slashes on the current line is ignored by the compiler. A comment of this kind can contain any text, including additional double slashes. The other kind of comment uses two delimiters (/* and */) that are inherited from C. Such comments begin with a /* and end with the next */. These comments can include anything that is not a */, including newlines. The compiler treats everything that falls between the /* and */ as part of the comment. A comment pair can be placed anywhere a tab, space, or newline is permitted. Comment pairs can span multiple lines of a program but are not required to do so. When a comment pair does span multiple lines, it is often a good idea to indicate visually that the inner lines are part of a multiline comment. Our style is to begin each line in the comment with an asterisk, thus indicating that the entire range is part of a multiline comment. Programs typically contain a mixture of both comment forms. Comment pairs generally are used for multiline explanations, whereas double-slash comments tend to be used for half-line and single-line remarks:
 Click here to view code image #include <iostream> /* * Simple main function:
C++ Primer, Fifth Edition
 * Read two numbers and write their sum */ int main() {    // prompt user to enter two numbers    std::cout << "Enter two numbers:" << std::endl;    int v1 = 0, v2 = 0;   // variables to hold the input we read    std::cin >> v1 >> v2; // read input    std::cout << "The sum of " << v1 << " and " << v2              << " is " << v1 + v2 << std::endl;    return 0; }
 
 Note In this book, we italicize comments to make them stand out from the normal program text. In actual programs, whether comment text is distinguished from the text used for program code depends on the sophistication of the programming environment you are using.
 
 
Comment Pairs Do Not Nest
 
A comment that begins with /* ends with the next */. As a result, one comment pair cannot appear inside another. The compiler error messages that result from this kind of mistake can be mysterious and confusing. As an example, compile the following program on your system:
 Click here to view code image /* * comment pairs /*   */ cannot nest. * ''cannot nest'' is considered source code, * as is the rest of the program */ int main() {    return 0; } We often need to comment out a block of code during debugging. Because that code might contain nested comment pairs, the best way to comment a block of code is to insert single-line comments at the beginning of each line in the section we want to ignore:
 Click here to view code image // /*
C++ Primer, Fifth Edition
// * everything inside a single-line comment is ignored // * including nested comment pairs //  */
 
Exercises Section 1.3 Exercise 1.7: Compile a program that has incorrectly nested comments. Exercise 1.8: Indicate which, if any, of the following output statements are legal:
 Click here to view code image std::cout << "/*"; std::cout << "*/"; std::cout << /* "*/" */; std::cout << /*  "*/" /* "/*"  */; After you¡¯ve predicted what will happen, test your answers by compiling a program with each of these statements. Correct any errors you encounter.
 
 
1.4. Flow of Control
 
Statements normally execute sequentially: The first statement in a block is executed first, followed by the second, and so on. Of course, few programs¡ªincluding the one to solve our bookstore problem¡ªcan be written using only sequential execution. Instead, programming languages provide various flow-of-control statements that allow for more complicated execution paths.
 1.4.1. The while Statement
 
A while statement repeatedly executes a section of code so long as a given condition is true. We can use a while to write a program to sum the numbers from 1 through 10 inclusive as follows:
 Click here to view code image #include <iostream> int main() {    int sum = 0, val  = 1;    // keep executing the while as long as val is less than or equal to 10    while (val <= 10)  {        sum += val;   // assigns sum + val to sum        ++val;        // add 1 to val    }    std::cout << "Sum of 1 to 10 inclusive is "
C++ Primer, Fifth Edition
              << sum << std::endl;    return 0; }
 When we compile and execute this program, it prints Sum of 1 to 10 inclusive is 55 As before, we start by including the iostream header and defining main. Inside main we define two int variables: sum, which will hold our summation, and val, which will represent each of the values from 1 through 10. We give sum an initial value of 0 and start val off with the value 1. The new part of this program is the while statement. A while has the form
 while (condition)    statement
 A while executes by (alternately) testing the condition and executing the associated statement until the condition is false. A condition is an expression that yields a result that is either true or false. So long as condition is true, statement is executed. After executing statement , condition is tested again. If condition is again true, then statement is again executed. The while continues, alternately testing the condition and executing statement until the condition is false. In this program, the while statement is
 Click here to view code image
 // keep executing the while as long as val is less than or equal to 10 while (val <= 10)  {    sum += val;   // assigns sum + val to sum    ++val;        // add 1 to val }
 The condition uses the less-than-or-equal operator (the <= operator) to compare the current value of val and 10. As long as val is less than or equal to 10, the condition is true. If the condition is true, we execute the body of the while. In this case, that body is a block with two statements:
 Click here to view code image {    sum += val;  // assigns sum + val to sum    ++val;       // add 1 to val }
 A block is a sequence of zero or more statements enclosed by curly braces. A block is a statement and may be used wherever a statement is required. The first statement in this block uses the compound assignment operator (the += operator). This operator adds its right-hand operand to its left-hand operand and stores the result in the lefthand operand. It has essentially the same effect as writing an addition and an
C++ Primer, Fifth Edition
assignment:
 Click here to view code image
 sum = sum + val; // assign sum + val to sum
 Thus, the first statement in the block adds the value of val to the current value of sum and stores the result back into sum. The next statement
 ++val;     // add 1 to val
 uses the prefix increment operator (the ++ operator). The increment operator adds 1 to its operand. Writing ++val is the same as writing val = val + 1. After executing the while body, the loop evaluates the condition again. If the (now incremented) value of val is still less than or equal to 10, then the body of the while is executed again. The loop continues, testing the condition and executing the body, until val is no longer less than or equal to 10. Once val is greater than 10, the program falls out of the while loop and continues execution with the statement following the while. In this case, that statement prints our output, followed by the return, which completes our main program.
 
Exercises Section 1.4.1 Exercise 1.9: Write a program that uses a while to sum the numbers from 50 to 100. Exercise 1.10: In addition to the ++ operator that adds 1 to its operand, there is a decrement operator (--) that subtracts 1. Use the decrement operator to write a while that prints the numbers from ten down to zero. Exercise 1.11: Write a program that prompts the user for two integers. Print each number in the range specified by those two integers.
 
 
1.4.2. The for Statement
 
In our while loop we used the variable val to control how many times we executed the loop. We tested the value of val in the condition and incremented val in the while body. This pattern¡ªusing a variable in a condition and incrementing that variable in the body¡ªhappens so often that the language defines a second statement, the for statement, that abbreviates code that follows this pattern. We can rewrite this program using a for loop to sum the numbers from 1 through 10 as follows:
 Click here to view code image
C++ Primer, Fifth Edition
 #include <iostream> int main() {    int sum = 0;    // sum values from 1 through 10 inclusive    for (int val = 1; val <= 10; ++val)        sum += val;  // equivalent to sum = sum + val    std::cout << "Sum of 1 to 10 inclusive is "              << sum << std::endl;    return 0; }
 As before, we define sum and initialize it to zero. In this version, we define val as part of the for statement itself:
 Click here to view code image for (int val = 1; val <= 10; ++val)    sum += val;
 Each for statement has two parts: a header and a body. The header controls how often the body is executed. The header itself consists of three parts: an initstatement , a condition , and an expression . In this case, the init-statement int val = 1;
 defines an int object named val and gives it an initial value of 1. The variable val exists only inside the for; it is not possible to use val after this loop terminates. The init-statement is executed only once, on entry to the for. The condition val <= 10
 compares the current value in val to 10. The condition is tested each time through the loop. As long as val is less than or equal to 10, we execute the for body. The expression is executed after the for body. Here, the expression ++val
 uses the prefix increment operator, which adds 1 to the value of val. After executing the expression , the for retests the condition . If the new value of val is still less than or equal to 10, then the for loop body is executed again. After executing the body, val is incremented again. The loop continues until the condition fails. In this loop, the for body performs the summation
 Click here to view code image
 sum += val; // equivalent to sum = sum + val
 To recap, the overall execution flow of this for is: 1. Create val and initialize it to 1. 2. Test whether val is less than or equal to 10. If the test succeeds, execute the for body. If the test fails, exit the loop and continue execution with the first
C++ Primer, Fifth Edition
statement following the for body. 3. Increment val. 4. Repeat the test in step 2, continuing with the remaining steps as long as the condition is true.
 
Exercises Section 1.4.2 Exercise 1.12: What does the following for loop do? What is the final value of sum?
 Click here to view code image int sum = 0; for (int i = -100; i <= 100; ++i)    sum += i; Exercise 1.13: Rewrite the exercises from ¡ì 1.4.1 (p. 13) using for loops. Exercise 1.14: Compare and contrast the loops that used a for with those using a while. Are there advantages or disadvantages to using either form? Exercise 1.15: Write programs that contain the common errors discussed in the box on page 16. Familiarize yourself with the messages the compiler generates.
 
 
1.4.3. Reading an Unknown Number of Inputs
 
In the preceding sections, we wrote programs that summed the numbers from 1 through 10. A logical extension of this program would be to ask the user to input a set of numbers to sum. In this case, we won¡¯t know how many numbers to add. Instead, we¡¯ll keep reading numbers until there are no more numbers to read:
 Click here to view code image #include <iostream> int main() {    int sum = 0, value = 0;    // read until end-of-file, calculating a running total of all values read    while (std::cin >> value)        sum += value; // equivalent to sum = sum + value    std::cout << "Sum is: " << sum << std::endl;    return 0; }
 If we give this program the input 3 4 5 6
 then our output will be
C++ Primer, Fifth Edition
 Sum is: 18 The first line inside main defines two int variables, named sum and value, which we initialize to 0. We¡¯ll use value to hold each number as we read it from the input. We read the data inside the condition of the while: while (std::cin >> value)
 Evaluating the while condition executes the expression std::cin >> value
 That expression reads the next number from the standard input and stores that number in value. The input operator (¡ì 1.2, p. 8) returns its left operand, which in this case is std::cin. This condition, therefore, tests std::cin. When we use an istream as a condition, the effect is to test the state of the stream. If the stream is valid¡ªthat is, if the stream hasn¡¯t encountered an error¡ªthen the test succeeds. An istream becomes invalid when we hit end-of-file or encounter an invalid input, such as reading a value that is not an integer. An istream that is in an invalid state will cause the condition to yield false. Thus, our while executes until we encounter end-of-file (or an input error). The while body uses the compound assignment operator to add the current value to the evolving sum. Once the condition fails, the while ends. We fall through and execute the next statement, which prints the sum followed by endl.
 Entering an End-of-File from the Keyboard When we enter input to a program from the keyboard, different operating systems use different conventions to allow us to indicate end-of-file. On Windows systems we enter an end-of-file by typing a control-z¡ªhold down the Ctrl key and press z¡ªfollowed by hitting either the Enter or Return key. On UNIX systems, including on Mac OS X machines, end-of-file is usually control-d.
 
 
Compilation Revisited Part of the compiler¡¯s job is to look for errors in the program text. A compiler cannot detect whether a program does what its author intends, but it can detect errors in the form of the program. The following are the most common kinds of errors a compiler will detect.
 Syntax errors: The programmer has made a grammatical error in the C++ language. The following program illustrates common syntax errors; each comment describes the error on the following line:
 Click here to view code image
C++ Primer, Fifth Edition
 
// error: missing ) in parameter list for main int main ( {    // error: used colon, not a semicolon, after endl    std::cout << "Read each file." << std::endl:    // error: missing quotes around string literal    std::cout << Update master. << std::endl;    // error: second output operator is missing    std::cout << "Write new master." std::endl;    // error: missing ; on return statement    return 0 }
 Type errors: Each item of data in C++ has an associated type. The value 10, for example, has a type of int (or, more colloquially, ¡°is an int¡±). The word "hello", including the double quotation marks, is a string literal. One example of a type error is passing a string literal to a function that expects an int argument.
 Declaration errors: Every name used in a C++ program must be declared before it is used. Failure to declare a name usually results in an error message. The two most common declaration errors are forgetting to use std:: for a name from the library and misspelling the name of an identifier:
 Click here to view code image #include <iostream> int main() {    int v1 = 0, v2 = 0;    std::cin >> v >> v2; // error: uses "v" not "v1"    // error: cout not defined; should be std::cout    cout << v1 + v2 << std::endl;    return 0; } Error messages usually contain a line number and a brief description of what the compiler believes we have done wrong. It is a good practice to correct errors in the sequence they are reported. Often a single error can have a cascading effect and cause a compiler to report more errors than actually are present. It is also a good idea to recompile the code after each fix¡ªor after making at most a small number of obvious fixes. This cycle is known as edit-compile-debug .
 
 
Exercises Section 1.4.3 Exercise 1.16: Write your own version of a program that prints the sum of a set of integers read from cin.
C++ Primer, Fifth Edition
 
 
1.4.4. The if Statement
 
Like most languages, C++ provides an if statement that supports conditional execution. We can use an if to write a program to count how many consecutive times each distinct value appears in the input:
 Click here to view code image #include <iostream> int main() {    // currVal is the number we're counting; we'll read new values into val    int currVal = 0, val = 0;    // read first number and ensure that we have data to process    if (std::cin >> currVal) {        int cnt = 1;  // store the count for the current value we're processing        while (std::cin >> val) { // read the remaining numbers            if (val == currVal)   // if the values are the same                ++cnt;            // add 1 to cnt            else { // otherwise, print the count for the previous value                std::cout << currVal << " occurs "                          << cnt << " times" << std::endl;                currVal = val;    // remember the new value                cnt = 1;          // reset the counter            }        }  // while loop ends here        // remember to print the count for the last value in the file        std::cout << currVal <<  " occurs "                  << cnt << " times" << std::endl;    } // outermost if statement ends here    return 0; }
 If we give this program the following input:
 Click here to view code image
 42 42 42 42 42 55 55 62 100 100 100
 then the output should be 42 occurs 5 times 55 occurs 2 times 62 occurs 1 times 100 occurs 3 times Much of the code in this program should be familiar from our earlier programs. We
C++ Primer, Fifth Edition
start by defining val and currVal: currVal will keep track of which number we are counting; val will hold each number as we read it from the input. What¡¯s new are the two if statements. The first if
 Click here to view code image if (std::cin >> currVal) {    // ... } // outermost if statement ends here
 ensures that the input is not empty. Like a while, an if evaluates a condition. The condition in the first if reads a value into currVal. If the read succeeds, then the condition is true and we execute the block that starts with the open curly following the condition. That block ends with the close curly just before the return statement. Once we know there are numbers to count, we define cnt, which will count how often each distinct number occurs. We use a while loop similar to the one in the previous section to (repeatedly) read numbers from the standard input. The body of the while is a block that contains the second if statement:
 Click here to view code image
 if (val == currVal)   // if the values are the same    ++cnt;            // add 1 to cnt else { // otherwise, print the count for the previous value    std::cout << currVal << " occurs "              << cnt << " times" << std::endl;    currVal = val;    // remember the new value    cnt = 1;          // reset the counter }
 The condition in this if uses the equality operator (the == operator) to test whether val is equal to currVal. If so, we execute the statement that immediately follows the condition. That statement increments cnt, indicating that we have seen currVal once more. If the condition is false¡ªthat is, if val is not equal to currVal¡ªthen we execute the statement following the else. This statement is a block consisting of an output statement and two assignments. The output statement prints the count for the value we just finished processing. The assignments reset cnt to 1 and currVal to val, which is the number we just read.
 
 Warning C++ uses = for assignment and == for equality. Both operators can appear inside a condition. It is a common mistake to write = when you mean == inside a condition.
 
 
C++ Primer, Fifth Edition
Exercises Section 1.4.4 Exercise 1.17: What happens in the program presented in this section if the input values are all equal? What if there are no duplicated values? Exercise 1.18: Compile and run the program from this section giving it only equal values as input. Run it again giving it values in which no number is repeated. Exercise 1.19: Revise the program you wrote for the exercises in ¡ì 1.4.1 (p. 13) that printed a range of numbers so that it handles input in which the first number is smaller than the second.
 
 
Key Concept: Indentation and Formatting of C++ Programs C++ programs are largely free-format, meaning that where we put curly braces, indentation, comments, and newlines usually has no effect on what our programs mean. For example, the curly brace that denotes the beginning of the body of main could be on the same line as main; positioned as we have done, at the beginning of the next line; or placed anywhere else we¡¯d like. The only requirement is that the open curly must be the first nonblank, noncomment character following main¡¯s parameter list. Although we are largely free to format programs as we wish, the choices we make affect the readability of our programs. We could, for example, have written main on a single long line. Such a definition, although legal, would be hard to read. Endless debates occur as to the right way to format C or C++ programs. Our belief is that there is no single correct style but that there is value in consistency. Most programmers indent subsidiary parts of their programs, as we¡¯ve done with the statements inside main and the bodies of our loops. We tend to put the curly braces that delimit functions on their own lines. We also indent compound IO expressions so that the operators line up. Other indentation conventions will become clear as our programs become more sophisticated. The important thing to keep in mind is that other ways to format programs are possible. When you choose a formatting style, think about how it affects readability and comprehension. Once you¡¯ve chosen a style, use it consistently.
 
 
1.5. Introducing Classes
 
C++ Primer, Fifth Edition
The only remaining feature we need to understand before solving our bookstore problem is how to define a data structure to represent our transaction data. In C++ we define our own data structures by defining a class. A class defines a type along with a collection of operations that are related to that type. The class mechanism is one of the most important features in C++. In fact, a primary focus of the design of C++ is to make it possible to define class types that behave as naturally as the builtin types. In this section, we¡¯ll describe a simple class that we can use in writing our bookstore program. We¡¯ll implement this class in later chapters as we learn more about types, expressions, statements, and functions. To use a class we need to know three things: ? What is its name? ? Where is it defined? ? What operations does it support?
 For our bookstore problem, we¡¯ll assume that the class is named Sales_item and that it is already defined in a header named Sales_item.h. As we¡¯ve seen, to use a library facility, we must include the associated header. Similarly, we use headers to access classes defined for our own applications. Conventionally, header file names are derived from the name of a class defined in that header. Header files that we write usually have a suffix of .h, but some programmers use .H, .hpp, or .hxx. The standard library headers typically have no suffix at all. Compilers usually don¡¯t care about the form of header file names, but IDEs sometimes 
To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation . Separate compilation lets us split our programs into several files, each of which can be compiled independently. When we separate a program into multiple files, we need a way to share code across those files. For example, code defined in one file may need to use a variable defined in another file. As a concrete example, consider std::cout and std::cin. These are objects defined somewhere in the standard library, yet our programs can use these objects.
 
Caution: Uninitialized Variables Cause Run-Time Problems An uninitialized variable has an indeterminate value. Trying to use the value of an uninitialized variable is an error that is often hard to debug. Moreover, the compiler is not required to detect such errors, although most will warn about at least some uses of uninitialized variables. What happens when we use an uninitialized variable is undefined. Sometimes, we¡¯re lucky and our program crashes as soon as we access the object. Once we track down the location of the crash, it is usually easy to see that the variable was not properly initialized. Other times, the program completes but produces erroneous results. Even worse, the results may appear correct on one run of our program but fail on a subsequent run. Moreover, adding code to the program in an unrelated location can cause what we thought was a correct program to start producing incorrect results.
 
 Tip We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.
 
 
 
To support separate compilation, C++ distinguishes between declarations and definitions. A declaration makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. A definition creates the associated entity. A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value. To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer:
C++ Primer, Fifth Edition
 
Click here to view code image
 extern int i;   // declares but does not define i int j;          // declares and defines j Any declaration that includes an explicit initializer is a definition. We can provide an initializer on a variable defined as extern, but doing so overrides the extern. An extern that has an initializer is a definition:
 Click here to view code image
 extern double pi = 3.1416; // definition It is an error to provide an initializer on an extern inside a function.
 
 Note Variables must be defined exactly once but can be declared many times.
 
 
The distinction between a declaration and a definition may seem obscure at this point but is actually important. To use a variable in more than one file requires declarations that are separate from the variable¡¯s definition. To use the same variable in multiple files, we must define that variable in one¡ªand only one¡ªfile. Other files that use that variable must declare¡ªbut not define¡ªthat variable. We¡¯ll have more to say about how C++ supports separate compilation in ¡ì 2.6.3 (p. 76) and ¡ì 6.1.3 (p. 207).
 
Exercises Section 2.2.2 Exercise 2.11: Explain whether each of the following is a declaration or a definition: (a) extern int ix = 1024; (b) int iy; (c) extern int iz;
 
 
Key Concept: Static Typing C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type checking . As we¡¯ve seen, the type of an object constrains the operations that the object can perform. In C++, the compiler checks whether the operations we
C++ Primer, Fifth Edition
write are supported by the types we use. If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file. As our programs get more complicated, we¡¯ll see that static type checking can help find bugs. However, a consequence of static checking is that the type of every entity we use must be known to the compiler. As one example, we must declare the type of a variable before we can use that variable.
 
 
2.2.3. Identifiers
 
Identifiers in C++ can be composed of letters, digits, and the underscore character. The language imposes no limit on name length. Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are distinct:
 Click here to view code image
 // defines four different int variables int somename, someName, SomeName, SOMENAME; The language reserves a set of names, listed in Tables 2.3 and Table 2.4, for its own use. These names may not be used as identifiers.
 
Table 2.3. C++ Keywords
 
 
Table 2.4. C++ Alternative Operator Names
 
C++ Primer, Fifth Edition
 The standard also reserves a set of names for use in the standard library. The identifiers we define in our own programs may not contain two consecutive underscores, nor can an identifier begin with an underscore followed immediately by an uppercase letter. In addition, identifiers defined outside a function may not begin with an underscore.
 
Conventions for Variable Names
 
There are a number of generally accepted conventions for naming variables. Following these conventions can improve the readability of a program. ? An identifier should give some indication of its meaning. ? Variable names normally are lowercase¡ªindex, not Index or INDEX. ? Like Sales_item, classes we define usually begin with an uppercase letter. ? Identifiers with multiple words should visually distinguish each word, for example, student_loan or studentLoan, not studentloan.
 
 Best Practices Naming conventions are most useful when followed consistently.
 
 
Exercises Section 2.2.3 Exercise 2.12: Which, if any, of the following names are invalid? (a) int double = 3.14; (b) int _; (c) int catch-22; (d) int 1_or_2 = 1; (e) double Double = 3.14;
 
 
2.2.4. Scope of a Name
 
At any particular point in a program, each name that is in use refers to a specific entity¡ªa variable, function, type, and so on. However, a given name can be reused to refer to different entities at different points in the program. A scope is a part of the program in which a name has a particular meaning. Most
C++ Primer, Fifth Edition
scopes in C++ are delimited by curly braces. The same name can refer to different entities in different scopes. Names are visible from the point where they are declared until the end of the scope in which the declaration appears. As an example, consider the program from ¡ì 1.4.2 (p. 13):
 Click here to view code image #include <iostream> int main() {    int sum = 0;    // sum values from 1 through 10 inclusive    for (int val = 1; val <= 10; ++val)        sum += val;  // equivalent to sum = sum + val    std::cout << "Sum of 1 to 10 inclusive is "              << sum << std::endl;    return 0; }
 This program defines three names¡ªmain, sum, and val¡ªand uses the namespace name std, along with two names from that namespace¡ªcout and endl. The name main is defined outside any curly braces. The name main¡ªlike most names defined outside a function¡ªhas global scope. Once declared, names at the global scope are accessible throughout the program. The name sum is defined within the scope of the block that is the body of the main function. It is accessible from its point of declaration throughout the rest of the main function but not outside of it. The variable sum has block scope. The name val is defined in the scope of the for statement. It can be used in that statement but not elsewhere in main.
 Advice: Define Variables Where You First Use Them It is usually a good idea to define an object near the point at which the object is first used. Doing so improves readability by making it easy to find the definition of the variable. More importantly, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used.
 
 
Nested Scopes
 
Scopes can contain other scopes. The contained (or nested) scope is referred to as an inner scope, the containing scope is the outer scope. Once a name has been declared in a scope, that name can be used by scopes nested inside that scope. Names declared in the outer scope can also be redefined in
C++ Primer, Fifth Edition
an inner scope:
 Click here to view code image #include <iostream> // Program for illustration purposes only: It is bad style for a function // to use a global variable and also define a local variable with the same name int reused = 42;  // reused has global scope int main() {    int unique = 0; // unique has block scope    // output #1: uses global reused; prints 42 0    std::cout << reused << " " << unique << std::endl;    int reused = 0; // new, local object named reused hides global reused    // output #2: uses local reused; prints 0 0    std::cout << reused << " " << unique << std::endl;    // output #3: explicitly requests the global reused; prints 42 0    std::cout << ::reused << " " << unique << std::endl;    return 0; }
 Output #1 appears before the local definition of reused. Therefore, this output statement uses the name reused that is defined in the global scope. This statement prints 42 0. Output #2 occurs after the local definition of reused. The local reused is now in scope. Thus, this second output statement uses the local object named reused rather than the global one and prints 0 0. Output #3 uses the scope operator (¡ì 1.2, p. 8) to override the default scoping rules. The global scope has no name. Hence, when the scope operator has an empty left-hand side, it is a request to fetch the name on the right-hand side from the global scope. Thus, this expression uses the global reused and prints 42 0.
 
 Warning It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use.
 
 
Exercises Section 2.2.4 Exercise 2.13: What is the value of j in the following program? int i = 42; int main() {    int i = 100;    int j = i; } Exercise 2.14: Is the following program legal? If so, what values are
C++ Primer, Fifth Edition
printed?
 Click here to view code image int i = 100, sum = 0; for (int i = 0; i != 10; ++i)     sum += i; std::cout << i << " " << sum << std::endl;
 
 
2.3. Compound Types
 
A compound type is a type that is defined in terms of another type. C++ has several compound types, two of which¡ªreferences and pointers¡ªwe¡¯ll cover in this chapter. Defining variables of compound type is more complicated than the declarations we¡¯ve seen so far. In ¡ì 2.2 (p. 41) we said that simple declarations consist of a type followed by a list of variable names. More generally, a declaration is a base type followed by a list of declarators. Each declarator names a variable and gives the variable a type that is related to the base type. The declarations we have seen so far have declarators that are nothing more than variable names. The type of such variables is the base type of the declaration. More complicated declarators specify variables with compound types that are built from the base type of the declaration.
 2.3.1. References
 
 Note The new standard introduced a new kind of reference: an ¡°rvalue reference,¡± which we¡¯ll cover in ¡ì 13.6.1 (p. 532). These references are primarily intended for use inside classes. Technically speaking, when we use the term reference , we mean ¡°lvalue reference.¡±
 
 
A reference defines an alternative name for an object. A reference type ¡°refers to¡± another type. We define a reference type by writing a declarator of the form &d, where d is the name being declared:
 Click here to view code image
 
C++ Primer, Fifth Edition
int ival = 1024; int &refVal = ival;  // refVal refers to (is another name for) ival int &refVal2;        // error: a reference must be initialized
 Ordinarily, when we initialize a variable, the value of the initializer is copied into the object we are creating. When we define a reference, instead of copying the initializer¡¯s value, we bind the reference to its initializer. Once initialized, a reference remains bound to its initial object. There is no way to rebind a reference to refer to a different object. Because there is no way to rebind a reference, references must be initialized.
 A Reference Is an Alias
 
 Note A reference is not an object. Instead, a reference is just another name for an already existing object .
 
 
After a reference has been defined, all operations on that reference are actually operations on the object to which the reference is bound:
 Click here to view code image
 refVal = 2;      // assigns 2 to the object to which refVal refers, i.e., to ival int ii = refVal; // same as ii = ival
 When we assign to a reference, we are assigning to the object to which the reference is bound. When we fetch the value of a reference, we are really fetching the value of the object to which the reference is bound. Similarly, when we use a reference as an initializer, we are really using the object to which the reference is bound:
 Click here to view code image
 // ok: refVal3 is bound to the object to which refVal is bound, i.e., to ival int &refVal3 = refVal; // initializes i from the value in the object to which refVal is bound int i = refVal; // ok: initializes i to the same value as ival
 Because references are not objects, we may not define a reference to a reference.
 Reference Definitions
 
We can define multiple references in a single definition. Each identifier that is a reference must be preceded by the & symbol:
 Click here to view code image
C++ Primer, Fifth Edition
 
int i = 1024, i2 = 2048;  // i and i2 are both ints int &r = i, r2 = i2;      // r is a reference bound to i; r2 is an int int i3 = 1024, &ri = i3;  // i3 is an int; ri is a reference bound to i3 int &r3 = i3, &r4 = i2;   // both r3 and r4 are references With two exceptions that we¡¯ll cover in ¡ì 2.4.1 (p. 61) and ¡ì 15.2.3 (p. 601), the type of a reference and the object to which the reference refers must match exactly. Moreover, for reasons we¡¯ll explore in ¡ì 2.4.1, a reference may be bound only to an object, not to a literal or to the result of a more general expression:
 Click here to view code image
 int &refVal4 = 10;   // error: initializer must be an object double dval = 3.14; int &refVal5 = dval; // error: initializer must be an int object
 
Exercises Section 2.3.1 Exercise 2.15: Which of the following definitions, if any, are invalid? Why? (a) int ival = 1.01; (b) int &rval1 = 1.01; (c) int &rval2 = ival; (d) int &rval3; Exercise 2.16: Which, if any, of the following assignments are invalid? If they are valid, explain what they do.
 Click here to view code image int i = 0, &r1 = i; double d = 0, &r2 = d; (a) r2 = 3.14159; (b) r2 = r1; (c) i = r2; (d) r1 = d; Exercise 2.17: What does the following code print?
 Click here to view code image int i, &ri = i; i = 5; ri = 10; std::cout << i << " " << ri << std::endl;
 
 
2.3.2. Pointers
C++ Primer, Fifth Edition
 
A pointer is a compound type that ¡°points to¡± another type. Like references, pointers are used for indirect access to other objects. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need not be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.
 
 Warning Pointers are often hard to understand. Debugging problems due to pointer errors bedevil even experienced programmers.
 
 
We define a pointer type by writing a declarator of the form *d, where d is the name being defined. The * must be repeated for each pointer variable:
 Click here to view code image
 int *ip1, *ip2;  // both ip1 and ip2 are pointers to int double dp, *dp2; // dp2 is a pointer to double; dp is a double
 Taking the Address of an Object
 
A pointer holds the address of another object. We get the address of an object by usin the address-of operator (the & operator):
 Click here to view code image int ival = 42; int *p = &ival; // p holds the address of ival; p is a pointer to ival
 The second statement defines p as a pointer to int and initializes p to point to the int object named ival. Because references are not objects, they don¡¯t have addresses. Hence, we may not define a pointer to a reference. With two exceptions, which we cover in ¡ì 2.4.2 (p. 62) and ¡ì 15.2.3 (p. 601), the types of the pointer and the object to which it points must match:
 Click here to view code image double dval; double *pd = &dval;  // ok: initializer is the address of a double double *pd2 = pd;    // ok: initializer is a pointer to double int *pi = pd;  // error: types of pi and pd differ pi = &dval;    // error: assigning the address of a double to a pointer to int
 
C++ Primer, Fifth Edition
The types must match because the type of the pointer is used to infer the type of the object to which the pointer points. If a pointer addressed an object of another type, operations performed on the underlying object would fail.
 Pointer Value
 
The value (i.e., the address) stored in a pointer can be in one of four states: 1. It can point to an object. 2. It can point to the location just immediately past the end of an object. 3. It can be a null pointer, indicating that it is not bound to any object. 4. It can be invalid; values other than the preceding three are invalid.
 It is an error to copy or otherwise try to access the value of an invalid pointer. As when we use an uninitialized variable, this error is one that the compiler is unlikely to detect. The result of accessing an invalid pointer is undefined. Therefore, we must always know whether a given pointer is valid. Although pointers in cases 2 and 3 are valid, there are limits on what we can do with such pointers. Because these pointers do not point to any object, we may not use them to access the (supposed) object to which the pointer points. If we do attempt to access an object through such pointers, the behavior is undefined.
 
Using a Pointer to Access an Object
 
When a pointer points to an object, we can use the dereference operator (the * operator) to access that object:
 Click here to view code image int ival = 42; int *p = &ival; // p holds the address of ival; p is a pointer to ival cout << *p;     // * yields the object to which p points; prints 42
 Dereferencing a pointer yields the object to which the pointer points. We can assign to that object by assigning to the result of the dereference:
 Click here to view code image
 *p = 0;     // * yields the object; we assign a new value to ival through p cout << *p; // prints 0
 When we assign to *p, we are assigning to the object to which p points.
 
 Note We may dereference only a valid pointer that points to an object.
C++ Primer, Fifth Edition
 
 
Key Concept: Some Symbols Have Multiple Meanings Some symbols, such as & and *, are used as both an operator in an expression and as part of a declaration. The context in which a symbol is used determines what the symbol means:
 Click here to view code image int i = 42; int &r = i;   // & follows a type and is part of a declaration; r is a reference int *p;       // * follows a type and is part of a declaration; p is a pointer p = &i;       // & is used in an expression as the address-of operator *p = i;       // * is used in an expression as the dereference operator int &r2 = *p; // & is part of the declaration; * is the dereference operator In declarations, & and * are used to form compound types. In expressions, these same symbols are used to denote an operator. Because the same symbol is used with very different meanings, it can be helpful to ignore appearances and think of them as if they were different symbols.
 
 
Null Pointers
 
A null pointer does not point to any object. Code can check whether a pointer is null before attempting to use it. There are several ways to obtain a null pointer:
 Click here to view code image
 int *p1 = nullptr; // equivalent to int *p1 = 0; int *p2 = 0;       // directly initializes p2 from the literal constant 0 // must #include cstdlib int *p3 = NULL;    // equivalent to int *p3 = 0;
 
The most direct approach is to initialize the pointer using the literal nullptr, which was introduced by the new standard. nullptr is a literal that has a special type that can be converted (¡ì 2.1.2, p. 35) to any other pointer type. Alternatively, we can initialize a pointer to the literal 0, as we do in the definition of p2. Older programs sometimes use a preprocessor variable named NULL, which the cstdlib header defines as 0. We¡¯ll describe the preprocessor in a bit more detail in ¡ì 2.6.3 (p. 77). What¡¯s useful
C++ Primer, Fifth Edition
to know now is that the preprocessor is a program that runs before the compiler. Preprocessor variables are managed by the preprocessor, and are not part of the std namespace. As a result, we refer to them directly without the std:: prefix. When we use a preprocessor variable, the preprocessor automatically replaces the variable by its value. Hence, initializing a pointer to NULL is equivalent to initializing it to 0. ModernC++ programs generally should avoid using NULL and use nullptr instead. It is illegal to assign an int variable to a pointer, even if the variable¡¯s value 