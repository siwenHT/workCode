1 * 2 * 3 * 4 * 5 = 120
We might define this function as follows:
Click here to view code image
// factorial of val is val * (val - 1) * (val - 2) . . . * ((val - (val - 1)) * 1)
int fact(int val)
{
  int ret = 1; // local variable to hold the result as we calculate it
  while (val > 1)
  ret *= val--; // assign ret * val to ret and decrement val
  return ret; // return the result
}
Our function is named fact. It takes one int parameter and returns an int value.
Inside the while loop, we compute the factorial using the postfix decrement operat(¡ì 4.5, p. 147) to reduce the value of val by 1 on each iteration. The return
statement ends execution of fact and returns the value of ret.
Calling a Function
To call fact, we must supply an int value. The result of the call is also an int:
Click here to view code image
int main()
{
  int j = fact(5); // j equals 120, i.e., the result of fact(5)
  cout << "5! is " << j << endl; return 0;
}
A function call does two things: It initializes the function¡¯s parameters from the
corresponding arguments, and it transfers control to that function. Execution of the
calling function is suspended and execution of the called function begins.
Execution of a function begins with the (implicit) definition and initialization of its
parameters. Thus, when we call fact, the first thing that happens is that an int
variable named val is created. This variable is initialized by the argument in the calto fact, which in this case is 5.
Execution of a function ends when a return statement is encountered. Like a
function call, the return statement does two things: It returns the value (if any) in
the return, and it transfers control out of the called function back to the calling
function. The value returned by the function is used to initialize the result of the call
expression. Execution continues with whatever remains of the expression in which thcall appeared. Thus, our call to fact is equivalent to the following:
Click here to view code imageth Edition
int val = 5; // initialize val from the literal 5
int ret = 1; // code from the body of fact
while (val > 1)
 ret *= val--;
int j = ret; // initialize j as a copy of ret
Parameters and Arguments
Arguments are the initializers for a function¡¯s parameters. The first argument initializthe first parameter, the second argument initializes the second parameter, and so onAlthough we know which argument initializes which parameter, we have no
guarantees about the order in which arguments are evaluated (¡ì 4.1.3, p. 137). The
compiler is free to evaluate the arguments in whatever order it prefers.
The type of each argument must match the corresponding parameter in the same
way that the type of any initializer must match the type of the object it initializes. Wmust pass exactly the same number of arguments as the function has parameters.
Because every call is guaranteed to pass as many arguments as the function has
parameters, parameters are always initialized.
Because fact has a single parameter of type int, every time we call it we must
supply a single argument that can be converted (¡ì 4.11, p. 159) to int:
Click here to view code image
fact("hello"); // error: wrong argument type
fact(); // error: too few arguments
fact(42, 10, 0); // error: too many arguments
fact(3.14); // ok: argument is converted to int
The first call fails because there is no conversion from const char* to int. The
second and third calls pass the wrong number of arguments. The fact function mube called with one argument; it is an error to call it with any other number. The last
call is legal because there is a conversion from double to int. In this call, the
argument is implicitly converted to int (through truncation). After the conversion, thcall is equivalent to
fact(3);
Function Parameter List
A function¡¯s parameter list can be empty but cannot be omitted. Typically we define function with no parameters by writing an empty parameter list. For compatibility wiC, we also can use the keyword void to indicate that there are no parameters:
Click here to view code image
void f1(){ /* ... */ } // implicit void parameter listth Edition
void f2(void){ /* ... */ } // explicit void parameter list
A parameter list typically consists of a comma-separated list of parameters, each owhich looks like a declaration with a single declarator. Even when the types of two
parameters are the same, the type must be repeated:
Click here to view code image
int f3(int v1, v2) { /* ... */ } // error
int f4(int v1, int v2) { /* ... */ } // ok
No two parameters can have the same name. Moreover, local variables at thoutermost scope of the function may not use the same name as any parameter.
Parameter names are optional. However, there is no way to use an unnamed
parameter. Therefore, parameters ordinarily have names. Occasionally a function has parameter that is not used. Such parameters are often left unnamed, to indicate thathey aren¡¯t used. Leaving a parameter unnamed doesn¡¯t change the number of
arguments that a call must supply. A call must supply an argument for every
parameter, even if that parameter isn¡¯t used.
Function Return Type
Most types can be used as the return type of a function. In particular, the return typcan be void, which means that the function does not return a value. However, the
return type may not be an array type (¡ì 3.5, p. 113) or a function type. However, a
function may return a pointer to an array or a function. We¡¯ll see how to define
functions that return pointers (or references) to arrays in ¡ì 6.3.3 (p. 228) and how treturn pointers to functions in ¡ì 6.7 (p. 247).
6.1.1. Local Objects
In C++, names have scope (¡ì 2.2.4, p. 48), and objects have lifetimes. It is
important to understand both of these concepts.
? The scope of a name is the part of the program¡¯s text in which that name is
visible.
? The lifetime of an object is the time during the program¡¯s execution that the
object exists.
As we¡¯ve seen, the body of a function is a statement block. As usual, the block
forms a new scope in which we can define variables. Parameters and variables defininside a function body are referred to as local variables. They are ¡°local¡± to that
function and hide declarations of the same name made in an outer scope.th Edition
Exercises Section 6.1
Exercise 6.1: What is the difference between a parameter and argument?
Exercise 6.2: Indicate which of the following functions are in error and whSuggest how you might correct the problems.
(a) int f() {
 string s; // ... return s;
}
(b) f2(int i) { /* ... */ }
(c) int calc(int v1, int v1) /* ... */ }
(d) double square(double x) return x * x;
Exercise 6.3: Write and test your own version of fact.
Exercise 6.4: Write a function that interacts with the user, asking fonumber and generating the factorial of that number. Call this function fromain.
Exercise 6.5: Write a function to return the absolute value of its argumentObjects defined outside any function exist throughout the program¡¯s execution. Suobjects are created when the program starts and are not destroyed until the program
ends. The lifetime of a local variable depends on how it is defined.
Automatic Objects
The objects that correspond to ordinary local variables are created when the functiocontrol path passes through the variable¡¯s definition. They are destroyed when contrpasses through the end of the block in which the variable is defined. Objects that exonly while a block is executing are known as automatic objects. After execution
exits a block, the values of the automatic objects created in that block are undefinedParameters are automatic objects. Storage for the parameters is allocated when thfunction begins. Parameters are defined in the scope of the function body. Hence theare destroyed when the function terminates.
Automatic objects corresponding to the function¡¯s parameters are initialized by the
arguments passed to the function. Automatic objects corresponding to local variables
are initialized if their definition contains an initializer. Otherwise, they are default
initialized (¡ì 2.2.1, p. 43), which means that uninitialized local variables of built-in tyhave undefined values.
Local static Objectsth Edition
It can be useful to have a local variable whose lifetime continues across calls to the
function. We obtain such objects by defining a local variable as static. Each local
static object is initialized before the first time execution passes through the object¡¯s
definition. Local statics are not destroyed when a function ends; they are destroywhen the program terminates.
As a trivial example, here is a function that counts how many times it is called:
Click here to view code image
size_t count_calls()
{
  static size_t ctr = 0; // value will persist across call return ++ctr;
}
int main()
{
 for (size_t i = 0; i != 10; ++i) cout << count_calls() << endl; return 0;
}
This program will print the numbers from 1 through 10 inclusive.
Before control flows through the definition of ctr for the first time, ctr is created
and given an initial value of 0. Each call increments ctr and returns its new value.
Whenever count_calls is executed, the variable ctr already exists and has
whatever value was in that variable the last time the function exited. Thus, on the
second invocation, the value of ctr is 1, on the third it is 2, and so on.
If a local static has no explicit initializer, it is value initialized (¡ì 3.3.1, p. 98),
meaning that local statics of built-in type are initialized to zero.
Exercises Section 6.1.1
Exercise 6.6: Explain the differences between a parameter, a local variaband a local static variable. Give an example of a function in which eamight be useful.
Exercise 6.7: Write a function that returns 0 when it is first called and thgenerates numbers in sequence each time it is called again.
6.1.2. Function Declarations
Like any other name, the name of a function must be declared before we can use itAs with variables (¡ì 2.2.2, p. 45), a function may be defined only once but may be
declared multiple times. With one exception that we¡¯ll cover in ¡ì 15.3 (p. 603), we cth Edition
declare a function that is not defined so long as we never use that function.
A function declaration is just like a function definition except that a declaration has
no function body. In a declaration, a semicolon replaces the function body.
Because a function declaration has no body, there is no need for parameter nameHence, parameter names are often omitted in a declaration. Although parameter
names are not required, they can be used to help users of the function understand
what the function does:
Click here to view code image
// parameter names chosen to indicate that the iterators denote a range of values to prvoid print(vector<int>::const_iterator beg,
 vector<int>::const_iterator end);
These three elements¡ªthe return type, function name, and parameter types¡ªdescrithe function¡¯s interface. They specify all the information we need to call the functionFunction declarations are also known as the function prototype.
Function Declarations Go in Header Files
Recall that variables are declared in header files (¡ì 2.6.3, p. 76) and defined in sourfiles. For the same reasons, functions should be declared in header files and defined source files.
It may be tempting¡ªand would be legal¡ªto put a function declaration directly in
each source file that uses the function. However, doing so is tedious and error-proneWhen we use header files for our function declarations, we can ensure that all the
declarations for a given function agree. Moreover, if the interface to the function
changes, only one declaration has to be changed.
The source file that defines a function should include the header that contains thafunction¡¯s declaration. That way the compiler will verify that the definition and
declaration are consistent.
  Best Practices
The header that declares a function should be included in the source file thdefines that function.
Exercises Section 6.1.2
Exercise 6.8: Write a header file named Chapter6.h that contadeclarations for the functions you wrote for the exercises in ¡ì 6.1 (p. 205).th Edition
6.1.3. Separate Compilation
As our programs get more complicated, we¡¯ll want to store the various parts of the
program in separate files. For example, we might store the functions we wrote for thexercises in ¡ì 6.1 (p. 205) in one file and store code that uses these functions in
other source files. To allow programs to be written in logical parts, C++ supports whis commonly known as separate compilation. Separate compilation lets us split our
programs into several files, each of which can be compiled independently.
Compiling and Linking Multiple Source Files
As an example, assume that the definition of our fact function is in a file named
fact.cc and its declaration is in a header file named Chapter6.h. Our fact.cc
file, like any file that uses these functions, will include the Chapter6.h header. Westore a main function that calls fact in a second file named factMain.cc. To
produce an executable file, we must tell the compiler where to find all of the code wuse. We might compile these files as follows:
Click here to view code image
$ CC factMain.cc fact.cc # generates factMain.exe or a.ou$ CC factMain.cc fact.cc -o main # generates main main.exe
Here CC is the name of our compiler, $ is our system prompt, and # begins a
command-line comment. We can now run the executable file, which will run our maifunction.
If we have changed only one of our source files, we¡¯d like to recompile only the fithat actually changed. Most compilers provide a way to separately compile each file.
This process usually yields a file with the .obj (Windows) or .o (UNIX) file extensioindicating that the file contains object code.
The compiler lets us link object files together to form an executable. On the system
we use, we would separately compile our program as follows:
Click here to view code image
$ CC -c factMain.cc # generates factMain.o
$ CC -c fact.cc # generates fact.o
$ CC factMain.o fact.o # generates factMain.exe or a.out
$ CC factMain.o fact.o -o main # generates main or main.exe
You¡¯ll need to check with your compiler¡¯s user¡¯s guide to understand how to compile
and execute programs made up of multiple source files.
Exercises Section 6.1.3th Edition
Exercise 6.9: Write your own versions of the fact.cc and factMain.files. These files should include your Chapter6.h from the exercises in tprevious section. Use these files to understand how your compiler supposeparate compilation.
6.2. Argument Passing
As we¡¯ve seen, each time we call a function, its parameters are created and initializeby the arguments passed in the call.
  Note
Parameter initialization works the same way as variable initialization.
As with any other variable, the type of a parameter determines the interaction
between the parameter and its argument. If the parameter is a reference (¡ì 2.3.1, p50), then the parameter is bound to its argument. Otherwise, the argument¡¯s value copied.
When a parameter is a reference, we say that its corresponding argument is
¡°passed by reference¡± or that the function is ¡°called by reference.¡± As with any
other reference, a reference parameter is an alias for the object to which it is boundthat is, the parameter is an alias for its corresponding argument.
When the argument value is copied, the parameter and argument are independent
objects. We say such arguments are ¡°passed by value¡± or alternatively that the
function is ¡°called by value.¡±
6.2.1. Passing Arguments by Value
When we initialize a nonreference type variable, the value of the initializer is copied.
Changes made to the variable have no effect on the initializer:
Click here to view code image
int n = 0; // ordinary variable of type int
int i = n; // i is a copy of the value in n
i = 42; // value in i is changed; n is unchanged
Passing an argument by value works exactly the same way; nothing the function doeth Edition
to the parameter can affect the argument. For example, inside fact (¡ì 6.1, p. 202)
the parameter val is decremented:
Click here to view code image
ret *= val--; // decrements the value of val
Although fact changes the value of val, that change has no effect on the argumepassed to fact. Calling fact(i) does not change the value of i.
Pointer Parameters
Pointers (¡ì 2.3.2, p. 52) behave like any other nonreference type. When we copy a
pointer, the value of the pointer is copied. After the copy, the two pointers are
distinct. However, a pointer also gives us indirect access to the object to which that
pointer points. We can change the value of that object by assigning through the
pointer (¡ì 2.3.2, p. 55):
Click here to view code image
int n = 0, i = 42;
int *p = &n, *q = &i; // p points to n; q points to i
*p = 42; // value in n is changed; p is unchanged
p = q; // p now points to i; values in i and n aunchanged
The same behavior applies to pointer parameters:
Click here to view code image
// function that takes a pointer and sets the pointed-to value to zero
void reset(int *ip)
{
  *ip = 0; // changes the value of the object to which ip points
  ip = 0; // changes only the local copy of ip; the argument is unchanged
}
After a call to reset, the object to which the argument points will be 0, but the
pointer argument itself is unchanged:
Click here to view code image
int i = 42;
reset(&i); // changes i but not the address of i
cout << "i = " << i << endl; // prints i = 0
  Best Practices
Programmers accustomed to programming in C often use pointer parameteth Edition
to access objects outside a function. In C++, programmers generally use
reference parameters instead.
Exercises Section 6.2.1
Exercise 6.10: Using pointers, write a function to swap the values of twints. Test the function by calling it and printing the swapped values.
6.2.2. Passing Arguments by Reference
Recall that operations on a reference are actually operations on the object to which
the reference refers (¡ì 2.3.1, p. 50):
Click here to view code image
int n = 0, i = 42;
int &r = n; // r is bound to n (i.e., r is another name for n)
r = 42; // n is now 42
r = i; // n now has the same value as i
i = r; // i has the same value as n
Reference parameters exploit this behavior. They are often used to allow a function tchange the value of one or more of its arguments.
As one example, we can rewrite our reset program from the previous section to
take a reference instead of a pointer:
Click here to view code image
// function that takes a reference to an int and sets the given object to zero
void reset(int &i) // i is just another name for the object passed to reset
{
  i = 0; // changes the value of the object to which i refers
}
As with any other reference, a reference parameter is bound directly to the object
from which it is initialized. When we call this version of reset, i will be bound to
whatever int object we pass. As with any reference, changes made to i are made the object to which i refers. In this case, that object is the argument to reset.
When we call this version of reset, we pass an object directly; there is no need tpass its address:
Click here to view code imageth Edition
int j = 42;
reset(j); // j is passed by reference; the value in j is changed
cout << "j = " << j << endl; // prints j = 0
In this call, the parameter i is just another name for j. Any use of i inside reset a use of j.
Using References to Avoid Copies
It can be inefficient to copy objects of large class types or large containers. Moreovesome class types (including the IO types) cannot be copied. Functions must use
reference parameters to operate on objects of a type that cannot be copied.
As an example, we¡¯ll write a function to compare the length of two strings.
Because strings can be long, we¡¯d like to avoid copying them, so we¡¯ll make our
parameters references. Because comparing two strings does not involve changing
the strings, we¡¯ll make the parameters references to const (¡ì 2.4.1, p. 61):
Click here to view code image
// compare the length of two strings
bool isShorter(const string &s1, const string &s2)
{
 return s1.size() < s2.size();
}
As we¡¯ll see in ¡ì 6.2.3 (p. 213), functions should use references to const for
reference parameters they do not need to change.
  Best Practices
Reference parameters that are not changed inside a function should be
references to const.
Using Reference Parameters to Return Additional Information
A function can return only a single value. However, sometimes a function has more
than one value to return. Reference parameters let us effectively return multiple
results. As an example, we¡¯ll define a function named find_char that will return thposition of the first occurrence of a given character in a string. We¡¯d also like the
function to return a count of how many times that character occurs.
How can we define a function that returns a position and an occurrence count? Wcould define a new type that contains the position and the count. An easier solution to pass an additional reference argument to hold the occurrence count:th Edition
Click here to view code image
// returns the index of the first occurrence of c in s
// the reference parameter occurs counts how often c occurs
string::size_type find_char(const string &s, char c,
 string::size_type &occurs)
{
  auto ret = s.size(); // position of the first occurrence, if any
  occurs = 0; // set the occurrence count parameter
  for (decltype(ret) i = 0; i != s.size(); ++i) { if (s[i] == c) { if (ret == s.size())
  ret = i; // remember the first occurrence of c
  ++occurs; // increment the occurrence count
  }  }
  return ret; // count is returned implicitly in occurs
}
When we call find_char, we have to pass three arguments: a string in which to
look, the character to look for, and a size_type (¡ì 3.2.2, p. 88) object to hold the
occurrence count. Assuming s is a string, and ctr is a size_type object, we cacall find_char as follows:
auto index = find_char(s, 'o', ctr);
After the call, the value of ctr will be the number of times o occurs, and index wilrefer to the first occurrence if there is one. Otherwise, index will be equal to
s.size() and ctr will be zero.
Exercises Section 6.2.Exercise 6.11: Write and test your own version of reset that takes reference.
Exercise 6.12: Rewrite the program from exercise 6.10 in ¡ì 6.2.1 (p. 21to use references instead of pointers to swap the value of two ints. Whversion do you think would be easier to use and why?
Exercise 6.13: Assuming T is the name of a type, explain the differenbetween a function declared as void f(T) and void f(T&).
Exercise 6.14: Give an example of when a parameter should be a referentype. Give an example of when a parameter should not be a reference.
Exercise 6.15: Explain the rationale for the type of each of find_chaparameters In particular, why is s a reference to const but occurs is plain reference? Why are these parameters references, but the chparameter c is not? What would happen if we made s a plain referencWhat if we made occurs a reference to const?th Edition
6.2.3. const Parameters and Arguments
When we use parameters that are const, it is important to remember the discussioof top-level const from ¡ì 2.4.3 (p. 63). As we saw in that section, a top-level consis one that applies to the object itself:
Click here to view code image
const int ci = 42; // we cannot change ci; const is top-level
int i = ci; // ok: when we copy ci, its top-level const ignored
int * const p = &i; // const is top-level; we can't assign to p
*p = 0; // ok: changes through p are allowed; i is now Just as in any other initialization, when we copy an argument to initialize a parametetop-level consts are ignored. As a result, top-level const on parameters are
ignored. We can pass either a const or a nonconst object to a parameter that has
a top-level const:
Click here to view code image
void fcn(const int i) { /* fcn can read but not write to i */ }
We can call fcn passing it either a const int or a plain int. The fact that top-levconsts are ignored on a parameter has one possibly surprising implication:
Click here to view code image
void fcn(const int i) { /* fcn can read but not write to i */ }
void fcn(int i) { /* . . . */ } // error: redefines fcn(int)
In C++, we can define several different functions that have the same name. Howevewe can do so only if their parameter lists are sufficiently different. Because top-level
consts are ignored, we can pass exactly the same types to either version of fcn.
The second version of fcn is an error. Despite appearances, its parameter list doesndiffer from the list in the first version of fcn.
Pointer or Reference Parameters and const
Because parameters are initialized in the same way that variables are initialized, it cabe helpful to remember the general initialization rules. We can initialize an object wita low-level const from a nonconst object but not vice versa, and a plain reference
must be initialized from an object of the same type.
Click here to view code imageth Edition
int i = 42;
const int *cp = &i; // ok: but cp can't change i (¡ì 2.4.2 (p. 62))
const int &r = i; // ok: but r can't change i (¡ì 2.4.1 (p. 61))
const int &r2 = 42; // ok: (¡ì 2.4.1 (p. 61))
int *p = cp; // error: types of p and cp don't match (¡ì 2.4.2 (p. 62))
int &r3 = r; // error: types of r3 and r don't match (¡ì 2.4.1 (p. 61))
int &r4 = 42; // error: can't initialize a plain reference from a literal (¡ì 2.3.1 50))
Exactly the same initialization rules apply to parameter passing:
Click here to view code image
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i); // calls the version of reset that has an int* parameter
reset(&ci); // error: can't initialize an int* from a pointer to a const int objreset(i); // calls the version of reset that has an int& parameter
reset(ci); // error: can't bind a plain reference to the const object ci
reset(42); // error: can't bind a plain reference to a literal
reset(ctr); // error: types don't match; ctr has an unsigned type
// ok: find_char's first parameter is a reference to const
find_char("Hello World!", 'o', ctr);
We can call the reference version of reset (¡ì 6.2.2, p. 210) only on int objects. Wcannot pass a literal, an expression that evaluates to an int, an object that requires
conversion, or a const int object. Similarly, we may pass only an int* to the
pointer version of reset (¡ì 6.2.1, p. 209). On the other hand, we can pass a string
literal as the first argument to find_char (¡ì 6.2.2, p. 211). That function¡¯s referenparameter is a reference to const, and we can initialize references to const from
literals.
Use Reference to const When Possible
It is a somewhat common mistake to define parameters that a function does not
change as (plain) references. Doing so gives the function¡¯s caller the misleading
impression that the function might change its argument¡¯s value. Moreover, using a
reference instead of a reference to const unduly limits the type of arguments that
can be used with the function. As we¡¯ve just seen, we cannot pass a const object, a literal, or an object that requires conversion to a plain reference parameter.
The effect of this mistake can be surprisingly pervasive. As an example, consider ofind_char function from ¡ì 6.2.2 (p. 211). That function (correctly) made its striparameter a reference to const. Had we defined that parameter as a plain stringth Edition
Click here to view code image
// bad design: the first parameter should be a const string&
string::size_type find_char(string &s, char c,
 string::size_type &occurs);
we could call find_char only on a string object. A call such as
Click here to view code image
find_char("Hello World", 'o', ctr);
would fail at compile time.
More subtly, we could not use this version of find_char from other functions tha(correctly) define their parameters as references to const. For example, we might
want to use find_char inside a function that determines whether a string
represents a sentence:
Click here to view code image
bool is_sentence(const string &s)
{
  // if there's a single period at the end of s, then s is a sentence
  string::size_type ctr = 0; return find_char(s, '.', ctr) == s.size() - 1 && ctr 1;
}
If find_char took a plain string&, then this call to find_char would be a
compile-time error. The problem is that s is a reference to a const string, but
find_char was (incorrectly) defined to take a plain reference.
It might be tempting to try to fix this problem by changing the type of the
parameter in is_sentence. But that fix only propagates the error¡ªcallers of
is_sentence could pass only nonconst stringsThe right way to fix this problem is to fix the parameter in find_char. If it¡¯s not
possible to change find_char, then define a local string copy of s inside
is_sentence and pass that string to find_char.
6.2.4. Array Parameters
Arrays have two special properties that affect how we define and use functions that
operate on arrays: We cannot copy an array (¡ì 3.5.1, p. 114), and when we use an
array it is (usually) converted to a pointer (¡ì 3.5.3, p. 117). Because we cannot copy
an array, we cannot pass an array by value. Because arrays are converted to pointerwhen we pass an array to a function, we are actually passing a pointer to the array¡¯first element.
Even though we cannot pass an array by value, we can write a parameter that looth Edition
like an array:
Exercises Section 6.2.3
Exercise 6.16: The following function, although legal, is less useful than might be. Identify and correct the limitation on this function:
Click here to view code image
bool is_empty(string& s) { return s.empty(); }
Exercise 6.17: Write a function to determine whether a string contaiany capital letters. Write a function to change a string to all lowercase. the parameters you used in these functions have the same type? If so, whIf not, why not?
Exercise 6.18: Write declarations for each of the following functions. Whyou write these declarations, use the name of the function to indicate whthe function does.
(a) A function named compare that returns a bool and has two parametethat are references to a class named matrix.
(b) A function named change_val that returns a vector<int> iterator
and takes two parameters: One is an int and the other is an iterator for vector<int>.
Exercise 6.19: Given the following declarations, determine which calls alegal and which are illegal. For those that are illegal, explain why.
Click here to view code image
double calc(double);
int count(const string &, char);
int sum(vector<int>::iterator, vector<int>::iteratoint);
vector<int> vec(10);
(a) calc(23.4, 55.1);
(b) count("abcda", 'a');
(c) calc(66);
(d) sum(vec.begin(), vec.end(), 3.8)Exercise 6.20: When should reference parameters be references to consWhat happens if we make a parameter a plain reference when it could be reference to const?
Click here to view code image
// despite appearances, these three declarations of print are equivalentth Edition
// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]); // shows the intent that the function takes array
void print(const int[10]); // dimension for documentation purposes best)
Regardless of appearances, these declarations are equivalent: Each declares a functiwith a single parameter of type const int*. When the compiler checks a call to
print, it checks only that the argument has type const int*:
Click here to view code image
int i = 0, j[2] = {0, 1};
print(&i); // ok: &i is int*
print(j); // ok: j is converted to an int* that points to j[0]
If we pass an array to print, that argument is automatically converted to a pointer
to the first element in the array; the size of the array is irrelevant.
  Warning
As with any code that uses arrays, functions that take array parameters muensure that all uses of the array stay within the array bounds.
Because arrays are passed as pointers, functions ordinarily don¡¯t know the size of
the array they are given. They must rely on additional information provided by the
caller. There are three common techniques used to manage pointer parameters.
Using a Marker to Specify the Extent of an Array
The first approach to managing array arguments requires the array itself to contain aend marker. C-style character strings (¡ì 3.5.4, p. 122) are an example of this
approach. C-style strings are stored in character arrays in which the last character othe string is followed by a null character. Functions that deal with C-style strings stoprocessing the array when they see a null character:
Click here to view code image
void print(const char *cp)
{
  if (cp) // if cp is not a null pointer
  while (*cp) // so long as the character it points to is not a ncharacter
  cout << *cp++; // print the character and advance the pointer
}th Edition
This convention works well for data where there is an obvious end-marker value (likthe null character) that does not appear in ordinary data. It works less well with datsuch as ints, where every value in the range is a legitimate value.
Using the Standard Library Conventions
A second technique used to manage array arguments is to pass pointers to the first
and one past the last element in the array. This approach is inspired by techniques
used in the standard library. We¡¯ll learn more about this style of programming in ParII. Using this approach, we¡¯ll print the elements in an array as follows:
Click here to view code image
void print(const int *beg, const int *end)
{
  // print every element starting at beg up to but not including end
  while (beg != end)
  cout << *beg++ << endl; // print the current element
  // and advance the pointer
}
The while uses the dereference and postfix increment operators (¡ì 4.5, p. 148) to
print the current element and advance beg one element at a time through the arrayThe loop stops when beg is equal to end.
To call this function, we pass two pointers¡ªone to the first element we want to
print and one just past the last element:
Click here to view code image
int j[2] = {0, 1};
// j is converted to a pointer to the first element in j
// the second argument is a pointer to one past the end of j
print(begin(j), end(j)); // begin and end functions, see ¡ì 3.5.3 (p. 118This function is safe, as long as the caller correctly calculates the pointers. Here we the library begin and end functions (¡ì 3.5.3, p. 118) provide those pointers.
Explicitly Passing a Size ParameteA third approach for array arguments, which is common in C programs and older C+programs, is to define a second parameter that indicates the size of the array. Using
this approach, we¡¯ll rewrite print as follows:
Click here to view code image
// const int ia[] is equivalent to const int* ia
// size is passed explicitly and used to control access to elements of iath Edition
void print(const int ia[], size_t size)
{
 for (size_t i = 0; i != size; ++i) { cout << ia[i] << endl; }
}
This version uses the size parameter to determine how many elements there are to
print. When we call print, we must pass this additional parameter:
Click here to view code image
int j[] = { 0, 1 }; // int array of size 2
print(j, end(j) - begin(j));
The function executes safely as long as the size passed is no greater than the actuasize of the array.
Array Parameters and const
Note that all three versions of our print function defined their array parameters as
pointers to const. The discussion in ¡ì 6.2.3 (p. 213) applies equally to pointers as references. When a function does not need write access to the array elements, the
array parameter should be a pointer to const (¡ì 2.4.2, p. 62). A parameter should a plain pointer to a nonconst type only if the function needs to change element
values.
Array Reference Parameters
Just as we can define a variable that is a reference to an array (¡ì 3.5.1, p. 114), we
can define a parameter that is a reference to an array. As usual, the reference
parameter is bound to the corresponding argument, which in this case is an array:
Click here to view code image
// ok: parameter is a reference to an array; the dimension is part of the type
void print(int (&arr)[10])
{
 for (auto elem : arr) cout << elem << endl;
}
  Note
The parentheses around &arr are necessary (¡ì 3.5.1, p. 114):
Click here to view code image
f(int &arr[10]) // error: declares arr as an array of referencesth Edition
f(int (&arr)[10]) // ok: arr is a reference to an array of ten ints
Because the size of an array is part of its type, it is safe to rely on the dimension the body of the function. However, the fact that the size is part of the type limits the
usefulness of this version of print. We may call this function only for an array of
exactly ten ints:
Click here to view code image
int i = 0, j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};
print(&i); // error: argument is not an array of ten intprint(j); // error: argument is not an array of ten ints
print(k); // ok: argument is an array of ten ints
We¡¯ll see in ¡ì 16.1.1 (p. 654) how we might write this function in a way that would
allow us to pass a reference parameter to an array of any size.
Passing a Multidimensional ArraRecall that there are no multidimensional arrays in C++ (¡ì 3.6, p. 125). Instead, whappears to be a multidimensional array is an array of arrays.
As with any array, a multidimensional array is passed as a pointer to its first
element (¡ì 3.6, p. 128). Because we are dealing with an array of arrays, that elemeis an array, so the pointer is a pointer to an array. The size of the second (and any
subsequent) dimension is part of the element type and must be specified:
Click here to view code image
// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }
declares matrix as a pointer to an array of ten ints.
  Note
Again, the parentheses around *matrix are necessary:
Click here to view code image
int *matrix[10]; // array of ten pointers
int (*matrix)[10]; // pointer to an array of ten ints
We can also define our function using array syntax. As usual, the compiler ignores
the first dimension, so it is best not to include it:th Edition
Click here to view code image
// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }
declares matrix to be what looks like a two-dimensional array. In fact, the parametis a pointer to an array of ten ints.
6.2.5. main: Handling Command-Line Options
It turns out that main is a good example of how C++ programs pass arrays to
functions. Up to now, we have defined main with an empty parameter list:
int main() { ... However, we sometimes need to pass arguments to main. The most common use oarguments to main is to let the user specify a set of options to guide the operation the program. For example, assuming our main program is in an executable file namprog, we might pass options to the program as follows:
Exercises Section 6.2.4
Exercise 6.21: Write a function that takes an int and a pointer to an iand returns the larger of the int value or the value to which the poinpoints. What type should you use for the pointer?
Exercise 6.22: Write a function to swap two int pointers.
Exercise 6.23: Write your own versions of each of the print functiopresented in this section. Call each of these functions to print i and defined as follows:
int i = 0, j[2] = {0, 1};
Exercise 6.24: Explain the behavior of the following function. If there aproblems in the code, explain what they are and how you might fix them.
Click here to view code image
void print(const int ia[10])
{
 for (size_t i = 0; i != 10; ++i) cout << ia[i] << endl;
}
prog -d -o ofile data0
Such command-line options are passed to main in two (optional) parameters:
Click here to view code image
parameters Local variables declared inside the function parameter list.
Parameters are initialized by the arguments provided in each function callpass by reference Description of how arguments are passed to parameters of
reference type. Reference parameters work the same way as any other use of
references; the parameter is bound to its corresponding argument.
pass by value How arguments are passed to parameters of a nonreference type.
A nonreference parameter is a copy of the value of its corresponding argument.
preprocessor macro Preprocessor facility that behaves like an inline function.
Aside from assert, modern C++ programs make very little use of preprocessor
macros.
recursion loop Description of a recursive function that omits a stoppincondition and which calls itself until exhasuting the program stack.
recursive function Function that calls itself directly or indirectly.
return type Part of a function declaration that specifies the type of the value
that the function returns.
separate compilation Ability to split a program into multiple separate source
files.
trailing return type Return type specified after the parameter list.
viable functions Subset of the candidate functions that could match a given call.
Viable functions have the same number of parameters as arguments to the call,
and each argument type can be converted to the corresponding parameter type.
() operator Call operator. Executes a function. The name of a function or a
function pointer precedes the parentheses, which enclose a (possibly empty)
comma-separated list of arguments.
Chapter 7. Classes
Contents
Section 7.1 Defining Abstract Data Types
Section 7.2 Access Control and Encapsulation
Section 7.3 Additional Class Features
Section 7.4 Class Scope
Section 7.5 Constructors Revisited Edition
Section 7.6 static Class Members
Chapter Summary
Defined Terms
n C++ we use classes to define our own data types. By defining types that mirror
concepts in the problems we are trying to solve, we can make our programs easier to
write, debug, and modify.
This chapter continues the coverage of classes begun in Chapter 2. Here we will
focus on the importance of data abstraction, which lets us separate the
mplementation of an object from the operations that that object can perform. In
Chapter 13 we¡¯ll learn how to control what happens when objects are copied, moved,
assigned, or destroyed. In Chapter 14 we¡¯ll learn how to define our own operators.
The fundamental ideas behind classes are data abstraction and encapsulation.
Data abstraction is a programming (and design) technique that relies on the
separation of interface and implementation. The interface of a class consists of
the operations that users of the class can execute. The implementation includes the
class¡¯ data members, the bodies of the functions that constitute the interface, and any
functions needed to define the class that are not intended for general use.
Encapsulation enforces the separation of a class¡¯ interface and implementation. A
class that is encapsulated hides its implementation¡ªusers of the class can use the
nterface but have no access to the implementation.
A class that uses data abstraction and encapsulation defines an abstract data
type. In an abstract data type, the class designer worries about how the class is
mplemented. Programmers who use the class need not know how the type works.
They can instead think abstractly about what the type does.
7.1. Defining Abstract Data Types
The Sales_item class that we used in Chapter 1 is an abstract data type. We use a
Sales_item object by using its interface (i.e., the operations described in ¡ì 1.5.1 (p.
20)). We have no access to the data members stored in a Sales_item object.
ndeed, we don¡¯t even know what data members that class has.
Our Sales_data class (¡ì 2.6.1, p. 72) is not an abstract data type. It lets users of
the class access its data members and forces users to write their own operations. To
make Sales_data an abstract type, we need to define operations for users of
Sales_data to use. Once Sales_data defines its own operations, we can
encapsulate (that is, hide) its data members.
7.1.1. Designing the Sales_data Class Edition
Ultimately, we want Sales_data to support the same set of operations as the
Sales_item class. The Sales_item class had one member function (¡ì 1.5.2, p.
23), named isbn, and supported the +, =, +=, <<, and >> operators.
We¡¯ll learn how to define our own operators in Chapter 14. For now, we¡¯ll define
ordinary (named) functions for these operations. For reasons that we will explain in ¡ì
14.1 (p. 555), the functions that do addition and IO will not be members of
Sales_data. Instead, we¡¯ll define those functions as ordinary functions. The function
that handles compound assignment will be a member, and for reasons we¡¯ll explain in
¡ì 7.1.5 (p. 267), our class doesn¡¯t need to define assignment.
Thus, the interface to Sales_data consists of the following operations:
? An isbn member function to return the object¡¯s ISBN
? A combine member function to add one Sales_data object into another
? A function named add to add two Sales_data objects
? A read function to read data from an istream into a Sales_data object
? A print function to print the value of a Sales_data object on an ostream
Key Concept: Different Kinds of Programming Roles
Programmers tend to think about the people who will run their applications as
users. Similarly a class designer designs and implements a class for users of
that class. In this case, the user is a programmer, not the ultimate user of
the application.
When we refer to a user, the context makes it clear which kind of user is
meant. If we speak of user code or the user of the Sales_data class, we
mean a programmer who is using a class. If we speak of the user of the
bookstore application, we mean the manager of the store who is running the
application.
  Note
C++ programmers tend to speak of users interchangeably as users of
the application or users of a class.
In simple applications, the user of a class and the designer of the class
might be one and the same person. Even in such cases, it is useful to keep
the roles distinct. When we design the interface of a class, we should think
about how easy it will be to use the class. When we use the class, we
shouldn¡¯t think about how the class works.
Authors of successful applications do a good job of understanding and
implementing the needs of the application¡¯s users. Similarly, good class Edition
designers pay close attention to the needs of the programmers who will use
the class. A well-designed class has an interface that is intuitive and easy to
use and has an implementation that is efficient enough for its intended use.
Using the Revised Sales_data Class
Before we think about how to implement our class, let¡¯s look at how we can use our
nterface functions. As one example, we can use these functions to write a version of
the bookstore program from ¡ì 1.6 (p. 24) that works with Sales_data objects rather
than Sales_items:
Click here to view code image
Sales_data total; // variable to hold the running sum
if (read(cin, total)) { // read the first transactio Sales_data trans; // variable to hold data for the next transaction
  while(read(cin, trans)) { // read the remaining transactions
  if (total.isbn() == trans.isbn()) // check the isbns
  total.combine(trans); // update the running total
  else {
  print(cout, total) << endl; // print the results
  total = trans; // process the next book
  }  }
  print(cout, total) << endl; // print the last transaction
} else { // there was no input
  cerr << "No data?!" << endl; // notify the user
}
We start by defining a Sales_data object to hold the running total. Inside the if
condition, we call read to read the first transaction into total. This condition works
like other loops we¡¯ve written that used the >> operator. Like the >> operator, our
read function will return its stream parameter, which the condition checks (¡ì 4.11.2,
p. 162). If the read fails, we fall through to the else to print an error message.
If there are data to read, we define trans, which we¡¯ll use to hold each
transaction. The condition in the while also checks the stream returned by read. So
long as the input operations in read succeed, the condition succeeds and we have
another transaction to process.
Inside the while, we call the isbn members of total and trans to fetch their
respective ISBNs. If total and trans refer to the same book, we call combine to
add the components of trans into the running total in total. If trans represents a
new book, we call print to print the total for the previous book. Because print
returns a reference to its stream parameter, we can use the result of print as the Edition
left-hand operand of the <<. We do so to print a newline following the output
generated by print. We next assign trans to total, thus setting up to process the
records for the next book in the file.
After we have exhausted the input, we have to remember to print the data for the
ast transaction, which we do in the call to print following the while loop.
Exercises Section 7.1.Exercise 7.1: Write a version of the transaction-processing program from ¡ì
1.6 (p. 24) using the Sales_data class you defined for the exercises in ¡ì
2.6.1 (p. 72).
7.1.2. Defining the Revised Sales_data Class
Our revised class will have the same data members as the version we defined in ¡ì
2.6.1 (p. 72): bookNo, a string representing the ISBN; units_sold, an unsigned
that says how many copies of the book were sold; and revenue, a double
representing the total revenue for those sales.
As we¡¯ve seen, our class will also have two member functions, combine and isbn.
n addition, we¡¯ll give Sales_data another member function to return the average
price at which the books were sold. This function, which we¡¯ll name avg_price, isn¡¯t
ntended for general use. It will be part of the implementation, not part of the
nterface.
We define (¡ì 6.1, p. 202) and declare (¡ì 6.1.2, p. 206) member functions similarly
to ordinary functions. Member functions must be declared inside the class. Member
functions may be defined inside the class itself or outside the class body. Nonmember
functions that are part of the interface, such as add, read, and print, are declared
and defined outside the class.
With this knowledge, we¡¯re ready to write our revised version of Sales_data:
Click here to view code image
struct Sales_data {
  // new members: operations on Sales_data object std::string isbn() const { return bookNo; } Sales_data& combine(const Sales_data&); double avg_price() const;
  // data members are unchanged from ¡ì 2.6.1 (p. 72)
  std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;
}; Edition
// nonmember Sales_data interface functions
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
  Note
Functions defined in the class are implicitly inline (¡ì 6.5.2, p. 238).
Defining Member FunctionAlthough every member must be declared inside its class, we can define a member
function¡¯s body either inside or outside of the class body. In Sales_data, isbn is
defined inside the class; combine and avg_price will be defined elsewhere.
We¡¯ll start by explaining the isbn function, which returns a string and has an
empty parameter list:
Click here to view code image
std::string isbn() const { return bookNo; }
As with any function, the body of a member function is a block. In this case, the block
contains a single return statement that returns the bookNo data member of a
Sales_data object. The interesting thing about this function is how it gets the object
from which to fetch the bookNo member.
Introducing this
Let¡¯s look again at a call to the isbn member functiontotal.isbn()
Here we use the dot operator (¡ì 4.6, p. 150) to fetch the isbn member of the object
named total, which we then call.
With one exception that we¡¯ll cover in ¡ì 7.6 (p. 300), when we call a member
function we do so on behalf of an object. When isbn refers to members of
Sales_data (e.g., bookNo), it is referring implicitly to the members of the object on
which the function was called. In this call, when isbn returns bookNo, it is implicitly
returning total.bookNo.
Member functions access the object on which they were called through an extra,
mplicit parameter named this. When we call a member function, this is initialized
with the address of the object on which the function was invoked. For example, when
we call Edition
total.isbn()
the compiler passes the address of total to the implicit this parameter in isbn. It
is as if the compiler rewrites this call as
Click here to view code image
// pseudo-code illustration of how a call to a member function is translated
Sales_data::isbn(&total)
which calls the isbn member of Sales_data passing the address of total.
Inside a member function, we can refer directly to the members of the object on
which the function was called. We do not have to use a member access operator to
use the members of the object to which this points. Any direct use of a member of
the class is assumed to be an implicit reference through this. That is, when isbn
uses bookNo, it is implicitly using the member to which this points. It is as if we
had written this->bookNo.
The this parameter is defined for us implicitly. Indeed, it is illegal for us to define
a parameter or variable named this. Inside the body of a member function, we can
use this. It would be legal, although unnecessary, to define isbn as
Click here to view code image
std::string isbn() const { return this->bookNo; }
Because this is intended to always refer to ¡°this¡± object, this is a const pointer
(¡ì 2.4.2, p. 62). We cannot change the address that this holds.
Introducing const Member Functions
The other important part about the isbn function is the keyword const that follows
the parameter list. The purpose of that const is to modify the type of the implicit
this pointer.
By default, the type of this is a const pointer to the nonconst version of the
class type. For example, by default, the type of this in a Sales_data member
function is Sales_data *const. Although this is implicit, it follows the normal
initialization rules, which means that (by default) we cannot bind this to a const
object (¡ì 2.4.2, p. 62). This fact, in turn, means that we cannot call an ordinary
member function on a const object.
If isbn were an ordinary function and if this were an ordinary pointer parameter,
we would declare this as const Sales_data *const. After all, the body of isbn
doesn¡¯t change the object to which this points, so our function would be more
flexible if this were a pointer to const (¡ì 6.2.3, p. 213).
However, this is implicit and does not appear in the parameter list. There is no
place to indicate that this should be a pointer to const. The language resolves this Edition
problem by letting us put const after the parameter list of a member function. A
const following the parameter list indicates that this is a pointer to const. Member
functions that use const in this way are const member functions.
We can think of the body of isbn as if it were written as
Click here to view code image
// pseudo-code illustration of how the implicit this pointer is used
// this code is illegal: we may not explicitly define the this pointer ourselves
// note that this is a pointer to const because isbn is a const member
std::string Sales_data::isbn(const Sales_data *const this)
{ return this->isbn; }
The fact that this is a pointer to const means that const member functions
cannot change the object on which they are called. Thus, isbn may read but not
write to the data members of the objects on which it is called.
  Note
Objects that are const, and references or pointers to const objects, may
call only const member functions.
Class Scope and Member Functions
Recall that a class is itself a scope (¡ì 2.6.1, p. 72). The definitions of the member
functions of a class are nested inside the scope of the class itself. Hence, isbn¡¯s use
of the name bookNo is resolved as the data member defined inside Sales_data.
It is worth noting that isbn can use bookNo even though bookNo is defined after
isbn. As we¡¯ll see in ¡ì 7.4.1 (p. 283), the compiler processes classes in two steps¡ª
the member declarations are compiled first, after which the member function bodies, if
any, are processed. Thus, member function bodies may use other members of their
class regardless of where in the class those members appear.
Defining a Member Function outside the Class
As with any other function, when we define a member function outside the class body,
the member¡¯s definition must match its declaration. That is, the return type,
parameter list, and name must match the declaration in the class body. If the member
was declared as a const member function, then the definition must also specify
const after the parameter list. The name of a member defined outside the class must
nclude the name of the class of which it is a member:
Click here to view code image Edition
double Sales_data::avg_price() const {
 if (units_sold) return revenue/units_sold; else return 0;
}
The function name, Sales_data::avg_price, uses the scope operator (¡ì 1.2, p. 8)
to say that we are defining the function named avg_price that is declared in the
scope of the Sales_data class. Once the compiler sees the function name, the rest
of the code is interpreted as being inside the scope of the class. Thus, when
avg_price refers to revenue and units_sold, it is implicitly referring to the
members of Sales_data.
Defining a Function to Return ¡°This¡± Object
The combine function is intended to act like the compound assignment operator, +=.
The object on which this function is called represents the left-hand operand of the
assignment. The right-hand operand is passed as an explicit argument:
Click here to view code image
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
  units_sold += rhs.units_sold; // add the members of rhs into
  revenue += rhs.revenue; // the members of ''this'' object
  return *this; // return the object on which the function was called
}
When our transaction-processing program calls
Click here to view code image
total.combine(trans); // update the running total
the address of total is bound to the implicit this parameter and rhs is bound to
trans. Thus, when combine executes
Click here to view code image
units_sold += rhs.units_sold; // add the members of rhs into
the effect is to add total.units_sold and trans.units_sold, storing the result
back into total.units_sold.
The interesting part about this function is its return type and the return
statement. Ordinarily, when we define a function that operates like a built-in operator,
our function should mimic the behavior of that operator. The built-in assignment
operators return their left-hand operand as an lvalue (¡ì 4.4, p. 144). To return an
value, our combine function must return a reference (¡ì 6.3.2, p. 226). Because the
eft-hand operand is a Sales_data object, the return type is Sales_data&. Edition
As we¡¯ve seen, we do not need to use the implicit this pointer to access the
members of the object on which a member function is executing. However, we do
need to use this to access the object as a whole:
Click here to view code image
return *this; // return the object on which the function was called
Here the return statement dereferences this to obtain the object on which the
function is executing. That is, for the call above, we return a reference to total.
Exercises Section 7.1.2
Exercise 7.2: Add the combine and isbn members to the Sales_data
class you wrote for the exercises in ¡ì 2.6.2 (p. 76).
Exercise 7.3: Revise your transaction-processing program from ¡ì 7.1.1 (p.
256) to use these members.
Exercise 7.4: Write a class named Person that represents the name and
address of a person. Use a string to hold each of these elements.
Subsequent exercises will incrementally add features to this class.
Exercise 7.5: Provide operations in your Person class to return the name
and address. Should these functions be const? Explain your choice.
7.1.3. Defining Nonmember Class-Related Functions
Class authors often define auxiliary functions, such as our add, read, and print
functions. Although such functions define operations that are conceptually part of the
nterface of the class, they are not part of the class itself.
We define nonmember functions as we would any other function. As with any other
function, we normally separate the declaration of the function from its definition (¡ì
6.1.2, p. 206). Functions that are conceptually part of a class, but not defined inside
the class, are typically declared (but not defined) in the same header as the class
tself. That way users need to include only one file to use any part of the interface.
  Note
Ordinarily, nonmember functions that are part of the interface of a class
should be declared in the same header as the class itself.
Defining the read and print Functions Edition
The read and print functions do the same job as the code in ¡ì 2.6.2 (p. 75) and
not surprisingly, the bodies of our functions look a lot like the code presented there:
Click here to view code image
// input transactions contain ISBN, number of copies sold, and sales price
istream &read(istream &is, Sales_data &item)
{
 double price = 0; is >> item.bookNo >> item.units_sold >> price; item.revenue = price * item.units_sold; return is;
}
ostream &print(ostream &os, const Sales_data &item)
{
 os << item.isbn() << " " << item.units_sold << " " << item.revenue << " " << item.avg_price(); return os;
}
The read function reads data from the given stream into the given object. The print
function prints the contents of the given object on the given stream.
However, there are two points worth noting about these functions. First, both read
and write take a reference to their respective IO class types. The IO classes are
types that cannot be copied, so we may only pass them by reference (¡ì 6.2.2, p.
210). Moreover, reading or writing to a stream changes that stream, so both functions
take ordinary references, not references to const.
The second thing to note is that print does not print a newline. Ordinarily,
functions that do output should do minimal formatting. That way user code can decide
whether the newline is needed.
Defining the add Function
The add function takes two Sales_data objects and returns a new Sales_data
representing their sum:
Click here to view code image
Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
  Sales_data sum = lhs; // copy data members from lhs into sum
  sum.combine(rhs); // add data members from rhs into sum
  return sum;
}
In the body of the function we define a new Sales_data object named sum to hold
the sum of our two transactions. We initialize sum as a copy of lhs. By default,
copying a class object copies that object¡¯s members. After the copy, the bookNo, Edition
units_sold, and revenue members of sum will have the same values as those in
lhs. Next we call combine to add the units_sold and revenue members of rhs
nto sum. When we¡¯re done, we return a copy of sum.
Exercises Section 7.1.3
Exercise 7.6: Define your own versions of the add, read, and print
functions.
Exercise 7.7: Rewrite the transaction-processing program you wrote for the
exercises in ¡ì 7.1.2 (p. 260) to use these new functions.
Exercise 7.8: Why does read define its Sales_data parameter as a plain
reference and print define its parameter as a reference to const?
Exercise 7.9: Add operations to read and print Person objects to the code
you wrote for the exercises in ¡ì 7.1.2 (p. 260).
Exercise 7.10: What does the condition in the following if statement do?
if (read(read(cin, data1), data2))
7.1.4. Constructors
Each class defines how objects of its type can be initialized. Classes control object
nitialization by defining one or more special member functions known as
constructors. The job of a constructor is to initialize the data members of a class
object. A constructor is run whenever an object of a class type is created.
In this section, we¡¯ll introduce the basics of how to define a constructor.
Constructors are a surprisingly complex topic. Indeed, we¡¯ll have more to say about
constructors in ¡ì 7.5 (p. 288), ¡ì 15.7 (p. 622), and ¡ì 18.1.3 (p. 777), and in Chapter
13.
Constructors have the same name as the class. Unlike other functions, constructors
have no return type. Like other functions, constructors have a (possibly empty)
parameter list and a (possibly empty) function body. A class can have multiple
constructors. Like any other overloaded function (¡ì 6.4, p. 230), the constructors must
differ from each other in the number or types of their parametersUnlike other member functions, constructors may not be declared as const (¡ì
7.1.2, p. 258). When we create a const object of a class type, the object does not
assume its ¡°constness¡± until after the constructor completes the object¡¯s initialization.
Thus, constructors can write to const objects during their construction.
The Synthesized Default Constructor Edition
Our Sales_data class does not define any constructors, yet the programs we¡¯ve
written that use Sales_data objects compile and run correctly. As an example, the
program on page 255 defined two objects:
Click here to view code image
Sales_data total; // variable to hold the running sum
Sales_data trans; // variable to hold data for the next transaction
The question naturally arises: How are total and trans initialized?
We did not supply an initializer for these objects, so we know that they are default
nitialized (¡ì 2.2.1, p. 43). Classes control default initialization by defining a special
constructor, known as the default constructor. The default constructor is one that
takes no arguments.
As we¡¯ll, see the default constructor is special in various ways, one of which is that
f our class does not explicitly define any constructors, the compiler will implicitly
define the default constructor for us
The compiler-generated constructor is known as the synthesized default
constructor. For most classes, this synthesized constructor initializes each data
member of the class as follows:
? If there is an in-class initializer (¡ì 2.6.1, p. 73), use it to initialize the member.
? Otherwise, default-initialize (¡ì 2.2.1, p. 43) the member.
Because Sales_data provides initializers for units_sold and revenue, the
synthesized default constructor uses those values to initialize those members. It
default initializes bookNo to the empty string.
Some Classes Cannot Rely on the Synthesized Default Constructor
Only fairly simple classes¡ªsuch as the current definition of Sales_data¡ªcan rely on
the synthesized default constructor. The most common reason that a class must define
ts own default constructor is that the compiler generates the default for us only if we
do not define any other constructors for the class. If we define any constructors, the
class will not have a default constructor unless we define that constructor ourselves.
The basis for this rule is that if a class requires control to initialize an object in one
case, then the class is likely to require control in all cases.
  Note
The compiler generates a default constructor automatically only if a class
declares no constructors. Edition
A second reason to define the default constructor is that for some classes, the
synthesized default constructor does the wrong thing. Remember that objects of builtn or compound type (such as arrays and pointers) that are defined inside a block
have undefined value when they are default initialized (¡ì 2.2.1, p. 43). The same rule
applies to members of built-in type that are default initialized. Therefore, classes that
have members of built-in or compound type should ordinarily either initialize those
members inside the class or define their own version of the default constructor.
Otherwise, users could create objects with members that have undefined value.
  Warning
Classes that have members of built-in or compound type usually should rely
on the synthesized default constructor only if all such members have in-class
initializers.
A third reason that some classes must define their own default constructor is that
sometimes the compiler is unable to synthesize one. For example, if a class has a
member that has a class type, and that class doesn¡¯t have a default constructor, then
the compiler can¡¯t initialize that member. For such classes, we must define our own
version of the default constructor. Otherwise, the class will not have a usable default
constructor. We¡¯ll see in ¡ì 13.1.6 (p. 508) additional circumstances that prevent the
compiler from generating an appropriate default constructor.
Defining the Sales_data Constructors
For our Sales_data class we¡¯ll define four constructors with the following
parameters:
? An istream& from which to read a transaction.
? A const string& representing an ISBN, an unsigned representing the count
of how many books were sold, and a double representing the price at which
the books sold.
? A const string& representing an ISBN. This constructor will use default
values for the other members.
? An empty parameter list (i.e., the default constructor) which as we¡¯ve just seen
we must define because we have defined other constructors.
Adding these members to our class, we now have
Click here to view code image
struct Sales_data {
  // constructors added
  Sales_data() = default; Edition
  Sales_data(const std::string &s): bookNo(s) { } Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(std::istream &);
  // other members as before
  std::string isbn() const { return bookNo; } Sales_data& combine(const Sales_data&); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;
};
What = default Means
We¡¯ll start by explaining the default constructor:
Sales_data() = default;
First, note that this constructor defines the default constructor because it takes no
arguments. We are defining this constructor only because we want to provide other
constructors as well as the default constructor. We want this constructor to do exactly
the same work as the synthesized version we had been using.
Under the new standard, if we want the default behavior, we can ask the compiler
to generate the constructor for us by writing = default after the parameter list. The =
default can appear with the declaration inside the class body or on the definition
outside the class body. Like any other function, if the = default appears inside the
class body, the default constructor will be inlined; if it appears on the definition
outside the class, the member will not be inlined by default.
  Warning
The default constructor works for Sales_data only because we provide
initializers for the data members with built-in type. If your compiler does not
support in-class initializers, your default constructor should use the
constructor initializer list (described immediately following) to initialize every
member of the class.
Constructor Initializer List
Next we¡¯ll look at the other two constructors that were defined inside the classClick here to view code image
Sales_data(const std::string &s): bookNo(s) { } Edition
Sales_data(const std::string &s, unsigned n, double p):
 bookNo(s), units_sold(n), revenue(p*n) { }
The new parts in these definitions are the colon and the code between it and the curly
braces that define the (empty) function bodies. This new part is a constructor
nitializer list, which specifies initial values for one or more data members of the
object being created. The constructor initializer is a list of member names, each of
which is followed by that member¡¯s initial value in parentheses (or inside curly
braces). Multiple member initializations are separated by commas.
The constructor that has three parameters uses its first two parameters to initialize
the bookNo and units_sold members. The initializer for revenue is calculated by
multiplying the number of books sold by the price per book.
The constructor that has a single string parameter uses that string to initialize
bookNo but does not explicitly initialize the units_sold and revenue members.
When a member is omitted from the constructor initializer list, it is implicitly initialized
using the same process as is used by the synthesized default constructor. In this case,
those members are initialized by the in-class initializers. Thus, the constructor that
takes a string is equivalent to
Click here to view code image
// has the same behavior as the original constructor defined above
Sales_data(const std::string &s):
 bookNo(s), units_sold(0), revenue(0){ }
t is usually best for a constructor to use an in-class initializer if one exists and gives
the member the correct value. On the other hand, if your compiler does not yet
support in-class initializers, then every constructor should explicitly initialize every
member of built-in type.
  Best Practices
Constructors should not override in-class initializers except to use a different
initial value. If you can¡¯t use in-class initializers, each constructor should
explicitly initialize every member of built-in type.
It is worth noting that both constructors have empty function bodies. The only work
these constructors need to do is give the data members their values. If there is no
further work, then the function body is empty.
Defining a Constructor outside the Class Body
Unlike our other constructors, the constructor that takes an istream does have work
to do. Inside its function body, this constructor calls read to give the data members
new values: Edition
Click here to view code image
Sales_data::Sales_data(std::istream &is)
{
  read(is, *this); // read will read a transaction from is into this object
}
Constructors have no return type, so this definition starts with the name of the
function we are defining. As with any other member function, when we define a
constructor outside of the class body, we must specify the class of which the
constructor is a member. Thus, Sales_data::Sales_data says that we¡¯re defining
the Sales_data member named Sales_data. This member is a constructor
because it has the same name as its class.
In this constructor there is no constructor initializer list, although technically
speaking, it would be more correct to say that the constructor initializer list is empty.
Even though the constructor initializer list is empty, the members of this object are still
nitialized before the constructor body is executed.
Members that do not appear in the constructor initializer list are initialized by the
corresponding in-class initializer (if there is one) or are default initialized. For
Sales_data that means that when the function body starts executing, bookNo will
be the empty string, and units_sold and revenue will both be 0.
To understand the call to read, remember that read¡¯s second parameter is a
reference to a Sales_data object. In ¡ì 7.1.2 (p. 259), we noted that we use this
to access the object as a whole, rather than a member of the object. In this case, we
use *this to pass ¡°this¡± object as an argument to the read function.
Exercises Section 7.1.Exercise 7.11: Add constructors to your Sales_data class and write a
program to use each of the constructors.
Exercise 7.12: Move the definition of the Sales_data constructor that
takes an istream into the body of the Sales_data class.
Exercise 7.13: Rewrite the program from page 255 to use the istream
constructor.
Exercise 7.14: Write a version of the default constructor that explicitly
initializes the members to the values we have provided as in-class initializers.
Exercise 7.15: Add appropriate constructors to your Person class.
7.1.5. Copy, Assignment, and Destruction Edition
n addition to defining how objects of the class type are initialized, classes also control
what happens when we copy, assign, or destroy objects of the class type. Objects are
copied in several contexts, such as when we initialize a variable or when we pass or
return an object by value (¡ì 6.2.1, p. 209, and ¡ì 6.3.2, p. 224). Objects are assigned
when we use the assignment operator (¡ì 4.4, p. 144). Objects are destroyed when
they cease to exist, such as when a local object is destroyed on exit from the block in
which it was created (¡ì 6.1.1, p. 204). Objects stored in a vector (or an array) are
destroyed when that vector (or array) is destroyed.
If we do not define these operations, the compiler will synthesize them for us.
Ordinarily, the versions that the compiler generates for us execute by copying,
assigning, or destroying each member of the object. For example, in our bookstore
program in ¡ì 7.1.1 (p. 255), when the compiler executes this assignmenClick here to view code image
total = trans; // process the next book
t executes as if we had written
Click here to view code image
// default assignment for Sales_data is equivalent to:
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;
We¡¯ll show how we can define our own versions of these operations in Chapter 13.
Some Classes Cannot Rely on the Synthesized Versions
Although the compiler will synthesize the copy, assignment, and destruction operations
for us, it is important to understand that for some classes the default versions do not
behave appropriately. In particular, the synthesized versions are unlikely to work
correctly for classes that allocate resources that reside outside the class objects
themselves. As one example, in Chapter 12 we¡¯ll see how C++ programs allocate and
manage dynamic memory. As we¡¯ll see in ¡ì 13.1.4 (p. 504), classes that manage
dynamic memory, generally cannot rely on the synthesized versions of these
operations.
However, it is worth noting that many classes that need dynamic memory can (and
generally should) use a vector or a string to manage the necessary storage.
Classes that use vectors and strings avoid the complexities involved in allocating
and deallocating memory.
Moreover, the synthesized versions for copy, assignment, and destruction work
correctly for classes that have vector or string members. When we copy or assign
an object that has a vector member, the vector class takes care of copying or Edition
assigning the elements in that member. When the object is destroyed, the vector
member is destroyed, which in turn destroys the elements in the vector. Similarly for
strings.
  Warning
Until you know how to define the operations covered in Chapter 13, the
resources your classes allocate should be stored directly as data members of
the class.
7.2. Access Control and Encapsulation
At this point, we have defined an interface for our class; but nothing forces users to
use that interface. Our class is not yet encapsulated¡ªusers can reach inside a
Sales_data object and meddle with its implementation. In C++ we use access
specifiers to enforce encapsulation:
? Members defined after a public specifier are accessible to all parts of the
program. The public members define the interface to the class.
? Members defined after a private specifier are accessible to the member
functions of the class but are not accessible to code that uses the class. The
private sections encapsulate (i.e., hide) the implementation.
Redefining Sales_data once again, we now have
Click here to view code image
class Sales_data {
public: // access specifier added
  Sales_data() = default; Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(const std::string &s): bookNo(s) { } Sales_data(std::istream&); std::string isbn() const { return bookNo; } Sales_data &combine(const Sales_data&);
private: // access specifier added
  double avg_price() const { return units_sold ? revenue/units_sold : 0; } std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;
};
The constructors and member functions that are part of the interface (e.g., isbn and Edition
combine) follow the public specifier; the data members and the functions that are
part of the implementation follow the private specifier.
A class may contain zero or more access specifiers, and there are no restrictions on
how often an access specifier may appear. Each access specifier specifies the access
evel of the succeeding members. The specified access level remains in effect until the
next access specifier or the end of the class body.
Using the class or struct Keyword
We also made another, more subtle, change: We used the class keyword rather than
struct to open the class definition. This change is strictly stylistic; we can define a
class type using either keyword. The only difference between struct and class is
the default access level.
A class may define members before the first access specifier. Access to such
members depends on how the class is defined. If we use the struct keyword, the
members defined before the first access specifier are public; if we use class, then
the members are private.
As a matter of programming style, when we define a class intending for all of its
members to be public, we use struct. If we intend to have private members,
then we use class.
  Note
The only difference between using class and using struct to define a
class is the default access level.
Exercises Section 7.Exercise 7.16: What, if any, are the constraints on where and how often an
access specifier may appear inside a class definition? What kinds of members
should be defined after a public specifier? What kinds should be private?
Exercise 7.17: What, if any, are the differences between using class or
struct?
Exercise 7.18: What is encapsulation? Why is it useful?
Exercise 7.19: Indicate which members of your Person class you would
declare as public and which you would declare as private. Explain your
choice.
7.2.1. Friends Edition
Now that the data members of Sales_data are private, our read, print, and
add functions will no longer compile. The problem is that although these functions are
part of the Sales_data interface, they are not members of the class.
A class can allow another class or function to access its nonpublic members by
making that class or function a friend. A class makes a function its friend by including
a declaration for that function preceded by the keyword friend:
Click here to view code image
class Sales_data {
// friend declarations for nonmember Sales_data operations added
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);
// other members and access specifiers as before
public:
 Sales_data() = default; Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(const std::string &s): bookNo(s) { } Sales_data(std::istream&); std::string isbn() const { return bookNo; } Sales_data &combine(const Sales_data&);
private:
 std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;
};
// declarations for nonmember parts of the Sales_data interface
Sales_data add(const Sales_data&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
Friend declarations may appear only inside a class definition; they may appeaanywhere in the class. Friends are not members of the class and are not affected by
the access control of the section in which they are declared. We¡¯ll have more to say
about friendship in ¡ì 7.3.4 (p. 279).
  Tip
Ordinarily it is a good idea to group friend declarations together at the
beginning or end of the class definition.

Contents
Chapter 13 Copy Control
Chapter 14 Overloaded Operations and ConversionChapter 15 Object-Oriented Programming
Chapter 16 Templates and Generic Programming
Classes are the central concept in C++. Chapter 7 began our detailed coverage of how
classes are defined. That chapter covered topics fundamental to any use of classes:
class scope, data hiding, and constructors. It also introduced various important class
features: member functions, the implicit this pointer, friends, and const, static,
and mutable members. In this part, we¡¯ll extend our coverage of classes by looking
at copy control, overloaded operators, inheritance, and templates.
As we¡¯ve seen, in C++ classes define constructors to control what happens when
objects of the class type are initialized. Classes also control what happens when
objects are copied, assigned, moved, and destroyed. In this respect, C++ differs from
other languages, many of which do not give class designers the ability to control these
operations. Chapter 13 covers these topics. This chapter also covers two important
concepts introduced by the new standard: rvalue references and move operations.
Chapter 14 looks at operator overloading, which allows operands of class types to
be used with the built-in operators. Operator overloading is one of the ways whereby
C++ lets us create new types that are as intuitive to use as are the built-in types.
Among the operators that a class can overload is the funtion call operator. We canr, Fifth Edition
¡°call¡± objects of such classes just as if they were functions. We¡¯ll also look at new
library facilities that make it easy to use different types of callable objects in a uniform
way.
This chapter concludes by looking at another special kind of class member function
¡ªconversion operators. These operators define implicit conversions from objects of
class type. The compiler applies these conversions in the same contexts¡ªand for the
same reasons¡ªas it does with conversions among the built-in types.
The last two chapters in this part cover how C++ supports object-oriented and
generic programming.
Chapter 15 covers inheritance and dynamic binding. Along with data abstraction,
inheritance and dynamic binding are fundamental to object-oriented programming.
Inheritance makes it easier for us to define related types and dynamic binding lets us
write type-indepenent code that can ignore the differences among types that are
related by inheritance.
Chapter 16 covers function and class templates. Templates let us write generic
classes and functions that are type-independent. A number of new template-related
features were introduced by the new standard: variadic templates, template type
aliases, and new ways to control instantiation.
Writing our own object-oriented or generic types requires a fairly good
understanding of C++. Fortunately, we can use object-oriented and generic types
without understanding the details of how to build them. For example, the standard
library uses the facilities we¡¯ll study in Chapters 15 and 16 extensively, and we¡¯ve used
the library types and algorithms without needing to know how they are implemented.
Readers, therefore, should understand that Part III covers fairly advanced topics.
Writing templates or object-oriented classes requires a good understanding of the
basics of C++ and a good grasp of how to define more basic classes.
Chapter 13. Copy Control
Contents
Section 13.1 Copy, Assign, and Destroy
Section 13.2 Copy Control and Resource Management
Section 13.3 Swap
Section 13.4 A Copy-Control Example
Section 13.5 Classes That Manage Dynamic Memory
Section 13.6 Moving Objects
Chapter Summaryr, Fifth Edition
Defined Terms
As we saw in Chapter 7, each class defines a new type and defines the operations
that objects of that type can perform. In that chapter, we also learned that classes
can define constructors, which control what happens when objects of the class type
are created.
In this chapter we¡¯ll learn how classes can control what happens when objects of
the class type are copied, assigned, moved, or destroyed. Classes control these actions
through special member functions: the copy constructor, move constructor, copyassignment operator, move-assignment operator, and destructor.
When we define a class, we specify¡ªexplicitly or implicitly¡ªwhat happens when
objects of that class type are copied, moved, assigned, and destroyed. A class controls
these operations by defining five special member functions: copy constructor, copyassignment operator, move constructor, move-assignment operator, and
destructor. The copy and move constructors define what happens when an object is
initialized from another object of the same type. The copy- and move-assignment
operators define what happens when we assign an object of a class type to another
object of that same class type. The destructor defines what happens when an object
of the type ceases to exist. Collectively, we¡¯ll refer to these operations as copy
control.
If a class does not define all of the copy-control members, the compiler
automatically defines the missing operations. As a result, many classes can ignore
copy control (¡ì 7.1.5, p. 267). However, for some classes, relying on the default
definitions leads to disaster. Frequently, the hardest part of implementing copy-control
operations is recognizing when we need to define them in the first place.
  Warning
Copy control is an essential part of defining any C++ class. Programmers
new to C++ are often confused by having to define what happens when
objects are copied, moved, assigned, or destroyed. This confusion is
compounded because if we do not explicitly define these operations, the
compiler defines them for us¡ªalthough the compiler-defined versions might
not behave as we intend13.1. Copy, Assign, and Destroy
We¡¯ll start by covering the most basic operations, which are the copy constructor,
copy-assignment operator, and destructor. We¡¯ll cover the move operations (which
were introduced by the new standard) in ¡ì 13.6 (p. 531).
13.1.1. The Copy Constructorr, Fifth Edition
A constructor is the copy constructor if its first parameter is a reference to the class
type and any additional parameters have default values:
Click here to view code image
class Foo {
public:
  Foo(); // default constructor
  Foo(const Foo&); // copy constructor
  // ...
};
For reasons we¡¯ll explain shortly, the first parameter must be a reference type. That
parameter is almost always a reference to const, although we can define the copy
constructor to take a reference to nonconst. The copy constructor is used implicitly
in several circumstances. Hence, the copy constructor usually should not be
explicit (¡ì 7.5.4, p. 296).
The Synthesized Copy Constructor
When we do not define a copy constructor for a class, the compiler synthesizes one
for us. Unlike the synthesized default constructor (¡ì 7.1.4, p. 262), a copy constructor
is synthesized even if we define other constructors.
As we¡¯ll see in ¡ì 13.1.6 (p. 508), the synthesized copy constructor for some
classes prevents us from copying objects of that class type. Otherwise, the
synthesized copy constructor memberwise copies the members of its argument into
the object being created (¡ì 7.1.5, p. 267). The compiler copies each nonstatic
member in turn from the given object into the one being created.
The type of each member determines how that member is copied: Members of class
type are copied by the copy constructor for that class; members of built-in type are
copied directly. Although we cannot directly copy an array (¡ì 3.5.1, p. 114), the
synthesized copy constructor copies members of array type by copying each element.
Elements of class type are copied by using the elements¡¯ copy constructor.
As an example, the synthesized copy constructor for our Sales_data class is
equivalent to:
Click here to view code image
class Sales_data {
public:
  // other members and constructors as before
  // declaration equivalent to the synthesized copy constructor
  Sales_data(const Sales_data&);
private:r, Fifth Edition
  std::string bookNo; int units_sold = 0; double revenue = 0.0;
};
// equivalent to the copy constructor that would be synthesized for Sales_data
Sales_data::Sales_data(const Sales_data &orig):
  bookNo(orig.bookNo), // uses the string copy constructor
  units_sold(orig.units_sold), // copies orig.units_sold
  revenue(orig.revenue) // copies orig.revenue
  { } // empty body
Copy Initialization
We are now in a position to fully understand the differences between direct
initialization and copy initialization (¡ì 3.2.1, p. 84):
Click here to view code image
string dots(10, '.'); // direct initialization
string s(dots); // direct initialization
string s2 = dots; // copy initialization
string null_book = "9-999-99999-9"; // copy initialization
string nines = string(100, '9'); // copy initialization
When we use direct initialization, we are asking the compiler to use ordinary function
matching (¡ì 6.4, p. 233) to select the constructor that best matches the arguments
we provide. When we use copy initialization, we are asking the compiler to copy
the right-hand operand into the object being created, converting that operand if
necessary (¡ì 7.5.4, p. 294).
Copy initialization ordinarily uses the copy constructor. However, as we¡¯ll see in ¡ì
13.6.2 (p. 534), if a class has a move constructor, then copy initialization sometimes
uses the move constructor instead of the copy constructor. For now, what¡¯s useful to
know is when copy initialization happens and that copy initialization requires either the
copy constructor or the move constructor.
Copy initialization happens not only when we define variables using an =, but also
when we
? Pass an object as an argument to a parameter of nonreference type
? Return an object from a function that has a nonreference return type
? Brace initialize the elements in an array or the members of an aggregate class
(¡ì 7.5.5, p. 298)
Some class types also use copy initialization for the objects they allocate. For example,
the library containers copy initialize their elements when we initialize the container, or
when we call an insert or push member (¡ì 9.3.1, p. 342). By contrast, elements
created by an emplace member are direct initialized (¡ì 9.3.1, p. 345).r, Fifth Edition
Parameters and Return ValueDuring a function call, parameters that have a nonreference type are copy initialized
(¡ì 6.2.1, p. 209). Similarly, when a function has a nonreference return type, the
return value is used to copy initialize the result of the call operator at the call site (¡ì
6.3.2, p. 224).
The fact that the copy constructor is used to initialize nonreference parameters of
class type explains why the copy constructor¡¯s own parameter must be a reference. If
that parameter were not a reference, then the call would never succeed¡ªto call the
copy constructor, we¡¯d need to use the copy constructor to copy the argument, but to
copy the argument, we¡¯d need to call the copy constructor, and so on indefinitely.
Constraints on Copy Initialization
As we¡¯ve seen, whether we use copy or direct initialization matters if we use an
initializer that requires conversion by an explicit constructor (¡ì 7.5.4, p. 296):
Click here to view code image
vector<int> v1(10); // ok: direct initialization
vector<int> v2 = 10; // error: constructor that takes a size is explicit
void f(vector<int>); // f's parameter is copy initialized
f(10); // error: can't use an explicit constructor to copy an argument
f(vector<int>(10)); // ok: directly construct a temporary vector from an int
Directly initializing v1 is fine, but the seemingly equivalent copy initialization of v2 is
an error, because the vector constructor that takes a single size parameter is
explicit. For the same reasons that we cannot copy initialize v2, we cannot
implicitly use an explicit constructor when we pass an argument or return a value
from a function. If we want to use an explicit constructor, we must do so
explicitly, as in the last line of the example above.
The Compiler Can Bypass the Copy Constructor
During copy initialization, the compiler is permitted (but not obligated) to skip the
copy/move constructor and create the object directly. That is, the compiler is
permitted to rewrite
Click here to view code image
string null_book = "9-999-99999-9"; // copy initialization
into
Click here to view code imager, Fifth Edition
string null_book("9-999-99999-9"); // compiler omits the copy
constructor
However, even if the compiler omits the call to the copy/move constructor, the
copy/move constructor must exist and must be accessible (e.g., not private) at that
point in the program.
Exercises Section 13.1.1
Exercise 13.1: What is a copy constructor? When is it used?
Exercise 13.2: Explain why the following declaration is illegal:
Click here to view code image
Sales_data::Sales_data(Sales_data rhs);
Exercise 13.3: What happens when we copy a StrBlob? What about
StrBlobPtrs?
Exercise 13.4: Assuming Point is a class type with a public copy
constructor, identify each use of the copy constructor in this program
fragment:
Click here to view code image
Point global;
Point foo_bar(Point arg)
{
 Point local = arg, *heap = new Point(global); *heap = local; Point pa[ 4 ] = { local, *heap }; return *heap;
}
Exercise 13.5: Given the following sketch of a class, write a copy
constructor that copies all the members. Your constructor should dynamically
allocate a new string (¡ì 12.1.2, p. 458) and copy the object to which ps
points, rather than copying ps itself.
Click here to view code image
class HasPtr {
public:
 HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) { }
private:
 std::string *ps; int i;
};r, Fifth Edition
13.1.2. The Copy-Assignment Operator
Just as a class controls how objects of that class are initialized, it also controls how
objects of its class are assigned:
Click here to view code image
Sales_data trans, accum;
trans = accum; // uses the Sales_data copy-assignment operator
As with the copy constructor, the compiler synthesizes a copy-assignment operator if
the class does not define its own.
Introducing Overloaded Assignment
Before we look at the synthesized assignment operator, we need to know a bit about
overloaded operators, which we cover in detail in Chapter 14.
Overloaded operators are functions that have the name operator followed by the
symbol for the operator being defined. Hence, the assignment operator is a function
named operator=. Like any other function, an operator function has a return type
and a parameter list.
The parameters in an overloaded operator represent the operands of the operator.
Some operators, assignment among them, must be defined as member functions.
When an operator is a member function, the left-hand operand is bound to the
implicit this parameter (¡ì 7.1.2, p. 257). The right-hand operand in a binary
operator, such as assignment, is passed as an explicit parameter.
The copy-assignment operator takes an argument of the same type as the class:
Click here to view code image
class Foo {
public:
  Foo& operator=(const Foo&); // assignment operator
  // ...
};
To be consistent with assignment for the built-in types (¡ì 4.4, p. 145), assignment
operators usually return a reference to their left-hand operand. It is also worth noting
that the library generally requires that types stored in a container have assignment
operators that return a reference to the left-hand operand.
  Best Practices
Assignment operators ordinarily should return a reference to their left-handr, Fifth Edition
operand.
The Synthesized Copy-Assignment Operator
Just as it does for the copy constructor, the compiler generates a synthesized copyassignment operator for a class if the class does not define its own. Analogously to
the copy constructor, for some classes the synthesized copy-assignment operator
disallows assignment (¡ì 13.1.6, p. 508). Otherwise, it assigns each nonstatic
member of the right-hand object to the corresponding member of the left-hand object
using the copy-assignment operator for the type of that member. Array members are
assigned by assigning each element of the array. The synthesized copy-assignment
operator returns a reference to its left-hand object.
As an example, the following is equivalent to the synthesized Sales_data copyassignment operator:
Click here to view code image
// equivalent to the synthesized copy-assignment operator
Sales_data&
Sales_data::operator=(const Sales_data &rhs)
{
  bookNo = rhs.bookNo; // calls the string::operator=
  units_sold = rhs.units_sold; // uses the built-in int assignment
  revenue = rhs.revenue; // uses the built-in double
assignment
  return *this; // return a reference to this object
}
Exercises Section 13.1.2
Exercise 13.6: What is a copy-assignment operator? When is this operator
used? What does the synthesized copy-assignment operator do? When is it
synthesized?
Exercise 13.7: What happens when we assign one StrBlob to another?
What about StrBlobPtrs?
Exercise 13.8: Write the assignment operator for the HasPtr class from
exercise 13.5 in ¡ì 13.1.1 (p. 499). As with the copy constructor, your
assignment operator should copy the object to which ps points.
13.1.3. The Destructorr, Fifth Edition
The destructor operates inversely to the constructors: Constructors initialize the
nonstatic data members of an object and may do other work; destructors do
whatever work is needed to free the resources used by an object and destroy the
nonstatic data members of the object.
The destructor is a member function with the name of the class prefixed by a tilde
(~). It has no return value and takes no parameters:
class Foo {
public:
  ~Foo(); // destructor
  // ...
};
Because it takes no parameters, it cannot be overloaded. There is always only one
destructor for a given class.
What a Destructor Does
Just as a constructor has an initialization part and a function body (¡ì 7.5.1, p. 288), a
destructor has a function body and a destruction part. In a constructor, members are
initialized before the function body is executed, and members are initialized in the
same order as they appear in the class. In a destructor, the function body is executed
first and then the members are destroyed. Members are destroyed in reverse order
from the order in which they were initialized.
The function body of a destructor does whatever operations the class designer
wishes to have executed subsequent to the last use of an object. Typically, the
destructor frees resources an object allocated during its lifetime.
In a destructor, there is nothing akin to the constructor initializer list to control how
members are destroyed; the destruction part is implicit. What happens when a
member is destroyed depends on the type of the member. Members of class type are
destroyed by running the member¡¯s own destructor. The built-in types do not have
destructors, so nothing is done to destroy members of built-in type.
  Note
The implicit destruction of a member of built-in pointer type does not
delete the object to which that pointer pointsUnlike ordinary pointers, the smart pointers (¡ì 12.1.1, p. 452) are class types and
have destructors. As a result, unlike ordinary pointers, members that are smart
pointers are automatically destroyed during the destruction phase.r, Fifth Edition
When a Destructor Is Called
The destructor is used automatically whenever an object of its type is destroyed:
? Variables are destroyed when they go out of scope.
? Members of an object are destroyed when the object of which they are a part is
destroyed.
? Elements in a container¡ªwhether a library container or an array¡ªare destroyed
when the container is destroyed.
? Dynamically allocated objects are destroyed when the delete operator is
applied to a pointer to the object (¡ì 12.1.2, p. 460).
? Temporary objects are destroyed at the end of the full expression in which the
temporary was created.
Because destructors are run automatically, our programs can allocate resources and
(usually) not worry about when those resources are released.
For example, the following fragment defines four Sales_data objects:
Click here to view code image
{ // new scope
  // p and p2 point to dynamically allocated objects
  Sales_data *p = new Sales_data; // p is a built-in pointer
  auto p2 = make_shared<Sales_data>(); // p2 is a shared_ptr
  Sales_data item(*p); // copy constructor copies *p into item
  vector<Sales_data> vec; // local objec vec.push_back(*p2); // copies the object to which p2 points
  delete p; // destructor called on the object pointed to
by p
} // exit local scope; destructor called on item, p2, and vec
  // destroying p2 decrements its use count; if the count goes to 0, the object is freed
  // destroying vec destroys the elements in vec
Each of these objects contains a string member, which allocates dynamic memory
to contain the characters in its bookNo member. However, the only memory our code
has to manage directly is the object we directly allocated. Our code directly frees only
the dynamically allocated object bound to p.
The other Sales_data objects are automatically destroyed when they go out of
scope. When the block ends, vec, p2, and item all go out of scope, which means
that the vector, shared_ptr, and Sales_data destructors will be run on those
objects, respectively. The vector destructor will destroy the element we pushed onto
vec. The shared_ptr destructor will decrement the reference count of the object to
which p2 points. In this example, that count will go to zero, so the shared_ptr
destructor will delete the Sales_data object that p2 allocated.r, Fifth Edition
In all cases, the Sales_data destructor implicitly destroys the bookNo member.
Destroying bookNo runs the string destructor, which frees the memory used to
store the ISBN.
  Note
The destructor is not run when a reference or a pointer to an object goes out
of scope.
The Synthesized Destructor
The compiler defines a synthesized destructor for any class that does not define its
own destructor. As with the copy constructor and the copy-assignment operator, for
some classes, the synthesized destructor is defined to disallow objects of the type
from being destroyed (¡ì 13.1.6, p. 508). Otherwise, the synthesized destructor has an
empty function body.
For example, the synthesized Sales_data destructor is equivalent to:
Click here to view code image
class Sales_data public:
  // no work to do other than destroying the members, which happens automatically
  ~Sales_data() { }
  // other members as before
};
The members are automatically destroyed after the (empty) destructor body is run. In
particular, the string destructor will be run to free the memory used by the bookNo
member.
It is important to realize that the destructor body does not directly destroy the
members themselves. Members are destroyed as part of the implicit destruction phase
that follows the destructor body. A destructor body executes in addition to the
memberwise destruction that takes place as part of destroying an object.
13.1.4. The Rule of Three/Five
As we¡¯ve seen, there are three basic operations to control copies of class objects: the
copy constructor, copy-assignment operator, and destructor. Moreover, as we¡¯ll see in
¡ì 13.6 (p. 531), under the new standard, a class can also define a move constructor
and move-assignment operator.r, Fifth Edition
Exercises Section 13.1.3
Exercise 13.9: What is a destructor? What does the synthesized destructor
do? When is a destructor synthesized?
Exercise 13.10: What happens when a StrBlob object is destroyed? What
about a StrBlobPtr?
Exercise 13.11: Add a destructor to your HasPtr class from the previous
exercises.
Exercise 13.12: How many destructor calls occur in the following code
fragment?
Click here to view code image
bool fcn(const Sales_data *trans, Sales_data accum)
{
 Sales_data item1(*trans), item2(accum); return item1.isbn() != item2.isbn();
}
Exercise 13.13: A good way to understand copy-control members and
constructors is to define a simple class with these members in which each
member prints its name:
Click here to view code image
struct X { X() {std::cout << "X()" << std::endl;} X(const X&) {std::cout << "X(const X&)" <<
std::endl;}
};
Add the copy-assignment operator and destructor to X and write a program using
X objects in various ways: Pass them as nonreference and reference parameters;
dynamically allocate them; put them in containers; and so forth. Study the output
until you are certain you understand when and why each copy-control member is
used. As you read the output, remember that the compiler can omit calls to the
copy constructor.
There is no requirement that we define all of these operations: We can define one
or two of them without having to define all of them. However, ordinarily these
operations should be thought of as a unit. In general, it is unusual to need one
without needing to define them all.
Classes That Need Destructors Need Copy and Assignmentr, Fifth Edition
One rule of thumb to use when you decide whether a class needs to define its own
versions of the copy-control members is to decide first whether the class needs a
destructor. Often, the need for a destructor is more obvious than the need for the
copy constructor or assignment operator. If the class needs a destructor, it almost
surely needs a copy constructor and copy-assignment operator as well.
The HasPtr class that we have used in the exercises is a good example (¡ì 13.1.1,
p. 499). That class allocates dynamic memory in its constructor. The synthesized
destructor will not delete a data member that is a pointer. Therefore, this class
needs to define a destructor to free the memory allocated by its constructor.
What may be less clear¡ªbut what our rule of thumb tells us¡ªis that HasPtr also
needs a copy constructor and copy-assignment operator.
Consider what would happen if we gave HasPtr a destructor but used the
synthesized versions of the copy constructor and copy-assignment operator:
Click here to view code image
class HasPtr {
public:
 HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) { } ~HasPtr() { delete ps; }
  // WRONG: HasPtr needs a copy constructor and copy-assignment operator
  // other members as before
};
In this version of the class, the memory allocated in the constructor will be freed when
a HasPtr object is destroyed. Unfortunately, we have introduced a serious bug! This
version of the class uses the synthesized versions of copy and assignment. Those
functions copy the pointer member, meaning that multiple HasPtr objects may be
pointing to the same memory:
Click here to view code image
HasPtr f(HasPtr hp) // HasPtr passed by value, so it is copied
{
  HasPtr ret = hp; // copies the given HasPtr
  // process ret
  return ret; // ret and hp are destroyed
}
When f returns, both hp and ret are destroyed and the HasPtr destructor is run on
each of these objects. That destructor will delete the pointer member in ret and in
hp. But these objects contain the same pointer value. This code will delete that
pointer twice, which is an error (¡ì 12.1.2, p. 462). What happens is undefined.
In addition, the caller of f may still be using the object that was passed to f:
Click here to view code imager, Fifth Edition
HasPtr p("some values");
f(p); // when f completes, the memory to which p.ps points is freed
HasPtr q(p); // now both p and q point to invalid memory!
The memory to which p (and q) points is no longer valid. It was returned to the
system when hp (or ret!) was destroyed.
  Tip
If a class needs a destructor, it almost surely also needs the copy-assignment
operator and a copy constructor.
Classes That Need Copy Need Assignment, and Vice Versa
Although many classes need to define all of (or none of) the copy-control members,
some classes have work that needs to be done to copy or assign objects but has no
need for the destructor.
As an example, consider a class that gives each object its own, unique serial
number. Such a class would need a copy constructor to generate a new, distinct serial
number for the object being created. That constructor would copy all the other data
members from the given object. This class would also need its own copy-assignment
operator to avoid assigning to the serial number of the left-hand object. However, this
class would have no need for a destructor.
This example gives rise to a second rule of thumb: If a class needs a copy
constructor, it almost surely needs a copy-assignment operator. And vice versa¡ªif the
class needs an assignment operator, it almost surely needs a copy constructor as well.
Nevertheless, needing either the copy constructor or the copy-assignment operator
does not (necessarily) indicate the need for a destructor.
Exercises Section 13.1.4
Exercise 13.14: Assume that numbered is a class with a default constructor
that generates a unique serial number for each object, which is stored in a
data member named mysn. Assuming numbered uses the synthesized copycontrol members and given the following function:
Click here to view code image
void f (numbered s) { cout << s.mysn << endl; }
what output does the following code produce?
Click here to view code imager, Fifth Edition
numbered a, b = a, c = b;
f(a); f(b); f(c);
Exercise 13.15: Assume numbered has a copy constructor that generates a
new serial number. Does that change the output of the calls in the previous
exercise? If so, why? What output gets generated?
Exercise 13.16: What if the parameter in f were const numbered&?
Does that change the output? If so, why? What output gets generated?
Exercise 13.17: Write versions of numbered and f corresponding to the
previous three exercises and check whether you correctly predicted the
output.
13.1.5. Using = default
We can explicitly ask the compiler to generate the synthesized versions of the copycontrol members by defining them as = default (¡ì 7.1.4, p. 264):
Click here to view code image
class Sales_data {
public:
  // copy control; use defaults
  Sales_data() = default; Sales_data(const Sales_data&) = default; Sales_data& operator=(const Sales_data &); ~Sales_data() = default;
  // other members as before
};
Sales_data& Sales_data::operator=(const Sales_data&) =
default;
When we specify = default on the declaration of the member inside the class body,
the synthesized function is implicitly inline (just as is any other member function
defined in the body of the class). If we do not want the synthesized member to be an
inline function, we can specify = default on the member¡¯s definition, as we do in
the definition of the copy-assignment operator.
  Note
We can use = default only on member functions that have a synthesized
version (i.e., the default constructor or a copy-control member).r, Fifth Edition
13.1.6. Preventing Copies
  Best Practices
Most classes should define¡ªeither implicitly or explicitly¡ªthe default and
copy constructors and the copy-assignment operator.
Although most classes should (and generally do) define a copy constructor and a
copy-assignment operator, for some classes, there really is no sensible meaning for
these operations. In such cases, the class must be defined so as to prevent copies or
assignments from being made. For example, the iostream classes prevent copying to
avoid letting multiple objects write to or read from the same IO buffer. It might seem
that we could prevent copies by not defining the copy-control members. However, this
strategy doesn¡¯t work: If our class doesn¡¯t define these operations, the compiler will
synthesize them.
Defining a Function as Deleted
Under the new standard, we can prevent copies by defining the copy constructor and
copy-assignment operator as deleted functions. A deleted function is one that is
declared but may not be used in any other way. We indicate that we want to define a
function as deleted by following its parameter list with = delete:
Click here to view code image
struct NoCopy {
  NoCopy() = default; // use the synthesized default constructor
  NoCopy(const NoCopy&) = delete; // no copy
  NoCopy &operator=(const NoCopy&) = delete; // no assignment
  ~NoCopy() = default; // use the synthesized destructor
  // other members
};
The = delete signals to the compiler (and to readers of our code) that we are
intentionally not defining these members.
Unlike = default, = delete must appear on the first declaration of a deleted
function. This difference follows logically from the meaning of these declarations. A
defaulted member affects only what code the compiler generates; hence the =
default is not needed until the compiler generates code. On the other hand, the
compiler needs to know that a function is deleted in order to prohibit operations that
attempt to use it.
Also unlike = default, we can specify = delete on any function (we can use =r, Fifth Edition
default only on the default constructor or a copy-control member that the compiler
can synthesize). Although the primary use of deleted functions is to suppress the
copy-control members, deleted functions are sometimes also useful when we want to
guide the function-matching process.
The Destructor Should Not be a Deleted Member
It is worth noting that we did not delete the destructor. If the destructor is deleted,
then there is no way to destroy objects of that type. The compiler will not let us
define variables or create temporaries of a type that has a deleted destructor.
Moreover, we cannot define variables or temporaries of a class that has a member
whose type has a deleted destructor. If a member has a deleted destructor, then that
member cannot be destroyed. If a member can¡¯t be destroyed, the object as a whole
can¡¯t be destroyed.
Although we cannot define variables or members of such types, we can dynamically
allocate objects with a deleted destructor. However, we cannot free them:
Click here to view code image
struct NoDtor {
  NoDtor() = default; // use the synthesized default constructor
  ~NoDtor() = delete; // we can't destroy objects of type NoDtor
};
NoDtor nd; // error: NoDtor destructor is deleted
NoDtor *p = new NoDtor(); // ok: but we can't delete p
delete p; // error: NoDtor destructor is deleted
  Warning
It is not possible to define an object or delete a pointer to a dynamically
allocated object of a type with a deleted destructor.
The Copy-Control Members May Be Synthesized as Deleted
As we¡¯ve seen, if we do not define the copy-control members, the compiler defines
them for us. Similarly, if a class defines no constructors, the compiler synthesizes a
default constructor for that class (¡ì 7.1.4, p. 262). For some classes, the compiler
defines these synthesized members as deleted functions:
? The synthesized destructor is defined as deleted if the class has a member
whose own destructor is deleted or is inaccessible (e.g., private).
? The synthesized copy constructor is defined as deleted if the class has a
member whose own copy constructor is deleted or inaccessible. It is also deletedr, Fifth Edition
if the class has a member with a deleted or inaccessible destructor.
? The synthesized copy-assignment operator is defined as deleted if a member
has a deleted or inaccessible copy-assignment operator, or if the class has a
const or reference member? The synthesized default constructor is defined as deleted if the class has a
member with a deleted or inaccessible destructor; or has a reference member
that does not have an in-class initializer (¡ì 2.6.1, p. 73); or has a const
member whose type does not explicitly define a default constructor and that
member does not have an in-class initializer.
In essence, these rules mean that if a class has a data member that cannot be default
constructed, copied, assigned, or destroyed, then the corresponding member will be a
deleted function.
It may be surprising that a member that has a deleted or inaccessible destructor
causes the synthesized default and copy constructors to be defined as deleted. The
reason for this rule is that without it, we could create objects that we could not
destroy.
It should not be surprising that the compiler will not synthesize a default constructor
for a class with a reference member or a const member that cannot be default
constructed. Nor should it be surprising that a class with a const member cannot use
the synthesized copy-assignment operator: After all, that operator attempts to assign
to every member. It is not possible to assign a new value to a const object.
Although we can assign a new value to a reference, doing so changes the value of
the object to which the reference refers. If the copy-assignment operator were
synthesized for such classes, the left-hand operand would continue to refer to the
same object as it did before the assignment. It would not refer to the same object as
the right-hand operand. Because this behavior is unlikely to be desired, the
synthesized copy-assignment operator is defined as deleted if the class has a
reference member.
We¡¯ll see in ¡ì 13.6.2 (p. 539), ¡ì 15.7.2 (p. 624), and ¡ì 19.6 (p. 849) that there are
other aspects of a class that can cause its copy members to be defined as deleted.
  Note
In essence, the copy-control members are synthesized as deleted when it is
impossible to copy, assign, or destroy a member of the class.
private Copy Control
Prior to the new standard, classes prevented copies by declaring their copy constructor
and copy-assignment operator as private:r, Fifth Edition
Click here to view code image
class PrivateCopy {
  // no access specifier; following members are private by default; see ¡ì 7.2 (p.
268)
  // copy control is private and so is inaccessible to ordinary user code
  PrivateCopy(const PrivateCopy&); PrivateCopy &operator=(const PrivateCopy&) // other members
public:
  PrivateCopy() = default; // use the synthesized default constructor
  ~PrivateCopy(); // users can define objects of this type but not copy them
};
Because the destructor is public, users will be able to define PrivateCopy objects.
However, because the copy constructor and copy-assignment operator are private,
user code will not be able to copy such objects. However, friends and members of the
class can still make copies. To prevent copies by friends and members, we declare
these members as private but do not define them.
With one exception, which we¡¯ll cover in ¡ì 15.2.1 (p. 594), it is legal to declare, but
not define, a member function (¡ì 6.1.2, p. 206). An attempt to use an undefined
member results in a link-time failure. By declaring (but not defining) a private copy
constructor, we can forestall any attempt to copy an object of the class type: User
code that tries to make a copy will be flagged as an error at compile time; copies
made in member functions or friends will result in an error at link time.
  Best Practices
Classes that want to prevent copying should define their copy constructor and
copy-assignment operators using = delete rather than making thosmembers private.
Exercises Section 13.1.6
Exercise 13.18: Define an Employee class that contains an employee name
and a unique employee identifier. Give the class a default constructor and a
constructor that takes a string representing the employee¡¯s name. Each
constructor should generate a unique ID by incrementing a static data
member.
Exercise 13.19: Does your Employee class need to define its own versions
of the copy-control members? If so, why? If not, why not? Implement
whatever copy-control members you think Employee needs.
Exercise 13.20: Explain what happens when we copy, assign, or destroy
objects of our TextQuery and QueryResult classes from ¡ì 12.3 (p. 484).r, Fifth Edition
Exercise 13.21: Do you think the TextQuery and QueryResult classes
need to define their own versions of the copy-control members? If so, why?
If not, why not? Implement whichever copy-control operations you think
these classes require.
13.2. Copy Control and Resource Management
Ordinarily, classes that manage resources that do not reside in the class must define
the copy-control members. As we saw in ¡ì 13.1.4 (p. 504), such classes will need
destructors to free the resources allocated by the object. Once a class needs a
destructor, it almost surely needs a copy constructor and copy-assignment operator as
well.
In order to define these members, we first have to decide what copying an object of
our type will mean. In general, we have two choices: We can define the copy
operations to make the class behave like a value or like a pointer.
Classes that behave like values have their own state. When we copy a valuelike
object, the copy and the original are independent of each other. Changes made to the
copy have no effect on the original, and vice versa.
Classes that act like pointers share state. When we copy objects of such classes, the
copy and the original use the same underlying data. Changes made to the copy also
change the original, and vice versa.
Of the library classes we¡¯ve used, the library containers and string class have
valuelike behavior. Not surprisingly, the shared_ptr class provides pointerlike
behavior, as does our StrBlob class (¡ì 12.1.1, p. 456). The IO types and
unique_ptr do not allow copying or assignment, so they provide neither valuelike
nor pointerlike behavior.
To illustrate these two approaches, we¡¯ll define the copy-control members for the
HasPtr class used in the exercises. First, we¡¯ll make the class act like a value; then
we¡¯ll reimplement the class making it behave like a pointer.
Our HasPtr class has two members, an int and a pointer to string. Ordinarily,
classes copy members of built-in type (other than pointers) directly; such members
are values and hence ordinarily ought to behave like values. What we do when we
copy the pointer member determines whether a class like HasPtr has valuelike or
pointerlike behavior.
Exercises Section 13.2
Exercise 13.22: Assume that we want HasPtr to behave like a value. Thatr, Fifth Edition
is, each object should have its own copy of the string to which the objects
point. We¡¯ll show the definitions of the copy-control members in the next
section. However, you already know everything you need to know to
implement these members. Write the HasPtr copy constructor and copyassignment operator before reading on.
13.2.1. Classes That Act Like Values
To provide valuelike behavior, each object has to have its own copy of the resource
that the class manages. That means each HasPtr object must have its own copy of
the string to which ps points. To implement valuelike behavior HasPtr needs
? A copy constructor that copies the string, not just the pointer
? A destructor to free the string
? A copy-assignment operator to free the object¡¯s existing string and copy the
string from its right-hand operand
The valuelike version of HasPtr is
Click here to view code image

ret-type StrBlob::member-name(parm-list)
the corresponding Blob member will look like
Click here to view code image
template <typename T>
ret-type Blob<T>::member-name(parm-list)
The check and Element Access Members
We¡¯ll start by defining the check member, which verifies a given index:
Click here to view code image
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg)
const
{
 if (i >= data->size()) throw std::out_of_range(msg);
}
Aside from the differences in the class name and the use of the template parameter
list, this function is identical to the original StrBlob member.
The subscript operator and back function use the template parameter to specify the
return type but are otherwise unchanged:
Click here to view code image
template <typename T>
T& Blob<T>::back()
{
 check(0, "back on empty Blob"); return data->back();
}
template <typename T>
T& Blob<T>::operator[](size_type i)
{
  // if i is too big, check will throw, preventing access to a nonexistent element
  check(i, "subscript out of range"); return (*data)[i];
}
In our original StrBlob class these operators returned string&. The template
versions will return a reference to whatever type is used to instantiate Blob.
The pop_back function is nearly identical to our original StrBlob member:
Click here to view code image
template <typename T> void Blob<T>::pop_back()Fifth Edition
{
 check(0, "pop_back on empty Blob"); data->pop_back();
}
The subscript operator and back members are overloaded on const. We leave the
definition of these members, and of the front members, as an exercise.
Blob Constructors
As with any other member defined outside a class template, a constructor starts by
declaring the template parameters for the class template of which it is a member:
Click here to view code image
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>>()) { }
Here we are defining the member named Blob in the scope of Blob<T>. Like our
StrBlob default constructor (¡ì 12.1.1, p. 456), this constructor allocates an empty
vector and stores the pointer to that vector in data. As we¡¯ve seen, we use the
class¡¯ own type parameter as the template argument of the vector we allocate.
Similarly, the constructor that takes an initializer_list uses its type
parameter T as the element type for its initializer_list parameter:
Click here to view code image
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il):
 data(std::make_shared<std::vector<T>>(il)) { }
Like the default constructor, this constructor allocates a new vector. In this case, we
initialize that vector from the parameter, il.
To use this constructor, we must pass an initializer_list in which the
elements are compatible with the element type of the Blob:
Click here to view code image
Blob<string> articles = {"a", "an", "the"};
The parameter in this constructor has type initializer_list<string>. Each
string literal in the list is implicitly converted to string.
Instantiation of Class-Template Member Functions
By default, a member function of a class template is instantiated only if the program
uses that member function. For example, this code
Click here to view code image
// Fifth Edition
instantiates Blob<int> and the initializer_list<int> constructor
Blob<int> squares = {0,1,2,3,4,5,6,7,8,9};
// instantiates Blob<int>::size() const
for (size_t i = 0; i != squares.size(); ++i)
  squares[i] = i*i; // instantiates Blob<int>::operator[](size_t)
instantiates the Blob<int> class and three of its member functions: operator[],
size, and the initializer_list<int> constructor.
If a member function isn¡¯t used, it is not instantiated. The fact that members are
instantiated only if we use them lets us instantiate a class with a type that may not
meet the requirements for some of the template¡¯s operations (¡ì 9.2, p. 329).
  Note
By default, a member of an instantiated class template is instantiated only if
the member is used.
Simplifying Use of a Template Class Name inside Class Code
There is one exception to the rule that we must supply template arguments when we
use a class template type. Inside the scope of the class template itself, we may use
the name of the template without arguments:
Click here to view code image
// BlobPtr throws an exception on attempts to access a nonexistent element
template <typename T> class BlobPtr
public:
 BlobPtr(): curr(0) { } BlobPtr(Blob<T> &a, size_t sz = 0): wptr(a.data), curr(sz) { } T& operator*() const { auto p = check(curr, "dereference past end");
  return (*p)[curr]; // (*p) is the vector to which this object points
  }
  // increment and decrement
  BlobPtr& operator++(); // prefix operators
  BlobPtr& operator--();
private:
  // check returns a shared_ptr to the vector if the check succeeds
  std::shared_ptr<std::vector<T>> check(std::size_t, const std::string&) const;
  // store a weak_ptr, which means the underlying vector might be destroyed
  std::weak_ptr<std::vector<T>> wptr;
  std::size_t curr; // current position within the array
};Fifth Edition
Careful readers will have noted that the prefix increment and decrement members of
BlobPtr return BlobPtr&, not BlobPtr<T>&. When we are inside the scope of a
class template, the compiler treats references to the template itself as if we had
supplied template arguments matching the template¡¯s own parameters. That is, it is as
if we had written:
BlobPtr<T>& operator++();
BlobPtr<T>& operator--();
Using a Class Template Name outside the Class Template Body
When we define members outside the body of a class template, we must remember
that we are not in the scope of the class until the class name is seen (¡ì 7.4, p. 282):
Click here to view code image
// postfix: increment/decrement the object but return the unchanged value
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
  // no check needed here; the call to prefix increment will do the check
  BlobPtr ret = *this; // save the current value
  ++*this; // advance one element; prefix ++ checks the increment
  return ret; // return the saved state
}
Because the return type appears outside the scope of the class, we must specify that
the return type returns a BlobPtr instantiated with the same type as the class.
Inside the function body, we are in the scope of the class so do not need to repeat
the template argument when we define ret. When we do not supply template
arguments, the compiler assumes that we are using the same type as the member¡¯s
instantiation. Hence, the definition of ret is as if we had written:
BlobPtr<T> ret = *this;
  Note
Inside the scope of a class template, we may refer to the template without
specifying template argument(s).
Class Templates and Friends
When a class contains a friend declaration (¡ì 7.2.1, p. 269), the class and the friend
can independently be templates or not. A class template that has a nontemplate friend
grants that friend access to all the instantiations of the template. When the friend isFifth Edition
itself a template, the class granting friendship controls whether friendship includes all
instantiations of the template or only specific instantiation(s).
One-to-One Friendship
The most common form of friendship from a class template to another template (class
or function) establishes friendship between corresponding instantiations of the class
and its friend. For example, our Blob class should declare the BlobPtr class and a
template version of the Blob equality operator (originally defined for StrBlob in the
exercises in ¡ì 14.3.1 (p. 562)) as friends.
In order to refer to a specific instantiation of a template (class or function) we must
first declare the template itself. A template declaration includes the template¡¯s
template parameter list:
Click here to view code image
// forward declarations needed for friend declarations in Blob
template <typename> class BlobPtr;
template <typename> class Blob; // needed for parameters in operator==
template <typename T>
 bool operator==(const Blob<T>&, const Blob<T>&);
template <typename T> class Blob {
  // each instantiation of Blob grants access to the version of
  // BlobPtr and the equality operator instantiated with the same type
  friend class BlobPtr<T>; friend bool operator==<T> (const Blob<T>&, const Blob<T>&);
  // other members as in ¡ì 12.1.1 (p. 456)
};
We start by declaring that Blob, BlobPtr, and operator== are templates. These
declarations are needed for the parameter declaration in the operator== function
and the friend declarations in Blob.
The friend declarations use Blob¡¯s template parameter as their own template
argument. Thus, the friendship is restricted to those instantiations of BlobPtr and
the equality operator that are instantiated with the same type:
Click here to view code image
Blob<char> ca; // BlobPtr<char> and operator==<char> are friendBlob<int> ia; // BlobPtr<int> and operator==<int> are friends
The members of BlobPtr<char> may access the nonpublic parts of ca (or any
other Blob<char> object), but ca has no special access to ia (or any other
Blob<int>) or to any other instantiation of Blob.
General and Specific Template FriendshipFifth Edition
A class can also make every instantiation of another template its friend, or it may limit
friendship to a specific instantiation:
Click here to view code image
// forward declaration necessary to befriend a specific instantiation of a template
template <typename T> class Pal;
class C { // C is an ordinary, nontemplate class
  friend class Pal<C>; // Pal instantiated with class C is a friend to
C
  // all instances of Pal2 are friends to C;
  // no forward declaration required when we befriend all instantiations
  template <typename T> friend class Pal2;
};
template <typename T> class C2 { // C2 is itself a class template
  // each instantiation of C2 has the same instance of Pal as a friend
  friend class Pal<T>; // a template declaration for Pal must be in
scope
  // all instances of Pal2 are friends of each instance of C2, prior declaration
needed
  template <typename X> friend class Pal2;
  // Pal3 is a nontemplate class that is a friend of every instance of C2
  friend class Pal3; // prior declaration for Pal3 not needed
};
To allow all instantiations as friends, the friend declaration must use template
parameter(s) that differ from those used by the class itself.
Befriending the Template¡¯s Own Type Parameter
Under the new standard, we can make a template type parameter a friend:
Click here to view code image
template <typename Type> class Bar {
friend Type; // grants access to the type used to instantiate Bar
  // ... };
Here we say that whatever type is used to instantiate Bar is a friend. Thus, for some
type named Foo, Foo would be a friend of Bar<Foo>, Sales_data a friend of
Bar<Sales_data>, and so on.
It is worth noting that even though a friend ordinarily must be a class or a function,
it is okay for Bar to be instantiated with a built-in type. Such friendship is allowed so
that we can instantiate classes such as Bar with built-in types.Fifth Edition
Template Type Aliases
An instantiation of a class template defines a class type, and as with any other class
type, we can define a typedef (¡ì 2.5.1, p. 67) that refers to that instantiated class:
typedef Blob<string> StrBlob;
This typedef will let us run the code we wrote in ¡ì 12.1.1 (p. 456) using our
template version of Blob instantiated with string. Because a template is not a type,
we cannot define a typedef that refers to a template. That is, there is no way to
define a typedef that refers to Blob<T>.
However, the new standard lets us define a type alias for a class template:
Click here to view code image
template<typename T> using twin = pair<T, T>;
twin<string> authors; // authors is a pair<string, string>
Here we¡¯ve defined twin as a synonym for pairs in which the members have the
same type. Users of twin need to specify that type only once.
A template type alias is a synonym for a family of classesClick here to view code image
twin<int> win_loss; // win_loss is a pair<int, inttwin<double> area; // area is a pair<double, double>
Just as we do when we use a class template, when we use twin, we specify which
particular kind of twin we want.
When we define a template type alias, we can fix one or more of the template
parameters:
Click here to view code image
template <typename T> using partNo = pair<T, unsigned>;
partNo<string> books; // books is a pair<string, unsigned>
partNo<Vehicle> cars; // cars is a pair<Vehicle, unsigned>
partNo<Student> kids; // kids is a pair<Student, unsigned>
Here we¡¯ve defined partNo as a synonym for the family of types that are pairs in
which the second member is an unsigned. Users of partNo specify a type for the
first member of the pair but have no choice about second.
static Members of Class Templates
Like any other class, a class template can declare static members (¡ì 7.6, p. 300):Fifth Edition
Click here to view code image
template <typename T> class Foo {
public:
 static std::size_t count() { return ctr; }
  // other interface members
private:
 static std::size_t ctr;
  // other implementation members
};
Here Foo is a class template that has a public static member function named
count and a private static data member named ctr. Each instantiation of Foo
has its own instance of the static members. That is, for any given type X, there is
one Foo<X>::ctr and one Foo<X>::count member. All objects of type Foo<X>
share the same ctr object and count function. For example,
Click here to view code image
// instantiates static members Foo<string>::ctr and Foo<string>::count
Foo<string> fs;
// all three objects share the same Foo<int>::ctr and Foo<int>::count members
Foo<int> fi, fi2, fi3;
As with any other static data member, there must be exactly one definition of
each static data member of a template class. However, there is a distinct object for
each instantiation of a class template. As a result, we define a static data member
as a template similarly to how we define the member functions of that template:
Click here to view code image
template <typename T>
size_t Foo<T>::ctr = 0; // define and initialize ctr
As with any other member of a class template, we start by defining the template
parameter list, followed by the type of the member we are defining and the member¡¯s
name. As usual, a member¡¯s name includes the member¡¯s class name, which for a
class generated from a template includes its template arguments. Thus, when Foo is
instantiated for a particular template argument type, a separate ctr will be
instantiated for that class type and initialized to 0.
As with static members of nontemplate classes, we can access a static member
of a class template through an object of the class type or by using the scope operator
to access the member directly. Of course, to use a static member through the
class, we must refer to a specific instantiation:
Click here to view code image
Foo<int> fi; // instantiates Foo<int> class
  // and the static data member ctr
auto ct = Foo<int>::count(); // instantiates Foo<int>::countFifth Edition
ct = fi.count(); // uses Foo<int>::count
ct = Foo::count(); // error: which template instantiation?
Like any other member function, a static member function is instantiated only if it is
used in a program.
Exercises Section 16.1.2
Exercise 16.9: What is a function template? What is a class template?
Exercise 16.10: What happens when a class template is instantiated?
Exercise 16.11: The following definition of List is incorrect. How would
you fix it?
Click here to view code image
template <typename elemType> class ListItem;
template <typename elemType> class List {
public:
 List<elemType>(); List<elemType>(const List<elemType> &); List<elemType>& operator=(const List<elemType> &); ~List(); void insert(ListItem *ptr, elemType value);
private:
 ListItem *front, *end;
};
Exercise 16.12: Write your own version of the Blob and BlobPtr
templates. including the various const members that were not shown in the
text.
Exercise 16.13: Explain which kind of friendship you chose for the equality
and relational operators for BlobPtr.
Exercise 16.14: Write a Screen class template that uses nontype
parameters to define the height and width of the Screen.
Exercise 16.15: Implement input and output operators for your Screen
template. Which, if any, friends are necessary in class Screen to make the
input and output operators work? Explain why each friend declaration, if any,
was needed.
Exercise 16.16: Rewrite the StrVec class (¡ì 13.5, p. 526) as a template
named Vec.
16.1.3. Template Parameters
Like the names of function parameters, a template parameter name has no intrinsicFifth Edition
meaning. We ordinarily name type parameters T, but we can use any name:
Click here to view code image
template <typename Foo> Foo calc(const Foo& a, const Foo& b)
{
  Foo tmp = a; // tmp has the same type as the parameters and return type
  // ...
  return tmp; // return type and parameters have the same type
}
Template Parameters and Scope
Template parameters follow normal scoping rules. The name of a template parameter
can be used after it has been declared and until the end of the template declaration or
definition. As with any other name, a template parameter hides any declaration of that
name in an outer scope. Unlike most other contexts, however, a name used as a
template parameter may not be reused within the template:
Click here to view code image
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
  A tmp = a; // tmp has same type as the template parameter A, not double
  double B; // error: redeclares template parameter B
}
Normal name hiding says that the typedef of A is hidden by the type parameter
named A. Thus, tmp is not a double; it has whatever type gets bound to the
template parameter A when calc is used. Because we cannot reuse names of
template parameters, the declaration of the variable named B is an error.
Because a parameter name cannot be reused, the name of a template parameter
can appear only once with in a given template parameter list:
Click here to view code image
// error: illegal reuse of template parameter name V
template <typename V, typename V> // ..Template Declarations
A template declaration must include the template parameters :
Click here to view code image
// declares but does not define compare and Blob
template <typename T> int compare(const T&, const T&);
template <typename T> class Blob;Fifth Edition
As with function parameters, the names of a template parameter need not be the
same across the declaration(s) and the definition of the same template:
Click here to view code image
// all three uses of calc refer to the same function template
template <typename T> T calc(const T&, const T&); // declaration
template <typename U> U calc(const U&, const U&); // declaration
// definition of the template
template <typename Type>
Type calc(const Type& a, const Type& b) { /* . . . */ }
Of course, every declaration and the definition of a given template must have the
same number and kind (i.e., type or nontype) of parameters.
  Best Practices
For reasons we¡¯ll explain in ¡ì 16.3 (p. 698), declarations for all the templates
needed by a given file usually should appear together at the beginning of a
file before any code that uses those names.
Using Class Members That Are Types
Recall that we use the scope operator (::) to access both static members and type
members (¡ì 7.4, p. 282, and ¡ì 7.6, p. 301). In ordinary (nontemplate) code, the
compiler has access to the class defintion. As a result, it knows whether a name
accessed through the scope operator is a type or a static member. For example,
when we write string::size_type, the compiler has the definition of string and
can see that size_type is a type.
Assuming T is a template type parameter, When the compiler sees code such as
T::mem it won¡¯t know until instantiation time whether mem is a type or a static
data member. However, in order to process the template, the compiler must know
whether a name represents a type. For example, assuming T is the name of a type
parameter, when the compiler sees a statement of the following form:
T::size_type * p;
it needs to know whether we¡¯re defining a variable named p or are multiplying a
static data member named size_type by a variable named p.
By default, the language assumes that a name accessed through the scope operator
is not a type. As a result, if we want to use a type member of a template type
parameter, we must explicitly tell the compiler that the name is a type. We do so by
using the keyword typename:
Click here to view code imageFifth Edition
template <typename T>
typename T::value_type top(const T& c)
{
 if (!c.empty()) return c.back(); else return typename T::value_type();
}
Our top function expects a container as its argument and uses typename to specify
its return type and to generate a value initialized element (¡ì 7.5.3, p. 293) to return if
c has no elements.
  Note
When we want to inform the compiler that a name represents a type, we
must use the keyword typename, not class.
Default Template Arguments
Just as we can supply default arguments to function parameters (¡ì 6.5.1, p. 236), we
can also supply default template arguments. Under the new standard, we can
supply default arguments for both function and class templates. Earlier versions of the
language, allowed default arguments only with class templates.
As an example, we¡¯ll rewrite compare to use the library less function-object
template (¡ì 14.8.2, p. 574) by default:
Click here to view code image
// compare has a default template argument, less<T>
// and a default function argument, F()
template <typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f = F())
{
 if (f(v1, v2)) return -1; if (f(v2, v1)) return 1; return 0;
}
Here we¡¯ve given our template a second type parameter, named F, that represents
the type of a callable object (¡ì 10.3.2, p. 388) and defined a new function parameter,
f, that will be bound to a callable object.
We¡¯ve also provided defaults for this template parameter and its corresponding
function parameter. The default template argument specifies that compare will use
the library less function-object class, instantiated with the same type parameter asFifth Edition
compare. The default function argument says that f will be a default-initialized object
of type F.
When users call this version of compare, they may supply their own comparison
operation but are not required to do so:
Click here to view code image
bool i = compare(0, 42); // uses less; i is -1
// result depends on the isbns in item1 and item2
Sales_data item1(cin), item2(cin);
bool j = compare(item1, item2, compareIsbn);
The first call uses the default function argument, which is a default-initialized object of
type less<T>. In this call, T is int so that object has type less<int>. This
instantiation of compare will use less<int> to do its comparisons.
In the second call, we pass compareIsbn (¡ì 11.2.2, p. 425) and two objects of
type Sales_data. When compare is called with three arguments, the type of the
third argument must be a callable object that returns a type that is convertible to
bool and takes arguments of a type compatible with the types of the first two
arguments. As usual, the types of the template parameters are deduced from their
corresponding function arguments. In this call, the type of T is deduced as
Sales_data and F is deduced as the type of compareIsbn.
As with function default arguments, a template parameter may have a default
argument only if all of the parameters to its right also have default arguments.
Template Default Arguments and Class Templates
Whenever we use a class template, we must always follow the template¡¯s name with
brackets. The brackets indicate that a class must be instantiated from a template. In
particular, if a class template provides default arguments for all of its template
parameters, and we want to use those defaults, we must put an empty bracket pair
following the template¡¯s name:
Click here to view code image
template <class T = int> class Numbers { // by default T is int
public:
 Numbers(T v = 0): val(v) { }
  // various operations on numbers
private:
 T val;
};
Numbers<long double> lots_of_precision;
Numbers<> average_precision; // empty <> says we want the default type
Here we instantiate two versions of Numbers: average_precision instantiates
Numbers with T replaced by int; lots_of_precision instantiates Numbers withFifth Edition
T replaced by long double.
Exercises Section 16.1.3
Exercise 16.17: What, if any, are the differences between a type parameter
that is declared as a typename and one that is declared as a class? When
must typename be used?
Exercise 16.18: Explain each of the following function template declarations
and identify whether any are illegal. Correct each error that you find.
Click here to view code image
(a) template <typename T, U, typename V> void f1(T, U, V);
(b) template <typename T> T f2(int &T);
(c) inline template <typename T> T foo(T, unsigned int*);
(d) template <typename T> f4(T, T);
(e) typedef char Ctype;
  template <typename Ctype> Ctype f5(Ctype a);
Exercise 16.19: Write a function that takes a reference to a container and
prints the elements in that container. Use the container¡¯s size_type and
size members to control the loop that prints the elements.
Exercise 16.20: Rewrite the function from the previous exercise to use
iterators returned from begin and end to control the loop.
16.1.4. Member Templates
A class¡ªeither an ordinary class or a class template¡ªmay have a member function
that is itself a template. Such members are referred to as member templates.
Member templates may not be virtual.
Member Templates of Ordianary (Nontemplate) Classes
As an example of an ordinary class that has a member template, we¡¯ll define a class
that is similar to the default deleter type used by unique_ptr (¡ì 12.1.5, p. 471).
Like the default deleter, our class will have an overloaded function-call operator (¡ì
14.8, p. 571) that will take a pointer and execute delete on the given pointer. Unlike
the default deleter, our class will also print a message whenever the deleter is
executed. Because we want to use our deleter with any type, we¡¯ll make the call
operator a template:
Click here to view code image
// function-object class that calls delete on a given pointerFifth Edition
class DebugDelete {
public:
 DebugDelete(std::ostream &s = std::cerr): os(s) { }
  // as with any function template, the type of T is deduced by the compiler
  template <typename T> void operator()(T *p) const { os << "deleting unique_ptr" << std::endl; delete p;
}
private:
 std::ostream &os;
};
Like any other template, a member template starts with its own template parameter
list. Each DebugDelete object has an ostream member on which to write, and a
member function that is itself a template. We can use this class as a replacement for
delete:
Click here to view code image
double* p = new double;
DebugDelete d; // an object that can act like a delete expression
d(p); // calls DebugDelete::operator()(double*), which deletes p
int* ip = new int;
// calls operator()(int*) on a temporary DebugDelete object
DebugDelete()(ip)Because calling a DebugDelete object deletes its given pointer, we can also use
DebugDelete as the deleter of a unique_ptr. To override the deleter of a
unique_ptr, we supply the type of the deleter inside brackets and supply an object
of the deleter type to the constructor (¡ì 12.1.5, p. 471):
Click here to view code image
// destroying the the object to which p points
// instantiates DebugDelete::operator()<int>(int *)
unique_ptr<int, DebugDelete> p(new int, DebugDelete());
// destroying the the object to which sp points
// instantiates DebugDelete::operator()<string>(string*)
unique_ptr<string, DebugDelete> sp(new string,
DebugDelete());
Here, we¡¯ve said that p¡¯s deleter will have type DebugDelete, and we have supplied
an unnamed object of that type in p¡¯s constructor.
The unique_ptr destructor calls the DebugDelete¡¯s call operator. Thus,
whenever unique_ptr¡¯s destructor is instantiated, DebugDelete¡¯s call operator will
also be instantiated: Thus, the definitions above will instantiate:
Click here to view code image
// sample instantiations for member templates of DebugDelete
void DebugDelete::operator()(int *p) const { delete p; }
void DebugDelete::operator()(string *p) const { delete p; }Fifth Edition
Member Templates of Class Templates
We can also define a member template of a class template. In this case, both the
class and the member have their own, independent, template parameters.
As an example, we¡¯ll give our Blob class a constructor that will take two iterators
denoting a range of elements to copy. Because we¡¯d like to support iterators into
varying kinds of sequences, we¡¯ll make this constructor a template:
Click here to view code image
template <typename T> class Blob { template <typename It> Blob(It b, It e);
  // ...
};
This constructor has its own template type parameter, It, which it uses for the type
of its two function parameters.
Unlike ordinary function members of class templates, member templates are function
templates. When we define a member template outside the body of a class template,
we must provide the template parameter list for the class template and for the
function template. The parameter list for the class template comes first, followed by
the member¡¯s own template parameter list:
Click here to view code image
template <typename T> // type parameter for the class
template <typename It> // type parameter for the constructor
  Blob<T>::Blob(It b, It e): data(std::make_shared<std::vector<T>>(b, e)) {
}
Here we are defining a member of a class template that has one template type
parameter, which we have named T. The member itself is a function template that
has a type parameter named It.
Instantiation and Member Templates
To instantiate a member template of a class template, we must supply arguments for
the template parameters for both the class and the function templates. As usual,
argument(s) for the class template parameter(s) are determined by the type of the
object through which we call the member template. Also as usual, the compiler
typically deduces template argument(s) for the member template¡¯s own parameter(s)
from the arguments passed in the call (¡ì 16.1.1, p. 653):
Click here to view code image
int ia[] = {0,1,2,3,4,5,6,7,8,9};Fifth Edition
vector<long> vi = {0,1,2,3,4,5,6,7,8,9};
list<const char*> w = {"now", "is", "the", "time"};
// instantiates the Blob<int> class
// and the Blob<int> constructor that has two int* parameters
Blob<int> a1(begin(ia), end(ia));
// instantiates the Blob<int> constructor that has
// two vector<long>::iterator parameters
Blob<int> a2(vi.begin(), vi.end());
// instantiates the Blob<string> class and the Blob<string>
// constructor that has two (list<const char*>::iterator parameters
Blob<string> a3(w.begin(), w.end());
When we define a1, we explicitly specify that the compiler should instantiate a version
of Blob with the template parameter bound to int. The type parameter for the
constructor¡¯s own parameters will be deduced from the type of begin(ia) and
end(ia). That type is int*. Thus, the definition of a1 instantiates:
Blob<int>::Blob(int*, int*);
The definition of a2 uses the already instantiated Blob<int> class, and instantiates
the constructor with It replaced by vector<short>::iterator. The definition of
a3 (explicitly) instantiates the Blob with its template parameter bound to string
and (implicitly) instantiates the member template constructor of that class with its
parameter bound to list<const char*>.
Exercises Section 16.1.4
Exercise 16.21: Write your own version of DebugDelete.
Exercise 16.22: Revise your TextQuery programs from ¡ì 12.3 (p. 484) so
that the shared_ptr members use a DebugDelete as their deleter (¡ì
12.1.4, p. 468).
Exercise 16.23: Predict when the call operator will be executed in your
main query program. If your expectations and what happens differ, be sure
you understand why.
Exercise 16.24: Add a constructor that takes two iterators to your Blob
template.
16.1.5. Controlling Instantiations
The fact that instantiations are generated when a template is used (¡ì 16.1.1, p. 656)
means that the same instantiation may appear in multiple object files. When two or
more separately compiled source files use the same template with the same template
arguments, there is an instantiation of that template in each of those files.Fifth Edition
In large systems, the overhead of instantiating the same template in multiple files
can become significant. Under the new standard, we can avoid this overhead through
an explicit instantiation. An explicit instantiation has the form
Click here to view code image
extern template declaration; // instantiation declaration
template declaration; // instantiation definition
where declaration is a class or function declaration in which all the template
parameters are replaced by the template arguments. For example,
Click here to view code image
// instantion declaration and definition
extern template class Blob<string>; // declaration
template int compare(const int&, const int&); // definition
When the compiler sees an extern template declaration, it will not generate code for
that instantiation in that file. Declaring an instantiation as extern is a promise that
there will be a nonextern use of that instantiation elsewhere in the program. There
may be several extern declarations for a given instantiation but there must be
exactly one definition for that instantiation.
Because the compiler automatically instantiates a template when we use it, the
extern declaration must appear before any code that uses that instantiation:
Click here to view code image
// Application.cc
// these template types must be instantiated elsewhere in the prograextern template class Blob<string>;
extern template int compare(const int&, const int&);
Blob<string> sa1, sa2; // instantiation will appear elsewhere
// Blob<int> and its initializer_list constructor instantiated in this filBlob<int> a1 = {0,1,2,3,4,5,6,7,8,9}Blob<int> a2(a1); // copy constructor instantiated in this file
int i = compare(a1[0], a2[0]); // instantiation will appear elsewhere
The file Application.o will contain instantiations for Blob<int>, along with the
initializer_list and copy constructors for that class. The compare<int>
function and Blob<string> class will not be instantiated in that file. There must be
definitions of these templates in some other file in the program:
Click here to view code image
// templateBuild.cc
// instantiation file must provide a (nonextern) definition for every
// type and function that other files declare as externFifth Edition
template int compare(const int&, const int&)template class Blob<string>; // instantiates all members of the class
template
When the compiler sees an instantiation definition (as opposed to a declaration), it
generates code. Thus, the file templateBuild.o will contain the definitions for
compare instantiated with int and for the Blob<string> class. When we build the
application, we must link templateBuild.o with the Application.o files.
  Warning
There must be an explicit instantiation definition somewhere in the program
for every instantiation declaration.
Instantiation Definitions Instantiate All Members
An instantiation definition for a class template instantiates all the members of that
template including inline member functions. When the compiler sees an instantiation
definition it cannot know which member functions the program uses. Hence, unlike the
way it handles ordinary class template instantiations, the compiler instantiates all the
members of that class. Even if we do not use a member, that member will be
instantiated. Consequently, we can use explicit instantiation only for types that can be
used with all the members of that template.
  Note
An instantiation definition can be used only for types that can be used with
every member function of a class template.
16.1.6. Efficiency and Flexibility
The library smart pointer types (¡ì 12.1, p. 450) offer a good illustration of design
choices faced by designers of templates.
The obvious difference between shared_ptr and unique_ptr is the strategy
they use in managing the pointer they hold¡ªone class gives us shared ownership; the
other owns the pointer that it holds. This difference is essential to what these classes
do.
These classes also differ in how they let users override their default deleter. We can
easily override the deleter of a shared_ptr by passing a callable object when weFifth Edition
create or reset the pointer. In contrast, the type of the deleter is part of the type of
a unique_ptr object. Users must supply that type as an explicit template argument
when they define a unique_ptr. As a result, it is more complicated for users of
unique_ptr to provide their own deleter.
Exercises Section 16.1.5
Exercise 16.25: Explain the meaning of these declarations:
Click here to view code image
extern template class vector<string>;
template class vector<Sales_data>;
Exercise 16.26: Assuming NoDefault is a class that does not have a
default constructor, can we explicitly instantiate vector<NoDefault>? If
not, why not?
Exercise 16.27: For each labeled statement explain what, if any,
instantiations happen. If a template is instantiated, explain why; if not,
explain why not.
Click here to view code image
template <typename T> class Stack { };
void f1(Stack<char>); // (a)
class Exercise {
  Stack<double> &rsd; // (b)
  Stack<int> si; // (c)
};
int main() {
  Stack<char> *sc; // (d)
  f1(*sc); // (e)
  int iObj = sizeof(Stack< string >); // (f)
}
The difference in how the deleter is handled is incidental to the functionality of
these classes. However, as we¡¯ll see, this difference in implementation strategy may
have important performance impacts.
Binding the Deleter at Run TimAlthough we don¡¯t know how the library types are implemented, we can infer that
shared_ptr must access its deleter indirectly. That is the deleter must be stored as
a pointer or as a class (such as function (¡ì 14.8.3, p. 577)) that encapsulates a
pointer.
We can be certain that shared_ptr does not hold the deleter as a direct member,
16.3. Overloading and Templates
Function templates can be overloaded by other templates or by ordinary, nontemplate
functions. As usual, functions with the same name must differ either as to the number
or the type(s) of their parameters.
Exercises Section 16.2.7
Exercise 16.47: Write your own version of the flip function and test it by
calling functions that have lvalue and rvalue reference parameters.
Function matching (¡ì 6.4, p. 233) is affected by the presence of function templates in
the following ways:
? The candidate functions for a call include any function-template instantiation for
which template argument deduction (¡ì 16.2, p. 678) succeeds.
? The candidate function templates are always viable, because template argument
deduction will have eliminated any templates that are not viable.
? As usual, the viable functions (template and nontemplate) are ranked by the
conversions, if any, needed to make the call. Of course, the conversions used to
call a function template are quite limited (¡ì 16.2.1, p. 679).
? Also as usual, if exactly one function provides a better match than any of the
others, that function is selected. However, if there are several functions that
provide an equally good match, then:
¨C If there is only one nontemplate function in the set of equally good matches,
the nontemplate function is called.
¨C If there are no nontemplate functions in the set, but there are multiple function
templates, and one of these templates is more specialized than any of the
others, the more specialized function template is called.
¨C Otherwise, the call is ambiguous.
 Warning
Correctly defining a set of overloaded function templates requires a good
understanding of the relationship among types and of the restricted
conversions applied to arguments in template functions.
C++ Primer, Fifth Edition
Writing Overloaded Templates
As an example, we¡¯ll build a set of functions that might be useful during debugging.
We¡¯ll name our debugging functions debug_rep, each of which will return a string
representation of a given object. We¡¯ll start by writing the most general version of this
function as a template that takes a reference to a const object:
Click here to view code image
// print any type we don't otherwise handle
template <typename T> string debug_rep(const T &t)
{
 ostringstream ret; // see ¡ì 8.3 (p. 321)
 ret << t; // uses T's output operator to print a representation of t
 return ret.str(); // return a copy of the string to which ret is bound
}
This function can be used to generate a string corresponding to an object of any
type that has an output operator.
Next, we¡¯ll define a version of debug_rep to print pointers:
Click here to view code image
// print pointers as their pointer value, followed by the object to which the pointer points
// NB: this function will not work properly with char*; see ¡ì 16.3 (p. 698)
template <typename T> string debug_rep(T *p)
{
 ostringstream ret;
 ret << "pointer: " << p; // print the pointer's own value
 if (p)
 ret << " " << debug_rep(*p); // print the value to which p
points
 else
 ret << " null pointer"; // or indicate that the p is null
 return ret.str(); // return a copy of the string to which ret is bound
}
This version generates a string that contains the pointer¡¯s own value and calls
debug_rep to print the object to which that pointer points. Note that this function
can¡¯t be used to print character pointers, because the IO library defines a version of
the << for char* values. That version of << assumes the pointer denotes a null?terminated character array, and prints the contents of the array, not its address. We¡¯ll
see in ¡ì 16.3 (p. 698) how to handle character pointers.
We might use these functions as follows:
Click here to view code image
string s("hi");
C++ Primer, Fifth Edition
cout << debug_rep(s) << endl;
For this call, only the first version of debug_rep is viable. The second version of
debug_rep requires a pointer parameter, and in this call we passed a nonpointer
object. There is no way to instantiate a function template that expects a pointer type
from a nonpointer argument, so argument deduction fails. Because there is only one
viable function, that is the one that is called.
If we call debug_rep with a pointer:
Click here to view code image
cout << debug_rep(&s) << endl;
both functions generate viable instantiations:
? debug_rep(const string* &), which is the instantiation of the first version
of debug_rep with T bound to string*
? debug_rep(string*), which is the instantiation of the second version of
debug_rep with T bound to string
The instantiation of the second version of debug_rep is an exact match for this call.
The instantiation of the first version requires a conversion of the plain pointer to a
pointer to const. Normal function matching says we should prefer the second
template, and indeed that is the one that is run.
Multiple Viable Templates
As another example, consider the following call:
Click here to view code image
const string *sp = &s;
cout << debug_rep(sp) << endl;
Here both templates are viable and both provide an exact match:
? debug_rep(const string* &), the instantiation of the first version of the
template with T bound to const string*
? debug_rep(const string*), the instantiation of the second version of the
template with T bound to const string
In this case, normal function matching can¡¯t distinguish between these two calls. We
might expect this call to be ambiguous. However, due to the special rule for
overloaded function templates, this call resolves to debug_rep(T*), which is the
more specialized template.
The reason for this rule is that without it, there would be no way to call the pointer
version of debug_rep on a pointer to const. The problem is that the template
debug_rep(const T&) can be called on essentially any type, including pointer
types. That template is more general than debug_rep(T*), which can be called only
C++ Primer, Fifth Edition
on pointer types. Without this rule, calls that passed pointers to const would always
be ambiguous.
 Note
When there are several overloaded templates that provide an equally good
match for a call, the most specialized version is preferred.
Nontemplate and Template Overloads
For our next example, we¡¯ll define an ordinary nontemplate version of debug_rep to
print strings inside double quotes:
Click here to view code image
// print strings inside double quotes
string debug_rep(const string &s)
{
 return '"' + s + '"';
}
Now, when we call debug_rep on a string,
Click here to view code image
string s("hi");
cout << debug_rep(s) << endl;
there are two equally good viable functions:
? debug_rep<string>(const string&), the first template with T bound to
string
? debug_rep(const string&), the ordinary, nontemplate function
In this case, both functions have the same parameter list, so obviously, each function
provides an equally good match for this call. However, the nontemplate version is
selected. For the same reasons that the most specialized of equally good function
templates is preferred, a nontemplate function is preferred over equally good
match(es) to a function template.
 Note
When a nontemplate function provides an equally good match for a call as a
function template, the nontemplate version is preferred.
Overloaded Templates and Conversions
C++ Primer, Fifth Edition
There¡¯s one case we haven¡¯t covered so far: pointers to C-style character strings and
string literals. Now that we have a version of debug_rep that takes a string, we
might expect that a call that passes character strings would match that version.
However, consider this call:
Click here to view code image
cout << debug_rep("hi world!") << endl; // calls debug_rep(T*)
Here all three of the debug_rep functions are viable:
? debug_rep(const T&), with T bound to char[10]
? debug_rep(T*), with T bound to const char
? debug_rep(const string&), which requires a conversion from const
char* to string
Both templates provide an exact match to the argument¡ªthe second template
requires a (permissible) conversion from array to pointer, and that conversion is
considered as an exact match for function-matching purposes (¡ì 6.6.1, p. 245). The
nontemplate version is viable but requires a user-defined conversion. That function is
less good than an exact match, leaving the two templates as the possible functions to
call. As before, the T* version is more specialized and is the one that will be selected.
If we want to handle character pointers as strings, we can define two more
nontemplate overloads:
Click here to view code image
// convert the character pointers to string and call the string version of debug_rep
string debug_rep(char *p)
{
 return debug_rep(string(p));
}
string debug_rep(const char *p)
{
 return debug_rep(string(p));
}
Missing Declarations Can Cause the Program to Misbehave
It is worth noting that for the char* versions of debug_rep to work correctly, a
declaration for debug_rep(const string&) must be in scope when these
functions are defined. If not, the wrong version of debug_rep will be called:
Click here to view code image
template <typename T> string debug_rep(const T &t);
template <typename T> string debug_rep(T *p);
// the following declaration must be in scope
C++ Primer, Fifth Edition
// for the definition of debug_rep(char*) to do the right thing
string debug_rep(const string &);
string debug_rep(char *p)
{
 // if the declaration for the version that takes a const string& is not in scope
 // the return will call debug_rep(const T&) with T instantiated to string
 return debug_rep(string(p));
}
Ordinarily, if we use a function that we forgot to declare, our code won¡¯t compile. Not
so with functions that overload a template function. If the compiler can instantiate the
call from the template, then the missing declaration won¡¯t matter. In this example, if
we forget to declare the version of debug_rep that takes a string, the compiler will
silently instantiate the template version that takes a const T&.
 Tip
Declare every function in an overload set before you define any of the
functions. That way you don¡¯t have to worry whether the compiler will
instantiate a call before it sees the function you intended to call.
Exercises Section 16.3
Exercise 16.48: Write your own versions of the debug_rep functions.
Exercise 16.49: Explain what happens in each of the following calls:
Click here to view code image
template <typename T> void f(T);
template <typename T> void f(const T*);
template <typename T> void g(T);
template <typename T> void g(T*);
int i = 42, *p = &i;
const int ci = 0, *p2 = &ci;
g(42); g(p); g(ci); g(p2);
f(42); f(p); f(ci); f(p2);
Exercise 16.50: Define the functions from the previous exercise so that they
print an identifying message. Run the code from that exercise. If the calls
behave differently from what you expected, make sure you understand why.
16.4. Variadic Templates
C++ Primer, Fifth Edition
A variadic template is a template function or class that can take a varying number
of parameters. The varying parameters are known as a parameter pack. There are
two kinds of parameter packs: A template parameter pack represents zero or more
template parameters, and a function parameter pack represents zero or more
function parameters.
We use an ellipsis to indicate that a template or function parameter represents a
pack. In a template parameter list, class... or typename... indicates that the
following parameter represents a list of zero or more types; the name of a type
followed by an ellipsis represents a list of zero or more nontype parameters of the
given type. In the function parameter list, a parameter whose type is a template
parameter pack is a function parameter pack. For example:
Click here to view code image
// Args is a template parameter pack; rest is a function parameter pack
// Args represents zero or more template type parameters
// rest represents zero or more function parameters
template <typename T, typename... Args>
void foo(const T &t, const Args& ... rest);
declares that foo is a variadic function that has one type parameter named T and a
template parameter pack named Args. That pack represents zero or more additional
type parameters. The function parameter list of foo has one parameter, whose type
is a const & to whatever type T has, and a function parameter pack named rest.
That pack represents zero or more function parameters.
As usual, the compiler deduces the template parameter types from the function¡¯s
arguments. For a variadic template, the compiler also deduces the number of
parameters in the pack. For example, given these calls:
Click here to view code image
int i = 0; double d = 3.14; string s = "how now brown cow";
foo(i, s, 42, d); // three parameters in the pack
foo(s, 42, "hi"); // two parameters in the pack
foo(d, s); // one parameter in the pack
foo("hi"); // empty pack
the compiler will instantiate four different instances of foo:
Click here to view code image
void foo(const int&, const string&, const int&, const
double&);
void foo(const string&, const int&, const char[3]&);
void foo(const double&, const string&);
void foo(const char[3]&);
In each case, the type of T is deduced from the type of the first argument. The
remaining arguments (if any) provide the number of, and types for, the additional
C++ Primer, Fifth Edition
arguments to the function.
The sizeof... Operator
When we need to know how many elements there are in a pack, we can use the
sizeof... operator. Like sizeof (¡ì 4.9, p. 156), sizeof... returns a constant
expression (¡ì 2.4.4, p. 65) and does not evaluate its argument:
Click here to view code image
template<typename ... Args> void g(Args ... args) {
 cout << sizeof...(Args) << endl; // number of type parameters
 cout << sizeof...(args) << endl; // number of function
parameters
}
Exercises Section 16.4
Exercise 16.51: Determine what sizeof...(Args) and
sizeof...(rest) return for each call to foo in this section.
Exercise 16.52: Write a program to check your answer to the previous
question.
16.4.1. Writing a Variadic Function Template
In ¡ì 6.2.6 (p. 220) we saw that we can use an initializer_list to define a
function that can take a varying number of arguments. However, the arguments must
have the same type (or types that are convertible to a common type). Variadic
functions are used when we know neither the number nor the types of the arguments
we want to process. As an example, we¡¯ll define a function like our earlier error_msg
function, only this time we¡¯ll allow the argument types to vary as well. We¡¯ll start by
defining a variadic function named print that will print the contents of a given list of
arguments on a given stream.
Variadic functions are often recursive (¡ì 6.3.2, p. 227). The first call processes the
first argument in the pack and calls itself on the remaining arguments. Our print
function will execute this way¡ªeach call will print its second argument on the stream
denoted by its first argument. To stop the recursion, we¡¯ll also need to define a
nonvariadic print function that will take a stream and an object:
Click here to view code image
C++ Primer, Fifth Edition
// function to end the recursion and print the last element
// this function must be declared before the variadic version of print is defined
template<typename T>
ostream &print(ostream &os, const T &t)
{
 return os << t; // no separator after the last element in the pack
}
// this version of print will be called for all but the last element in the pack
template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest)
{
 os << t << ", "; // print the first argument
 return print(os, rest...); // recursive call; print the other
arguments
}
The first version of print stops the recursion and prints the last argument in the
initial call to print. The second, variadic, version prints the argument bound to t
and calls itself to print the remaining values in the function parameter pack.
The key part is the call to print inside the variadic function:
Click here to view code image
return print(os, rest...); // recursive call; print the other arguments
The variadic version of our print function takes three parameters: an ostream&, a
const T&, and a parameter pack. Yet this call passes only two arguments. What
happens is that the first argument in rest gets bound to t. The remaining arguments
in rest form the parameter pack for the next call to print. Thus, on each call, the
first argument in the pack is removed from the pack and becomes the argument
bound to t. That is, given:
Click here to view code image
print(cout, i, s, 42); // two parameters in the pack
the recursion will execute as follows:
The first two calls can match only the variadic version of print because the
nonvariadic version isn¡¯t viable. These calls pass four and three arguments,
respectively, and the nonvariadic print takes only two arguments.
For the last call in the recursion, print(cout, 42), both versions of print are
viable. This call passes exactly two arguments, and the type of the first argument is
ostream&. Thus, the nonvariadic version of print is viable.
C++ Primer, Fifth Edition
The variadic version is also viable. Unlike an ordinary argument, a parameter pack
can be empty. Hence, the variadic version of print can be instantiated with only two
parameters: one for the ostream& parameter and the other for the const T&
parameter.
Both functions provide an equally good match for the call. However, a nonvariadic
template is more specialized than a variadic template, so the nonvariadic version is
chosen for this call (¡ì 16.3, p. 695).
 Warning
A declaration for the nonvariadic version of print must be in scope when
the variadic version is defined. Otherwise, the variadic function will recurse
indefinitely.
Exercises Section 16.4.1
Exercise 16.53: Write your own version of the print functions and test
them by printing one, two, and five arguments, each of which should have
different types.
Exercise 16.54: What happens if we call print on a type that doesn¡¯t have
an << operator?
Exercise 16.55: Explain how the variadic version of print would execute if
we declared the nonvariadic version of print after the definition of the
variadic version.
16.4.2. Pack Expansion
Aside from taking its size, the only other thing we can do with a parameter pack is to
expand it. When we expand a pack, we also provide a pattern to be used on each
expanded element. Expanding a pack separates the pack into its constituent elements,
applying the pattern to each element as it does so. We trigger an expansion by
putting an ellipsis (. . . ) to the right of the pattern.
For example, our print function contains two expansions:
Click here to view code image
template <typename T, typename... Args>
ostream &
print(ostream &os, const T &t, const Args&... rest)// expand
Args
C++ Primer, Fifth Edition
{
 os << t << ", ";
 return print(os, rest...); // expand
rest
}
The first expansion expands the template parameter pack and generates the function
parameter list for print. The second expansion appears in the call to print. That
pattern generates the argument list for the call to print.
The expansion of Args applies the pattern const Args& to each element in the
template parameter pack Args. The expansion of this pattern is a comma-separated
list of zero or more parameter types, each of which will have the form const type&.
For example:
Click here to view code image
print(cout, i, s, 42); // two parameters in the pack
The types of the last two arguments along with the pattern determine the types of the
trailing parameters. This call is instantiated as
Click here to view code image
ostream&
print(ostream&, const int&, const string&, const int&);
The second expansion happens in the (recursive) call to print. In this case, the
pattern is the name of the function parameter pack (i.e., rest). This pattern expands
to a comma-separated list of the elements in the pack. Thus, this call is equivalent to
print(os, s, 42);
Understanding Pack Expansions
The expansion of the function parameter pack in print just expanded the pack into
its constituent parts. More complicated patterns are also possible when we expand a
function parameter pack. For example, we might write a second variadic function that
calls debug_rep (¡ì 16.3, p. 695) on each of its arguments and then calls print to
print the resulting strings:
Click here to view code image
// call debug_rep on each argument in the call to print
template <typename... Args>
ostream &errorMsg(ostream &os, const Args&... rest)
{
 // print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
 return print(os, debug_rep(rest)...);
}
The call to print uses the pattern debug_rep(rest). That pattern says that we
C++ Primer, Fifth Edition
want to call debug_rep on each element in the function parameter pack rest. The
resulting expanded pack will be a comma-separated list of calls to debug_rep. That
is, a call such as
Click here to view code image
errorMsg(cerr, fcnName, code.num(), otherData, "other",
item);
will execute as if we had written
Click here to view code image
print(cerr, debug_rep(fcnName), debug_rep(code.num()), debug_rep(otherData), debug_rep("otherData"), debug_rep(item));
In contrast, the following pattern would fail to compile:
Click here to view code image
// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))
print(os, debug_rep(rest...)); // error: no matching function to call
The problem here is that we expanded rest in the call to debug_rep. This call
would execute as if we had written
Click here to view code image
print(cerr, debug_rep(fcnName, code.num(), otherData, "otherData", item));
In this expansion, we attempted to call debug_rep with a list of five arguments.
There is no version of debug_rep that matches this call. The debug_rep function is
not variadic and there is no version of debug_rep that has five parameters.
 Note
The pattern in an expansion applies separately to each element in the pack.
Exercises Section 16.4.2
Exercise 16.56: Write and test a variadic version of errorMsg.
Exercise 16.57: Compare your variadic version of errorMsg to the
error_msg function in ¡ì 6.2.6 (p. 220). What are the advantages and
disadvantages of each approach?
16.4.3. Forwarding Parameter Packs
C++ Primer, Fifth Edition
Under the new standard, we can use variadic templates together with forward to
write functions that pass their arguments unchanged to some other function. To
illustrate such functions, we¡¯ll add an emplace_back member to our StrVec class (¡ì
13.5, p. 526). The emplace_back member of the library containers is a variadic
member template (¡ì 16.1.4, p. 673) that uses its arguments to construct an element
directly in space managed by the container.
Our version of emplace_back for StrVec will also have to be variadic, because
string has a number of constructors that differ in terms of their parameters.
Because we¡¯d like to be able to use the string move constructor, we¡¯ll also need to
preserve all the type information about the arguments passed to emplace_back.
As we¡¯ve seen, preserving type information is a two-step process. First, to preserve
type information in the arguments, we must define emplace_back¡¯s function
parameters as rvalue references to a template type parameter (¡ì 16.2.7, p. 693):
Click here to view code image
class StrVec {
public:
 template <class... Args> void emplace_back(Args&&...);
 // remaining members as in ¡ì 13.5 (p. 526)
};
The pattern in the expansion of the template parameter pack, &&, means that each
function parameter will be an rvalue reference to its corresponding argument.
Second, we must use forward to preserve the arguments¡¯ original types when
emplace_back passes those arguments to construct (¡ì 16.2.7, p. 694):
Click here to view code image
template <class... Args>
inline
void StrVec::emplace_back(Args&&... args)
{
 chk_n_alloc(); // reallocates the StrVec if necessary
 alloc.construct(first_free++,
std::forward<Args>(args)...);
}
The body of emplace_back calls chk_n_alloc (¡ì 13.5, p. 526) to ensure that
there is enough room for an element and calls construct to create an element in
the first_free spot. The expansion in the call to construct:
std::forward<Args>(args)...
expands both the template parameter pack, Args, and the function parameter pack,
args. This pattern generates elements with the form
C++ Primer, Fifth Edition
std::forward<Ti>(ti)
where Ti
 represents the type of the ith element in the template parameter pack and ti
represents the ith element in the function parameter pack. For example, assuming
svec is a StrVec, if we call
Click here to view code image
svec.emplace_back(10, 'c'); // adds cccccccccc as a new last element
the pattern in the call to construct will expand to
Click here to view code image
std::forward<int>(10), std::forward<char>(c)
By using forward in this call, we guarantee that if emplace_back is called with
an rvalue, then construct will also get an rvalue. For example, in this call:
Click here to view code image
svec.emplace_back(s1 + s2); // uses the move constructor
the argument to emplace_back is an rvalue, which is passed to construct as
Click here to view code image
std::forward<string>(string("the end"))
The result type from forward<string> is string&&, so construct will be called
with an rvalue reference. The construct function will, in turn, forward this argument
to the string move constructor to build this element.
Advice: Forwarding and Variadic Templates
Variadic functions often forward their parameters to other functions. Such
functions typically have a form similar to our emplace_back function:
Click here to view code image
// fun has zero or more parameters each of which is
// an rvalue reference to a template parameter type
template<typename... Args>
void fun(Args&&... args) // expands Args as a list of rvalue references
{
 // the argument to work expands both Args and args
 work(std::forward<Args>(args)...);
}
Here we want to forward all of fun¡¯s arguments to another function named
work that presumably does the real work of the function. Like our call to
construct inside emplace_back, the expansion in the call to work
C++ Primer, Fifth Edition
expands both the template parameter pack and the function parameter pack.
Because the parameters to fun are rvalue references, we can pass
arguments of any type to fun; because we use std::forward to pass
those arguments, all type information about those arguments will be
preserved in the call to work.
Exercises Section 16.4.3
Exercise 16.58: Write the emplace_back function for your StrVec class
and for the Vec class that you wrote for the exercises in ¡ì 16.1.2 (p. 668).
Exercise 16.59: Assuming s is a string, explain
svec.emplace_back(s).
Exercise 16.60: Explain how make_shared (¡ì 12.1.1, p. 451) works.
Exercise 16.61: Define your own version of make_shared.
16.5. Template Specializations
It is not always possible to write a single template that is best suited for every
possible template argument with which the template might be instantiated. In some
cases, the general template definition is simply wrong for a type: The general
definition might not compile or might do the wrong thing. At other times, we may be
able to take advantage of some specific knowledge to write more efficient code than
would be instantiated from the template. When we can¡¯t (or don¡¯t want to) use the
template version, we can define a specialized version of the class or function template.
Our compare function is a good example of a function template for which the
general definition is not appropriate for a particular type, namely, character pointers.
We¡¯d like compare to compare character pointers by calling strcmp rather than by
comparing the pointer values. Indeed, we have already overloaded the compare
function to handle character string literals (¡ì 16.1.1, p. 654):
Click here to view code image
// first version; can compare any two types
template <typename T> int compare(const T&, const T&);
// second version to handle string literals
template<size_t N, size_t M>
int compare(const char (&)[N], const char (&)[M]);
However, the version of compare that has two nontype template parameters will be
called only when we pass a string literal or an array. If we call compare with
C++ Primer, Fifth Edition
character pointers, the first version of the template will be called:
Click here to view code image
const char *p1 = "hi", *p2 = "mom";
compare(p1, p2); // calls the first template
compare("hi", "mom"); // calls the template with two nontype parameters
There is no way to convert a pointer to a reference to an array, so the second version
of compare is not viable when we pass p1 and p2 as arguments.
To handle character pointers (as opposed to arrays), we can define a template
specialization of the first version of compare. A specialization is a separate
definition of the template in which one or more template parameters are specified to
have particular types.
Defining a Function Template Specialization
When we specialize a function template, we must supply arguments for every template
parameter in the original template. To indicate that we are specializing a template, we
use the keyword template followed by an empty pair of angle brackets (< >). The
empty brackets indicate that arguments will be supplied for all the template
parameters of the original template:
Click here to view code image
// special version of compare to handle pointers to character arrays
template <>
int compare(const char* const &p1, const char* const &p2)
{
 return strcmp(p1, p2);
}
The hard part in understanding this specialization is the function parameter types.
When we define a specialization, the function parameter type(s) must match the
corresponding types in a previously declared template. Here we are specializing:
Click here to view code image
template <typename T> int compare(const T&, const T&);
in which the function parameters are references to a const type. As with type aliases,
the interaction between template parameter types, pointers, and const can be
surprising (¡ì 2.5.1, p. 68).
We want to define a specialization of this function with T as const char*. Our
function requires a reference to the const version of this type. The const version of
a pointer type is a constant pointer as distinct from a pointer to const (¡ì 2.4.2, p.
63). The type we need to use in our specialization is const char* const &, which
is a reference to a const pointer to const char.
C++ Primer, Fifth Edition
Function Overloading versus Template Specializations
When we define a function template specialization, we are essentially taking over the
job of the compiler. That is, we are supplying the definition to use for a specific
instantiation of the original template. It is important to realize that a specialization is
an instantiation; it is not an overloaded instance of the function name.
 Note
Specializations instantiate a template; they do not overload it. As a result,
specializations do not affect function matching.
Whether we define a particular function as a specialization or as an independent,
nontemplate function can impact function matching. For example, we have defined
two versions of our compare function template, one that takes references to array
parameters and the other that takes const T&. The fact that we also have a
specialization for character pointers has no impact on function matching. When we call
compare on a string literal:
compare("hi", "mom")
both function templates are viable and provide an equally good (i.e., exact) match to
the call. However, the version with character array parameters is more specialized (¡ì
16.3, p. 695) and is chosen for this call.
Had we defined the version of compare that takes character pointers as a plain
nontemplate function (rather than as a specialization of the template), this call would
resolve differently. In this case, there would be three viable functions: the two
templates and the nontemplate character-pointer version. All three are also equally
good matches for this call. As we¡¯ve seen, when a nontemplate provides an equally
good match as a function template, the nontemplate is selected (¡ì 16.3, p. 695)
Key Concept: Ordinary Scope Rules Apply to Specializations
In order to specialize a template, a declaration for the original template must
be in scope. Moreover, a declaration for a specialization must be in scope
before any code uses that instantiation of the template.
With ordinary classes and functions, missing declarations are (usually) easy
to find¡ªthe compiler won¡¯t be able to process our code. However, if a
specialization declaration is missing, the compiler will usually generate code
using the original template. Because the compiler can often instantiate the
original template when a specialization is missing, errors in declaration order
between a template and its specializations are easy to make but hard to find.
It is an error for a program to use a specialization and an instantiation of
C++ Primer, Fifth Edition
the original template with the same set of template arguments. However, it is
an error that the compiler is unlikely to detect.
 Best Practices
Templates and their specializations should be declared in the same
header file. Declarations for all the templates with a given name should
appear first, followed by any specializations of those templates.
Class Template Specializations
In addition to specializing function templates, we can also specialize class templates.
As an example, we¡¯ll define a specialization of the library hash template that we can
use to store Sales_data objects in an unordered container. By default, the
unordered containers use hash<key_type> (¡ì 11.4, p. 444) to organize their
elements. To use this default with our own data type, we must define a specialization
of the hash template. A specialized hash class must define
? An overloaded call operator (¡ì 14.8, p. 571) that returns a size_t and takes
an object of the container¡¯s key type
? Two type members, result_type and argument_type, which are the return
and argument types, respectively, of the call operator
? The default constructor and a copy-assignment operator (which can be implicitly
defined (¡ì 13.1.2, p. 500))
The only complication in defining this hash specialization is that when we specialize a
template, we must do so in the same namespace in which the original template is
defined. We¡¯ll have more to say about namespaces in ¡ì 18.2 (p. 785). For now, what
we need to know is that we can add members to a namespace. To do so, we must
first open the namespace:
Click here to view code image
// open the std namespace so we can specialize std::hash
namespace std {
} // close the std namespace; note: no semicolon after the close curly
Any definitions that appear between the open and close curlies will be part of the std
namespace.
The following defines a specialization of hash for Sales_data:
Click here to view code image
// 
C++ Primer, Fifth Edition
open the std namespace so we can specialize std::hash
namespace std {
template <> // we're defining a specialization with
struct hash<Sales_data> // the template parameter of Sales_data
{
 // the type used to hash an unordered container must define these types
 typedef size_t result_type;
 typedef Sales_data argument_type; // by default, this type needs
==
 size_t operator()(const Sales_data& s) const;
 // our class uses synthesized copy control and default constructor
};
size_t
hash<Sales_data>::operator()(const Sales_data& s) const
{
 return hash<string>()(s.bookNo) ^ hash<unsigned>()(s.units_sold) ^ hash<double>()(s.revenue);
}
} // close the std namespace; note: no semicolon after the close curly
Our hash<Sales_data> definition starts with template<>, which indicates that we
are defining a fully specialized template. The template we¡¯re specializing is named
hash and the specialized version is hash<Sales_data>. The members of the class
follow directly from the requirements for specializing hash.
As with any other class, we can define the members of a specialization inside the
class or out of it, as we did here. The overloaded call operator must define a hashing
function over the values of the given type. This function is required to return the same
result every time it is called for a given value. A good hash function will (almost
always) yield different results for objects that are not equal.
Here, we delegate the complexity of defining a good hash function to the library.
The library defines specializations of the hash class for the built-in types and for many
of the library types. We use an (unnamed) hash<string> object to generate a hash
code for bookNo, an object of type hash<unsigned> to generate a hash from
units_sold, and an object of type hash<double> to generate a hash from
revenue. We exclusive OR (¡ì 4.8, p. 154) these results to form an overall hash code
for the given Sales_data object.
It is worth noting that we defined our hash function to hash all three data members
so that our hash function will be compatible with our definition of operator== for
Sales_data (¡ì 14.3.1, p. 561). By default, the unordered containers use the
specialization of hash that corresponds to the key_type along with the equality
operator on the key type.
Assuming our specialization is in scope, it will be used automatically when we use
Sales_data as a key to one of these containers:
Click here to view code image
C++ Primer, Fifth Edition
// uses hash<Sales_data> and Sales_data operator==from ¡ì 14.3.1 (p. 561)
unordered_multiset<Sales_data> SDset;
Because hash<Sales_data> uses the private members of Sales_data, we must
make this class a friend of Sales_data:
Click here to view code image
template <class T> class std::hash; // needed for the friend
declaration
class Sales_data {
friend class std::hash<Sales_data>;
 // other members as before
};
Here we say that the specific instantiation of hash<Sales_data> is a friend.
Because that instantiation is defined in the std namespace, we must remember to
that this hash type is defined in the std namespace. Hence, our friend declaration
refers to std::hash.
 Note
To enable users of Sales_data to use the specialization of hash, we
should define this specialization in the Sales_data header.
Class-Template Partial Specializations
Differently from function templates, a class template specialization does not have to
supply an argument for every template parameter. We can specify some, but not all,
of the template parameters or some, but not all, aspects of the parameters. A class
template partial specialization is itself a template. Users must supply arguments for
those template parameters that are not fixed by the specialization.
 Note
We can partially specialize only a class template. We cannot partially
specialize a function template.
In ¡ì 16.2.3 (p. 684) we introduced the library remove_reference type. That
template works through a series of specializations:
Click here to view code image
// original, most general template
C++ Primer, Fifth Edition
template <class T> struct remove_reference {
 typedef T type;
};
// partial specializations that will be used for lvalue and rvalue references
template <class T> struct remove_reference<T&> // lvalue
references
 { typedef T type; };
template <class T> struct remove_reference<T&&> // rvalue
references
 { typedef T type; };
The first template defines the most general version. It can be instantiated with any
type; it uses its template argument as the type for its member named type. The next
two classes are partial specializations of this original template.
Because a partial specialization is a template, we start, as usual, by defining the
template parameters. Like any other specialization, a partial specialization has the
same name as the template it specializes. The specialization¡¯s template parameter list
includes an entry for each template parameter whose type is not completely fixed by
this partial specialization. After the class name, we specify arguments for the template
parameters we are specializing. These arguments are listed inside angle brackets
following the template name. The arguments correspond positionally to the parameters
in the original template.
The template parameter list of a partial specialization is a subset of, or a
specialization of, the parameter list of the original template. In this case, the
specializations have the same number of parameters as the original template.
However, the parameter¡¯s type in the specializations differ from the original template.
The specializations will be used for lvalue and rvalue reference types, respectively:
Click here to view code image
int i;
// decltype(42) is int, uses the original template
remove_reference<decltype(42)>::type a;
// decltype(i) is int&, uses first (T&) partial specialization
remove_reference<decltype(i)>::type b;
// decltype(std::move(i)) is int&&, uses second (i.e., T&&) partial specialization
remove_reference<decltype(std::move(i))>::type c;
All three variables, a, b, and c, have type int.
Specializing Members but Not the Class
Rather than specializing the whole template, we can specialize just specific member
function(s). For example, if Foo is a template class with a member Bar, we can
specialize just that member:
Click here to view code image
C++ Primer, Fifth Edition
template <typename T> struct Foo {
 Foo(const T &t = T()): mem(t) { }
 void Bar() { /* ... */ }
 T mem;
 // other members of Foo
};
template<> // we're specializing a template
void Foo<int>::Bar() // we're specializing the Bar member of Foo<int>
{
 // do whatever specialized processing that applies to ints
}
Here we are specializing just one member of the Foo<int> class. The other members
of Foo<int> will be supplied by the Foo template:
Click here to view code image
Foo<string> fs; // instantiates Foo<string>::Foo()
fs.Bar(); // instantiates Foo<string>::Bar()
Foo<int> fi; // instantiates Foo<int>::Foo()
fi.Bar(); // uses our specialization of Foo<int>::Bar()
When we use Foo with any type other than int, members are instantiated as usual.
When we use Foo with int, members other than Bar are instantiated as usual. If we
use the Bar member of Foo<int>, then we get our specialized definition.
Exercises Section 16.5
Exercise 16.62: Define your own version of hash<Sales_data> and
define an unordered_multiset of Sales_data objects. Put several
transactions into the container and print its contents.
Exercise 16.63: Define a function template to count the number of
occurrences of a given value in a vector. Test your program by passing it a
vector of doubles, a vector of ints, and a vector of strings.
Exercise 16.64: Write a specialized version of the template from the
previous exercise to handle vector<const char*> and a program that
uses this specialization.
Exercise 16.65: In ¡ì 16.3 (p. 698) we defined overloaded two versions of
debug_rep one had a const char* and the other a char* parameter.
Rewrite these functions as specializations.
Exercise 16.66: What are the advantages and disadvantages of overloading
these debug_rep functions as compared to defining specializations?
Exercise 16.67: Would defining these specializations affect function
matching for debug_rep? If so, how? If not, why not?
C++ Primer, Fifth Edition
Chapter Summary
Templates are a distinctive feature of C++ and are fundamental to the library. A
template is a blueprint that the compiler uses to generate specific class types or
functions. This process is called instantiation. We write the template once, and the
compiler instantiates the template for the type(s) or value(s) with which we use the
template.
We can define both function templates and class templates. The library algorithms
are function templates and the library containers are class templates.
An explicit template argument lets us fix the type or value of one or more template
parameters. Normal conversions are applied to parameters that have an explicit
template argument.
A template specialization is a user-provided instantiation of a template that binds
one or more template parameters to specified types or values. Specializations are
useful when there are types that we cannot use (or do not want to use) with the
template definition.
A major part of the latest release of the C++ standard is variadic templates. A
variadic template can take a varying number and types of parameters. Variadic
templates let us write functions, such as the container emplace members and the
library make_shared function, that pass arguments to an object¡¯s constructor.
Defined Terms
class template Definition from which specific classes can be instantiated. Class
templates are defined using the template keyword followed by a comma?separated list of one or more template parameters enclosed in < and > brackets,
followed by a class definition.
default template arguments A type or a value that a template uses if the user
does not supply a corresponding template argument.
explicit instantiation A declaration that supplies explicit arguments for all the
template parameters. Used to guide the instantiation process. If the declaration is
extern, the template will not be instantiated; otherwise, the template is
instantiated with the specified arguments. There must be a nonextern explicit
instantiation somewhere in the program for every extern template declaration.
explicit template argument Template argument supplied by the user in a call
to a function or when defining a template class type. Explicit template arguments
are supplied inside angle brackets immediately following the template¡¯s name.
function parameter pack Parameter pack that represents zero or more function
C++ Primer, Fifth Edition
parameters.
function template Definition from which specific functions can be instantiated. A
function template is defined using the template keyword followed by a comma?separated list of one or more template parameters enclosed in < and > brackets,
followed by a function definition.
instantiate Compiler process whereby the actual template argument(s) are used
to generate a specific instance of the template in which the parameter(s) are
replaced by the corresponding argument(s). Functions are instantiated
automatically based on the arguments used in a call. We must supply explicit
template arguments whenever we use a class template.
instantiation Class or function generated by the compiler from a template.
member template Member function that is a template. A member template may
not be virtual.
nontype parameter A template parameter that represents a value. Template
arguments for nontype template parameters must be constant expressions.
pack expansion Process by which a parameter pack is replaced by the
corresponding list of its elements.
parameter pack Template or function parameter that represents zero or more
parameters.
partial specialization Version of a class template in which some some but not
all of the template parameters are specified or in which one or more parameters
are not completely specified.
pattern Defines the form of each element in an expanded parameter pack.
template argument Type or value used to instantiate a template parameter.
template argument deduction Process by which the compiler determines
which function template to instantiate. The compiler examines the types of the
arguments that were specified using a template parameter. It automatically
instantiates a version of the function with those types or values bound to the
template parameters.
template parameter Name specifed in the template parameter list that may be
used inside the definition of a template. Template parameters can be type or
nontype parameters. To use a class template, we must supply explicit arguments
for each template parameter. The compiler uses those types or values to
instantiate a version of the class in which uses of the parameter(s) are replaced
by the actual argument(s). When a function template is used, the compiler
deduces the template arguments from the arguments in the call and instantiates a
specific function using the deduced template arguments.
C++ Primer, Fifth Edition
template parameter list List of parameters, separated by commas, to be used
in the definition or declaration of a template. Each parameter may be a type or
nontype parameter.
template parameter pack Parameter pack that represents zero or more
template parameters.
template specialization Redefinition of a class template, a member of a class
template, or a function template, in which some (or all) of the template
parameters are specified. A template specialization may not appear until after the
base template that it specializes has been declared. A template specialization must
appear before any use of the template with the specialized arguments. Each
template parameter in a function template must be completely specialized.
type parameter Name used in a template parameter list to represent a type.
Type parameters are specified following the keyword typename or class.
type transformation Class templates defined by the library that transform their
given template type parameter to a related type.
variadic template Template that takes a varying number of template
arguments. A template parameter pack is specified using an elipsis (e.g., class. .
., typename. . ., or type-name. . . ).
Part IV: Advanced Topics
Contents
Chapter 17 Specialized Library Facilities
Chapter 18 Tools for Large Programs
Chapter 19 Specialized Tools and Techniques
Part IV covers additional features that, although useful in the right context, are not
needed by every C++ programmer. These features divide into two clusters: those that
are useful for large-scale problems and those that are applicable to specialized
problems rather than general ones. Features for specialized problems occur both in the
language, the topic of Chapter 19, and in the library, Chapter 17.
In Chapter 17 we cover four special-purpose library facilities: the bitset class and
three new library facilities: tuples, regular expressions, and random numbers. We¡¯ll
also look at some of the less commonly used parts of the IO library.
Chapter 18 covers exception handling, namespaces, and multiple inheritance. These
features tend to be most useful in the context of large-scale problems.
Even programs simple enough to be written by a single author can benefit from
C++ Primer, Fifth Edition
exception handling, which is why we introduced the basics of exception handling in
Chapter 5. However, the need to deal with run-time errors tends to be more important
and harder to manage in problems that require large programming teams. In Chapter
18 we review some additional useful exception-handling facilities. We also look in more
detail at how exceptions are handled, and show how we can define and use our own
exception classes. This section will also cover improvements from the new standard
regarding specifying that a particular function will not throw.
Large-scale applications often use code from multiple independent vendors.
Combining independently developed libraries would be difficult (if not impossible) if
vendors had to put the names they define into a single namespace. Independently
developed libraries would almost inevitably use names in common with one another; a
name defined in one library would conflict with the use of that name in another
library. To avoid name collisions, we can define names inside a namespace.
Whenever we use a name from the standard library, we are using a name defined
in the namespace named std. Chapter 18 shows how we can define our own
namespaces.
Chapter 18 closes by looking at an important but infrequently used language
feature: multiple inheritance. Multiple inheritance is most useful for fairly complicated
inheritance hierarchies.
Chapter 19 covers several specialized tools and techniques that are applicable to
particular kinds of problems. Among the features covered in this chapter are how to
redefine how memory allocation works; C++ support for run-time type identification
(RTTI), which let us determine the actual type of an expression at run time; and how
we can define and use pointers to class members. Pointers to class members differ
from pointers to ordinary data or functions. Ordinary pointers only vary based on the
type of the object or function. Pointers to members must also reflect the class to
which the member belongs. We¡¯ll also look at three additional aggregate types:
unions, nested classes, and local classes. The chapter closes by looking briefly at a
collection of features that are inherently nonportable: the volatile qualifier, bit?fields, and linkage directives.
Chapter 17. Specialized Library Facilities
Contents
Section 17.1 The tuple Type
Section 17.2 The bitset Type
Section 17.3 Regular Expressions
Section 17.4 Random Numbers
Section 17.5 The IO Library Revisited
C++ Primer, Fifth Edition
Chapter Summary
Defined Terms
The latest standard greatly increased the size and scope of the library. Indeed, the
portion of the standard devoted to the library more than doubled between the first
release in 1998 and the 2011 standard. As a result, covering every C++ library class is
well beyond the scope of this Primer. However, there are four library facilities that,
although more specialized than other library facilities we¡¯ve covered, are general
enough to warrant discussion in an introductory book: tuples, bitsets, random number generation, and regular expressions. In addition, we will also cover some
additional, special-purpose parts of the IO library.
The library constitutes nearly two-thirds of the text of the new standard. Although we
cannot cover every library facility in depth, there remain a few library facilities that are
likely to be of use in many applications: tuples, bitsets, regular expressions, and
random numbers. We¡¯ll also look at some additional IO library capabilities: format
control, unformatted IO, and random access.
17.1. The tuple Type
A tuple is a template that is similar to a pair (¡ì 11.2.3, p. 426). Each pair type
has different types for its members, but every pair always has exactly two members.
A tuple also has members whose types vary from one tuple type to another, but a
tuple can have any number of members. Each distinct tuple type has a fixed
number of members, but the number of members in one tuple type can differ from
the number of members in another.
A tuple is most useful when we want to combine some data into a single object
but do not want to bother to define a data structure to represent those data. Table
17.1 lists the operations that tuples support. The tuple type, along with its
companion types and functions, are defined in the tuple header.
Table 17.1. Operations on tuples
sp
to obtain the object to which sp points. We then call the destructor, which is the
name of the type preceded by a tilde (~).
Like calling destroy, calling a destructor cleans up the given object but does not
free the space in which that object resides. We can reuse the space if desired.
  Note
Calling a destructor destroys an object but does not free the memory.
19.2. Run-Time Type Identification
Run-time type identification (RTTI) is provided through two operators:
? The typeid operator, which returns the type of a given expression
? The dynamic_cast operator, which safely converts a pointer or reference to a
base type into a pointer or reference to a derived type
When applied to pointers or references to types that have virtual functions, these
operators use the dynamic type (¡ì 15.2.3, p. 601) of the object to which the pointer
or reference is bound.
These operators are useful when we have a derived operation that we want to
perform through a pointer or reference to a base-class object and it is not possible to
make that operation a virtual function. Ordinarily, we should use virtual functions if we
can. When the operation is virtual, the compiler automatically selects the right function
according to the dynamic type of the object.
However, it is not always possible to define a virtual. If we cannot use a virtual, we
can use one of the RTTI operators. On the other hand, using these operators is more
error-prone than using virtual member functions: The programmer must know to
which type the object should be cast and must check that the cast was performed
successfully.
  Warning
RTTI should be used with caution. When possible, it is better to define a
virtual function rather than to take over managing the types directly.
19.2.1. The dynamic_cast OperatorC++ Primer, Fifth Edition
A dynamic_cast has the following form:
dynamic_cast<type*>(e)
dynamic_cast<type&>(e)
dynamic_cast<type&&>(e)
where type must be a class type and (ordinarily) names a class that has virtual
functions. In the first case, e must be a valid pointer (¡ì 2.3.2, p. 52); in the second, e
must be an lvalue; and in the third, e must not be an lvalue.
In all cases, the type of e must be either a class type that is publicly derived from
the target type, a public base class of the target type, or the same as the target
type. If e has one of these types, then the cast will succeed. Otherwise, the cast fails.
If a dynamic_cast to a pointer type fails, the result is 0. If a dynamic_cast to a
reference type fails, the operator throws an exception of type bad_cast.
Pointer-Type dynamic_casts
As a simple example, assume that Base is a class with at least one virtual function
and that class Derived is publicly derived from Base. If we have a pointer to Base
named bp, we can cast it, at run time, to a pointer to Derived as follows:
Click here to view code image
if (Derived *dp = dynamic_cast<Derived*>(bp))
{
  // use the Derived object to which dp points
} else { // bp points at a Base object
  // use the Base object to which bp points
}
If bp points to a Derived object, then the cast will initialize dp to point to the
Derived object to which bp points. In this case, it is safe for the code inside the if
to use Derived operations. Otherwise, the result of the cast is 0. If dp is 0, the
condition in the if fails. In this case, the else clause does processing appropriate to
Base instead.
  Note
We can do a dynamic_cast on a null pointer; the result is a null pointer of
the requested type.
It is worth noting that we defined dp inside the condition. By defining the variable in
a condition, we do the cast and corresponding check as a single operation. Moreover,
the pointer dp is not accessible outside the if. If the cast fails, then the unbound
pointer is not available for use in subsequent code where we might forget to checkC++ Primer, Fifth Edition
whether the cast succeeded.
  Best Practices
Performing a dynamic_cast in a condition ensures that the cast and test of
its result are done in a single expression.
Reference-Type dynamic_castA dynamic_cast to a reference type differs from a dynamic_cast to a pointer
type in how it signals that an error occurred. Because there is no such thing as a null
reference, it is not possible to use the same error-reporting strategy for references
that is used for pointers. When a cast to a reference type fails, the cast throws a
std::bad_cast exception, which is defined in the typeinfo library header.
We can rewrite the previous example to use references as follows:
Click here to view code image
void f(const Base &b)
{
 try { const Derived &d = dynamic_cast<const Derived&>(b);
  // use the Derived object to which b referred
  } catch (bad_cast) {
  // handle the fact that the cast failed
  }
}
19.2.2. The typeid Operator
The second operator provided for RTTI is the typeid operator. The typeid operator
allows a program to ask of an expression: What type is your object?
Exercises Section 19.2.1
Exercise 19.3: Given the following class hierarchy in which each class
defines a public default constructor and virtual destructor:
Click here to view code image
class A { /* . . . */ };
class B : public A { /* . . . */ };
class C : public B { /* . . . */ };
class D : public B, public A { /* . . . */ };C++ Primer, Fifth Edition
which, if any, of the following dynamic_casts fail?
(a) A *pa = new C; B *pb = dynamic_cast< B* >(pa);
(b) B *pb = new B;
 C *pc = dynamic_cast< C* >(pb);
(c) A *pa = new D;
 B *pb = dynamic_cast< B* >(pa);
Exercise 19.4: Using the classes defined in the first exercise, rewrite the
following code to convert the expression *pa to the type C&:
Click here to view code image
if (C *pc = dynamic_cast< C* >(pa))
  // use C's members
} else {
  // use A's members
}
Exercise 19.5: When should you use a dynamic_cast instead of a virtual
function?
A typeid expression has the form typeid(e) where e is any expression or a type
name. The result of a typeid operation is a reference to a const object of a library
type named type_info, or a type publicly derived from type_info. ¡ì 19.2.4 (p.
831) covers this type in more detail. The type_info class is defined in the
typeinfo header.
The typeid operator can be used with expressions of any type. As usual, top-level
const (¡ì 2.4.3, p. 63) is ignored, and if the expression is a reference, typeid
returns the type to which the reference refers. When applied to an array or function,
however, the standard conversion to pointer (¡ì 4.11.2, p. 161) is not done. That is, if
we take typeid(a) and a is an array, the result describes an array type, not a
pointer type.
When the operand is not of class type or is a class without virtual functions, then
the typeid operator indicates the static type of the operand. When the operand is an
lvalue of a class type that defines at least one virtual function, then the type is
evaluated at run time.
Using the typeid Operator
Ordinarily, we use typeid to compare the types of two expressions or to compare the
type of an expression to a specified type:
Click here to view code image
Derived *dp = new Derived;C++ Primer, Fifth Edition
Base *bp = dp; // both pointers point to a Derived object
// compare the type of two objects at run time
if (typeid(*bp) == typeid(*dp)) {
  // bp and dp point to objects of the same type
}
// test whether the run-time type is a specific type
if (typeid(*bp) == typeid(Derived)) {
  // bp actually points to a Derived
}
In the first if, we compare the dynamic types of the objects to which bp and dp
point. If both point to the same type, then the condition succeeds. Similarly, the
second if succeeds if bp currently points to a Derived object.
Note that the operands to the typeid are objects¡ªwe used *bp, not bp:
Click here to view code image
// test always fails: the type of bp is pointer to Base
if (typeid(bp) == typeid(Derived)) {
  // code never executed
}
This condition compares the type Base* to type Derived. Although the pointer
points at an object of class type that has virtual functions, the pointer itself is not a
class-type object. The type Base* can be, and is, evaluated at compile time. That
type is unequal to Derived, so the condition will always fail regardless of the type of
the object to which bp points.
  Warning
The typeid of a pointer (as opposed to the object to which the pointer
points) returns the static, compile-time type of the pointer.
Whether typeid requires a run-time check determines whether the expression is
evaluated. The compiler evaluates the expression only if the type has virtual functions.
If the type has no virtuals, then typeid returns the static type of the expression; the
compiler knows the static type without evaluating the expression.
If the dynamic type of the expression might differ from the static type, then the
expression must be evaluated (at run time) to determine the resulting type. The
distinction matters when we evaluate typeid(*p). If p is a pointer to a type that
does not have virtual functions, then p does not need to be a valid pointer. Otherwise,
*p is evaluated at run time, in which case p must be a valid pointer. If p is a null
pointer, then typeid(*p) throws a bad_typeid exception.
19.2.3. Using RTTIC++ Primer, Fifth Edition
As an example of when RTTI might be useful, consider a class hierarchy for which
we¡¯d like to implement the equality operator (¡ì 14.3.1, p. 561). Two objects are equal
if they have the same type and same value for a given set of their data members.
Each derived type may add its own data, which we will want to include when we test
for equality.
Exercises Section 19.2.2
Exercise 19.6: Write an expression to dynamically cast a pointer to a
Query_base to a pointer to an AndQuery (¡ì 15.9.1, p. 636). Test the cast
by using objects of AndQuery and of another query type. Print a statement
indicating whether the cast works and be sure that the output matches your
expectations.
Exercise 19.7: Write the same cast, but cast a Query_base object to a
reference to AndQuery. Repeat the test to ensure that your cast works
correctly.
Exercise 19.8: Write a typeid expression to see whether two
Query_base pointers point to the same type. Now check whether that type
is an AndQuery.
We might think we could solve this problem by defining a set of virtual functions
that would perform the equality test at each level in the hierarchy. Given those
virtuals, we would define a single equality operator that operates on references to the
base type. That operator could delegate its work to a virtual equal operation that
would do the real work.
Unfortunately, this strategy doesn¡¯t quite work. Virtual functions must have the
same parameter type(s) in both the base and derived classes (¡ì 15.3, p. 605). If we
wanted to define a virtual equal function, that function must have a parameter that
is a reference to the base class. If the parameter is a reference to base, the equal
function could use only members from the base class. equal would have no way to
compare members that are in the derived class but not in the base.
We can write our equality operation by realizing that the equality operator ought to
return false if we attempt to compare objects of differing type. For example, if we
try to compare a object of the base-class type with an object of a derived type, the
== operator should return false.
Given this observation, we can now see that we can use RTTI to solve our problem.
We¡¯ll define an equality operator whose parameters are references to the base-class
type. The equality operator will use typeid to verify that the operands have the
same type. If the operands differ, the == will return false. Otherwise, it will call a
virtual equal function. Each class will define equal to compare the data elements of
its own type. These operators will take a Base& parameter but will cast the operand
to its own type before doing the comparison.C++ Primer, Fifth Edition
The Class Hierarchy
To make the concept a bit more concrete, we¡¯ll define the following classes:
Click here to view code image
class Base { friend bool operator==(const Base&, const Base&);
public:
  // interface members for Base
protected:
 virtual bool equal(const Base&) const;
  // data and other implementation members of Base
};
class Derived: public Base {
public:
  // other interface members for Derived
protected:
 bool equal(const Base&) const;
  // data and other implementation members of Derived
};
A Type-Sensitive Equality Operator
Next let¡¯s look at how we might define the overall equality operatorClick here to view code image
bool operator==(const Base &lhs, const Base &rhs)
{
  // returns false if typeids are different; otherwise makes a virtual call to equal
  return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}
This operator returns false if the operands are different types. If they are the same
type, then it delegates the real work of comparing the operands to the (virtual) equal
function. If the operands are Base objects, then Base::equal will be called. If they
are Derived objects, Derived::equal is called.
The Virtual equal Functions
Each class in the hierarchy must define its own version of equal. All of the functions
in the derived classes will start the same way: They¡¯ll cast their argument to the type
of the class itself:
Click here to view code image
bool Derived::equal(const Base &rhs) constC++ Primer, Fifth Edition
{
  // we know the types are equal, so the cast won't throw
  auto r = dynamic_cast<const Derived&>(rhs);
  // do the work to compare two Derived objects and return the result
}
The cast should always succeed¡ªafter all, the function is called from the equality
operator only after testing that the two operands are the same type. However, the
cast is necessary so that the function can access the derived members of the righthand operand.
The Base-Class equal Function
This operation is a bit simpler than the others:
Click here to view code image
bool Base::equal(const Base &rhs) const
{
  // do whatever is required to compare to Base objects
}
There is no need to cast the parameter before using it. Both *this and the
parameter are Base objects, so all the operations available for this object are also
defined for the parameter type.
19.2.4. The type_info Class
The exact definition of the type_info class varies by compiler. However, the standard
guarantees that the class will be defined in the typeinfo header and that the class
will provide at least the operations listed in Table 19.1.
Table 19.1. Operations on type_info
The class also provides a public virtual destructor, because it is intended to serve
as a base class. When a compiler wants to provide additional type information, it
normally does so in a class derived from type_info.C++ Primer, Fifth Edition
There is no type_info default constructor, and the copy and move constructors
and the assignment operators are all defined as deleted (¡ì 13.1.6, p. 507). Therefore,
we cannot define, copy, or assign objects of type type_info. The only way to create
a type_info object is through the typeid operator.
The name member function returns a C-style character string for the name of the
type represented by the type_info object. The value used for a given type depends
on the compiler and in particular is not required to match the type names as used in a
program. The only guarantee we have about the return from name is that it returns a
unique string for each type. For example:
Click here to view code image
int arr[10];
Derived d;
Base *p = &d;
cout << typeid(42).name() << ", "
 << typeid(arr).name() << ", " << typeid(Sales_data).name() << ", " << typeid(std::string).name() << ", " << typeid(p).name() << ", " << typeid(*p).name() << endl;
This program, when executed on our machine, generates the following output:
Click here to view code image
i, A10_i, 10Sales_data, Ss, P4Base, 7Derived
  Note
The type_info class varies by compiler. Some compilers provide additional
member functions that provide additional information about types used in a
program. You should consult the reference manual for your compiler to
understand the exact type_info support provided.
Exercises Section 19.2.4
Exercise 19.9: Write a program similar to the last one in this section to
print the names your compiler uses for common type names. If your compiler
gives output similar to ours, write a function that will translate those strings
to more human-friendly form.
Exercise 19.10: Given the following class hierarchy in which each class
defines a public default constructor and virtual destructor, which type name
do the following statements print?
Click here to view code imageC++ Primer, Fifth Edition
class A { /* . . . */ };
class B : public A { /* . . . */ };
class C : public B { /* . . . */ };
(a) A *pa = new C;
 cout << typeid(pa).name() << endl;
(b) C cobj;
 A& ra = cobj; cout << typeid(&ra).name() << endl;
(c) B *px = new B;
 A& ra = *px; cout << typeid(ra).name() << endl;
19.3. Enumerations
Enumerations let us group together sets of integral constants. Like classes, each
enumeration defines a new type. Enumerations are literal types (¡ì 7.5.6, p. 299).
C++ has two kinds of enumerations: scoped and unscoped. The new standard
introduced scoped enumerations. We define a scoped enumeration using the
keywords enum class (or, equivalently, enum struct), followed by the
enumeration name and a comma-separated list of enumerators enclosed in curly
braces. A semicolon follows the close curly:
Click here to view code image
enum class open_modes {input, output, append};
Here we defined an enumeration type named open_modes that has three
enumerators: input, output, and append.
We define an unscoped enumeration by omitting the class (or struct)
keyword. The enumeration name is optional in an unscoped enum:
Click here to view code image
enum color {red, yellow, green}; // unscoped enumeration
// unnamed, unscoped enum
enum {floatPrec = 6, doublePrec = 10, double_doublePrec =
10};
If the enum is unnamed, we may define objects of that type only as part of the enum
definition. As with a class definition, we can provide a comma-separated list of
declarators between the close curly and the semicolon that ends the enum definition
(¡ì 2.6.1, p. 73).
EnumeratorsC++ Primer, Fifth Edition
The names of the enumerators in a scoped enumeration follow normal scoping rules
and are inaccessible outside the scope of the enumeration. The enumerator names in
an unscoped enumeration are placed into the same scope as the enumeration itself:
Click here to view code image
enum color {red, yellow, green}; // unscoped enumeration
enum stoplight {red, yellow, green}; // error: redefines enumerators
enum class peppers {red, yellow, green}; // ok: enumerators are
hidden
color eyes = green; // ok: enumerators are in scope for an unscoped
enumeration
peppers p = green; // error: enumerators from peppers are not in scope
  // color::green is in scope but has the wrong type
color hair = color::red; // ok: we can explicitly access the enumerators
peppers p2 = peppers::red; // ok: using red from pepperBy default, enumerator values start at 0 and each enumerator has a value 1 greater
than the preceding one. However, we can also supply initializers for one or more
enumerators:
Click here to view code image
enum class intTypes { charTyp = 8, shortTyp = 16, intTyp = 16 longTyp = 32, long_longTyp = 64
};
As we see with the enumerators for intTyp and shortTyp, an enumerator value
need not be unique. When we omit an initializer, the enumerator has a value 1
greater than the preceding enumerator.
Enumerators are const and, if initialized, their initializers must be constant
expressions (¡ì 2.4.4, p. 65). Consequently, each enumerator is itself a constant
expression. Because the enumerators are constant expressions, we can use them
where a constant expression is required. For example, we can define constexpr
variables of enumeration type:
Click here to view code image
constexpr intTypes charbits = intTypes::charTypSimilarly, we can use an enum as the expression in a switch statement and use the
value of its enumerators as the case labels (¡ì 5.3.2, p. 178). For the same reason,
we can also use an enumeration type as a nontype template parameter (¡ì 16.1.1, p.
654). and can initialize class static data members of enumeration type inside the
class definition (¡ì 7.6, p. 302).C++ Primer, Fifth Edition
Like Classes, Enumerations Define New Types
So long as the enum is named, we can define and initialize objects of that type. An
enum object may be initialized or assigned only by one of its enumerators or by
another object of the same enum type:
Click here to view code image
open_modes om = 2; // error: 2 is not of type open_modes
om = open_modes::input; // ok: input is an enumerator of open_modes
Objects or enumerators of an unscoped enumeration type are automatically
converted to an integral type. As a result, they can be used where an integral value is
required:
Click here to view code image
int i = color::red; // ok: unscoped enumerator implicitly converted to int
int j = peppers::red; // error: scoped enumerations are not implicitly
converted
Specifying the Size of an enum
Although each enum defines a unique type, it is represented by one of the built-in
integral types. Under the new standard, we may specify that type by following the
enum name with a colon and the name of the type we want to use:
Click here to view code image
enum intValues : unsigned long long { charTyp = 255, shortTyp = 65535, intTyp = 65535, longTyp = 4294967295UL, long_longTyp = 18446744073709551615ULL
};
If we do not specify the underlying type, then by default scoped enums have int as
the underlying type. There is no default for unscoped enums; all we know is that the
underlying type is large enough to hold the enumerator values. When the underlying
type is specified (including implicitly specified for a scoped enum), it is an error for an
enumerator to have a value that is too large to fit in that type.
Being able to specify the underlying type of an enum lets us control the type used
across different implementations. We can be confident that our program compiled
under one implementation will generate the same code when we compile it on
another.
Forward Declarations for EnumerationsC++ Primer, Fifth Edition
Under the new standard, we can forward declare an enum. An enum forward
declaration must specify (implicitly or explicitly) the underlying size of the enum:
Click here to view code image
// forward declaration of unscoped enum named intValues
enum intValues : unsigned long long; // unscoped, must specify a type
enum class open_modes; // scoped enums can use int by default
Because there is no default size for an unscoped enum, every declaration must include
the size of that enum. We can declare a scoped enum without specifying a size, in
which case the size is implicitly defined as int.
As with any declaration, all the declarations and the definition of a given enum must
match one another. In the case of enums, this requirement means that the size of the
enum must be the same across all declarations and the enum definition. Moreover, we
cannot declare a name as an unscoped enum in one context and redeclare it as a
scoped enum later:
Click here to view code image
// error: declarations and definition must agree whether the enum is scoped or unscoped
enum class intValuesenum intValues; // error: intValues previously declared as scoped enum
enum intValues : long; // error: intValues previously declared as int
Parameter Matching and Enumerations
Because an object of enum type may be initialized only by another object of that
enum type or by one of its enumerators (¡ì 19.3, p. 833), an integral value that
happens to have the same value as an enumerator cannot be used to call a function
expecting an enum argument:
Click here to view code image
// unscoped enumeration; the underlying type is machine dependent
enum Tokens {INLINE = 128, VIRTUAL = 129};
void ff(Tokens);
void ff(int);
int main() {
 Tokens curTok = INLINE;
  ff(128); // exactly matches ff(int)
  ff(INLINE); // exactly matches ff(Tokens)
  ff(curTok); // exactly matches ff(Tokens)
  return 0;
}
Although we cannot pass an integral value to an enum parameter, we can pass anC++ Primer, Fifth Edition
object or enumerator of an unscoped enumeration to a parameter of integral type.
When we do so, the enum value promotes to int or to a larger integral type. The
actual promotion type depends on the underlying type of the enumeration:
Click here to view code image
void newf(unsigned char);
void newf(int);
unsigned char uc = VIRTUAL;
newf(VIRTUAL); // calls newf(int)
newf(uc); // calls newf(unsigned char)
The enum Tokens has only two enumerators, the larger of which has the value 129.
That value can be represented by the type unsigned char, and many compilers will
use unsigned char as the underlying type for Tokens. Regardless of its underlying
type, objects and the enumerators of Tokens are promoted to int. Enumerators and
values of an enum type are not promoted to unsigned char, even if the values of
the enumerators would fit.
19.4. Pointer to Class Member
A pointer to member is a pointer that can point to a nonstatic member of a
class. Normally a pointer points to an object, but a pointer to member identifies a
member of a class, not an object of that class. static class members are not part of
any object, so no special syntax is needed to point to a static member. Pointers to
static members are ordinary pointers.
The type of a pointer to member embodies both the type of a class and the type of
a member of that class. We initialize such pointers to point to a specific member of a
class without identifying an object to which that member belongs. When we use a
pointer to member, we supply the object whose member we wish to use.
To explain pointers to members, we¡¯ll use a version of the Screen class from ¡ì
7.3.1 (p. 271):
Click here to view code image
class public:
 typedef std::string::size_type pos; char get_cursor() const { return contents[cursor]; } char get() const; char get(pos ht, pos wd) const;
private:
 std::string contents; pos cursor; pos height, width;
};
19.4.1. Pointers to Data MembersC++ Primer, Fifth Edition
As with any pointer, we declare a pointer to member using a * to indicate that the
name we¡¯re declaring is a pointer. Unlike ordinary pointers, a pointer to member also
incorporates the class that contains the member. Hence, we must precede the * with
classname:: to indicate that the pointer we are defining can point to a member of
classname. For example:
Click here to view code image
// pdata can point to a string member of a const (or non const) Screen object
const string Screen::*pdata;
declares that pdata is a ¡°pointer to a member of class Screen that has type const
string.¡± The data members in a const object are themselves const. By making
our pointer a pointer to const string member, we say that we can use pdata to
point to a member of any Screen object, const or not. In exchange we can use
pdata to read, but not write to, the member to which it points.
When we initialize (or assign to) a pointer to member, we say to which member it
points. For example, we can make pdata point to the contents member of an
unspecified Screen object as follows:
pdata = &Screen::contents;
Here, we apply the address-of operator not to an object in memory but to a member
of the class Screen.
Of course, under the new standard, the easiest way to declare a pointer to member
is to use auto or decltype:
auto pdata = &Screen::contents;
Using a Pointer to Data Member
It is essential to understand that when we initialize or assign a pointer to member,
that pointer does not yet point to any data. It identifies a specific member but not the
object that contains that member. We supply the object when we dereference the
pointer to member.
Analogous to the member access operators, . and ->, there are two pointer-tomember access operators, .* and ->*, that let us supply an object and dereference
the pointer to fetch a member of that object:
Click here to view code image
Screen myScreen, *pScreen = &myScreen;
// .* dereferences pdata to fetch the contents member from the object myScreen
auto s = myScreen.*pdata;
// ->* dereferences pdata to fetch contents from the object to which pScreen points
s = pScreen->*pdata;C++ Primer, Fifth Edition
Conceptually, these operators perform two actions: They dereference the pointer to
member to get the member that we want; then, like the member access operators,
they fetch that member from an object (.*) or through a pointer (->*).
A Function Returning a Pointer to Data Member
Normal access controls apply to pointers to members. For example, the contents
member of Screen is private. As a result, the use of pdata above must have been
inside a member or friend of class Screen or it would be an error.
Because data members are typically private, we normally can¡¯t get a pointer to
data member directly. Instead, if a class like Screen wanted to allow access to its
contents member, it would define a function to return a pointer to that member:
Click here to view code image
class Screen {
public:
  // data is a static member that returns a pointer to member
  static const std::string Screen::*data() { return &Screen::contents; }
  // other members as before
};
Here we¡¯ve added a static member to class Screen that returns a pointer to the
contents member of a Screen. The return type of this function is the same type as
our original pdata pointer. Reading the return type from right to left, we see that
data returns a pointer to a member of class Screen that is a string that is const.
The body of the function applies the address-of operator to the contents member,
so the function returns a pointer to the contents member of Screen.
When we call data, we get a pointer to member:
Click here to view code image
// data() returns a pointer to the contents member of class Screen
const string Screen::*pdata = Screen::data();
As before, pdata points to a member of class Screen but not to actual data. To use
pdata, we must bind it to an object of type Screen
Click here to view code image
// fetch the contents of the object named myScreen
auto s = myScreen.*pdata;
Exercises Section 19.4.1
Exercise 19.11: What is the difference between an ordinary data pointer
and a pointer to a data member?C++ Primer, Fifth Edition
Exercise 19.12: Define a pointer to member that can point to the cursor
member of class Screen. Fetch the value of Screen::cursor through that
pointer.
Exercise 19.13: Define the type that can represent a pointer to the bookNo
member of the Sales_data class.
19.4.2. Pointers to Member Functions
We can also define a pointer that can point to a member function of a class. As with
pointers to data members, the easiest way to form a pointer to member function is to
use auto to deduce the type for us:
Click here to view code image
// pmf is a pointer that can point to a Screen member function that is const
// that returns a char and takes no arguments
auto pmf = &Screen::get_cursor;
Like a pointer to data member, a pointer to a function member is declared using
classname::*. Like any other function pointer (¡ì 6.7, p. 247), a pointer to member
function specifies the return type and parameter list of the type of function to which
this pointer can point. If the member function is a const member (¡ì 7.1.2, p. 258) or
a reference member (¡ì 13.6.3, p. 546), we must include the const or reference
qualifier as well.
As with normal function pointers, if the member is overloaded, we must distinguish
which function we want by declaring the type explicitly (¡ì 6.7, p. 248). For example,
we can declare a pointer to the two-parameter version of get as
Click here to view code image
char (Screen::*pmf2)(Screen::pos, Screen::pos) const;
pmf2 = &Screen::get;
The parentheses around Screen::* in this declaration are essential due to
precedence. Without the parentheses, the compiler treats the following as an (invalid)
function declaration:
Click here to view code image
// error: nonmember function p cannot have a const qualifier
char Screen::*p(Screen::pos, Screen::pos) const;
This declaration tries to define an ordinary function named p that returns a pointer to
a member of class Screen that has type char. Because it declares an ordinary
function, the declaration can¡¯t be followed by a const qualifier.
Unlike ordinary function pointers, there is no automatic conversion between aC++ Primer, Fifth Edition
member function and a pointer to that member:
Click here to view code image
// pmf points to a Screen member that takes no arguments and returns char
pmf = &Screen::get; // must explicitly use the address-of operator
pmf = Screen::get; // error: no conversion to pointer for member functions
Using a Pointer to Member Function
As when we use a pointer to a data member, we use the .* or ->* operators to call
a member function through a pointer to member:
Click here to view code image
Screen myScreen,*pScreen = &myScreen;
// call the function to which pmf points on the object to which pScreen points
char c1 = (pScreen->*pmf)();
// passes the arguments 0, 0 to the two-parameter version of get on the object
myScreen
char c2 = (myScreen.*pmf2)(0, 0);
The calls (myScreen->*pmf)() and (pScreen.*pmf2)(0,0) require the
parentheses because the precedence of the call operator is higher than the
precedence of the pointer to member operators.
Without the parenthesesmyScreen.*pmf()
would be interpreted to mean
myScreen.*(pmf())
This code says to call the function named pmf and use its return value as the operand
of the pointer-to-member operator (.*). However, pmf is not a function, so this code
is in error.
  Note
Because of the relative precedence of the call operator, declarations of
pointers to member functions and calls through such pointers must use
parentheses: (C::*p)(parms) and (obj.*p)(args).
Using Type Aliases for Member Pointers
Type aliases or typedefs (¡ì 2.5.1, p. 67) make pointers to members considerablyC++ Primer, Fifth Edition
easier to read. For example, the following type alias defines Action as an alternative
name for the type of the two-parameter version of get:
Click here to view code image
// Action is a type that can point to a member function of Screen
// that returns a char and takes two pos arguments
using Action =
char (Screen::*)(Screen::pos, Screen::pos) const;
Action is another name for the type ¡°pointer to a const member function of class
Screen taking two parameters of type pos and returning char.¡± Using this alias, we
can simplify the definition of a pointer to get as follows:
Click here to view code image
Action get = &Screen::get; // get points to the get member of Screen
As with any other function pointer, we can use a pointer-to-member function type
as the return type or as a parameter type in a function. Like any other parameter, a
pointer-to-member parameter can have a default argument:
Click here to view code image
// action takes a reference to a Screen and a pointer to a Screen member function
Screen& action(Screen&, Action = &Screen::get);
action is a function taking two parameters, which are a reference to a Screen
object and a pointer to a member function of class Screen that takes two pos
parameters and returns a char. We can call action by passing it either a pointer or
the address of an appropriate member function in Screen:
Click here to view code image
Screen myScreen;
// equivalent calls:
action(myScreen); // uses the default argument
action(myScreen, get); // uses the variable get that we previously defined
action(myScreen, &Screen::get); // passes the address explicitly
  Note
Type aliases make code that uses pointers to members much easier to read
and write.
Pointer-to-Member Function Tables
One common use for function pointers and for pointers to member functions is toC++ Primer, Fifth Edition
store them in a function table (¡ì 14.8.3, p. 577). For a class that has several
members of the same type, such a table can be used to select one from the set of
these members. Let¡¯s assume that our Screen class is extended to contain several
member functions, each of which moves the cursor in a particular direction:
Click here to view code image
class Screen {
public:
  // other interface and implementation members as before
  Screen& home(); // cursor movement functions
  Screen& forward(); Screen& back(); Screen& up(); Screen& down();
};
Each of these new functions takes no parameters and returns a reference to the
Screen on which it was invoked.
We might want to define a move function that can call any one of these functions
and perform the indicated action. To support this new function, we¡¯ll add a static
member to Screen that will be an array of pointers to the cursor movement
functions:
Click here to view code image
class Screen {
public:
  // other interface and implementation members as before
  // Action is a pointer that can be assigned any of the cursor movement members
  using Action = Screen& (Screen::*)();
  // specify which direction to move; enum see ¡ì 19.3 (p. 832)
  enum Directions { HOME, FORWARD, BACK, UP, DOWN }; Screen& move(Directions);
private:
  static Action Menu[]; // function table
};
The array named Menu will hold pointers to each of the cursor movement functions.
Those functions will be stored at the offsets corresponding to the enumerators in
Directions. The move function takes an enumerator and calls the appropriate
function:
Click here to view code image
Screen& Screen::move(Directions cm)
{
  // run the element indexed by cm on this object
  return (this->*Menu[cm])(); // Menu[cm] points to a member
functionC++ Primer, Fifth Edition
}
The call inside move is evaluated as follows: The Menu element indexed by cm is
fetched. That element is a pointer to a member function of the Screen class. We call
the member function to which that element points on behalf of the object to which
this points.
When we call move, we pass it an enumerator that indicates which direction to
move the cursor:
Click here to view code image
Screen myScreen;
myScreen.move(Screen::HOME); // invokes myScreen.home
myScreen.move(Screen::DOWN); // invokes myScreen.down
What¡¯s left is to define and initialize the table itself:
Click here to view code image
Screen::Action Screen::Menu[] = { &Screen::home, &Screen::forward,
&Screen::back,
&Screen::up,
&Screen::down, };
Exercises Section 19.4.2
Exercise 19.14: Is the following code legal? If so, what does it do? If not,
why?
Click here to view code image
auto pmf = &Screen::get_cursor;
pmf = &Screen::get;
Exercise 19.15: What is the difference between an ordinary function pointer
and a pointer to a member function?
Exercise 19.16: Write a type alias that is a synonym for a pointer that can
point to the avg_price member of Sales_data.
Exercise 19.17: Define a type alias for each distinct Screen member
function type.
19.4.3. Using Member Functions as Callable Objects
As we¡¯ve seen, to make a call through a pointer to member function, we must use the
.* or ->* operators to bind the pointer to a specific object. As a result, unlike
ordinary function pointers, a pointer to member is not a callable object; these pointersC++ Primer, Fifth Edition
do not support the function-call operator (¡ì 10.3.2, p. 388).
Because a pointer to member is not a callable object, we cannot directly pass a
pointer to a member function to an algorithm. As an example, if we wanted to find the
first empty string in a vector of strings, the obvious call won¡¯t work:
Click here to view code image
auto fp = &string::empty; // fp points to the string empty function
// error: must use .* or ->* to call a pointer to member
find_if(svec.begin(), svec.end(), fp);
The find_if algorithm expects a callable object, but we¡¯ve supplied fp, which is a
pointer to a member function. This call won¡¯t compile, because the code inside
find_if executes a statement something like
Click here to view code image
// check whether the given predicate applied to the current element yields true
if (fp(*it)) // error: must use ->* to call through a pointer to member
which attempts to call the object it was passed.
Using function to Generate a Callable
One way to obtain a callable from a pointer to member function is by using the library
function template (¡ì 14.8.3, p. 577):
Click here to view code image
function<bool (const string&)> fcn = &string::empty;
find_if(svec.begin(), svec.end(), fcn);
Here we tell function that empty is a function that can be called with a string
and returns a bool. Ordinarily, the object on which a member function executes is
passed to the implicit this parameter. When we want to use function to generate
a callable for a member function, we have to ¡°translate¡± the code to make that implicit
parameter explicit.
When a function object holds a pointer to a member function, the function
class knows that it must use the appropriate pointer-to-member operator to make the
call. That is, we can imagine that find_if will have code something like
Click here to view code image
// assuming it is the iterator inside find_if, so *it is an object in the given range
if (fcn(*it)) // assuming fcn is the name of the callable inside find_if
which function will execute using the proper pointer-to-member operator. In
essence, the function class will transform this call into something like
Click here to view code imageC++ Primer, Fifth Edition
// assuming it is the iterator inside find_if, so *it is an object in the given range
if (((*it).*p)()) // assuming p is the pointer to member function inside fcn
When we define a function object, we must specify the function type that is the
signature of the callable objects that object can represent. When the callable is a
member function, the signature¡¯s first parameter must represent the (normally implicit)
object on which the member will be run. The signature we give to function must
specify whether the object will be passed as a pointer or a reference.
When we defined fcn, we knew that we wanted to call find_if on a sequence of
string objects. Hence, we asked function to generate a callable that took string
objects. Had our vector held pointers to string, we would have told function to
expect a pointer:
Click here to view code image
vector<string*> pvec;
function<bool (const string*)> fp = &string::empty;
// fp takes a pointer to string and uses the ->* to call emptfind_if(pvec.begin(), pvec.end(), fp)Using mem_fn to Generate a Callable
To use function, we must supply the call signature of the member we want to call.
We can, instead, let the compiler deduce the member¡¯s type by using another library
facility, mem_fn, which, like function, is defined in the functional header. Like
function, mem_fn generates a callable object from a pointer to member. Unlike
function, mem_fn will deduce the type of the callable from the type of the pointer
to member:
Click here to view code image
find_if(svec.begin(), svec.end(), mem_fn(&string::empty));
Here we used mem_fn(&string::empty) to generate a callable object that takes a
string argument and returns a bool.
The callable generated by mem_fn can be called on either an object or a pointer:
Click here to view code image
auto f = mem_fn(&string::empty); // f takes a string or a string*
f(*svec.begin()); // ok: passes a string object; f uses .* to call empty
f(&svec[0]); // ok: passes a pointer to string; f uses .-> to call empty
Effectively, we can think of mem_fn as if it generates a callable with an overloaded
function call operator¡ªone that takes a string* and the other a string&.C++ Primer, Fifth Edition
Using bind to Generate a Callable
For completeness, we can also use bind (¡ì 10.3.4, p. 397) to generate a callable
from a member function:
Click here to view code image
// bind each string in the range to the implicit first argument to empty
auto it = find_if(svec.begin(), svec.end(),
 bind(&string::empty, _1));
As with function, when we use bind, we must make explicit the member function¡¯s
normally implicit parameter that represents the object on which the member function
will operate. Like mem_fn, the first argument to the callable generated by bind can
be either a pointer or a reference to a string:
Click here to view code image
auto f = bind(&string::empty, _1);
f(*svec.begin()); // ok: argument is a string f will use .* to call empty
f(&svec[0]); // ok: argument is a pointer to string f will use .-> to call empty
19.5. Nested Classes
A class can be defined within another class. Such a class is a nested class, also
referred to as a nested type. Nested classes are most often used to define
implementation classes, such as the QueryResult class we used in our text query
example (¡ì 12.3, p. 484).
Exercises Section 19.4.3
Exercise 19.18: Write a function that uses count_if to count how many
empty strings there are in a given vector.
Exercise 19.19: Write a function that takes a vector<Sales_data> and
finds the first element whose average price is greater than some given
amount.
Nested classes are independent classes and are largely unrelated to their enclosing
class. In particular, objects of the enclosing and nested classes are independent from
each other. An object of the nested type does not have members defined by the
enclosing class. Similarly, an object of the enclosing class does not have members
defined by the nested class.
The name of a nested class is visible within its enclosing class scope but not outside
the class. Like any other nested name, the name of a nested class will not collide withC++ Primer, Fifth Edition
the use of that name in another scope.
A nested class can have the same kinds of members as a nonnested class. Just like
any other class, a nested class controls access to its own members using access
specifiers. The enclosing class has no special access to the members of a nested class,
and the nested class has no special access to members of its enclosing class.
A nested class defines a type member in its enclosing class. As with any other
member, the enclosing class determines access to this type. A nested class defined in
the public part of the enclosing class defines a type that may be used anywhere. A
nested class defined in the protected section defines a type that is accessible only
by the enclosing class, its friends, and its derived classes. A private nested class
defines a type that is accessible only to the members and friends of the enclosing
class.
Declaring a Nested Class
The TextQuery class from ¡ì 12.3.2 (p. 487) defined a companion class named
QueryResult. The QueryResult class is tightly coupled to our TextQuery class. It
would make little sense to use QueryResult for any other purpose than to represent
the results of a query operation on a TextQuery object. To reflect this tight
coupling, we¡¯ll make QueryResult a member of TextQuery.
Click here to view code image
class TextQuery {
public:
  class QueryResult; // nested class to be defined later
  // other members as in ¡ì 12.3.2 (p. 487)
};
We need to make only one change to our original TextQuery class¡ªwe declare our
intention to define QueryResult as a nested class. Because QueryResult is a type
member (¡ì 7.4.1, p. 284), we must declare QueryResult before we use it. In
particular, we must declare QueryResult before we use it as the return type for the
query member. The remaining members of our original class are unchanged.
Defining a Nested Class outside of the Enclosing Class
Inside TextQuery we declared QueryResult but did not define it. As with member
functions, nested classes must be declared inside the class but can be defined either
inside or outside the class.
When we define a nested class outside its enclosing class, we must qualify the name
of the nested class by the name of its enclosing class:
Click here to view code imageC++ Primer, Fifth Edition
// we're defining the QueryResult class that is a member of class TextQuery
class TextQuery::QueryResult {
  // in class scope, we don't have to qualify the name of the QueryResult
parameters
  friend std::ostream& print(std::ostream&, const QueryResult&);
public:
  // no need to define QueryResult::line_no; a nested class can use a member
  // of its enclosing class without needing to qualify the member's name
  QueryResult(std::string, std::shared_ptr<std::set<line_no>>,
std::shared_ptr<std::vector<std::string>>);
  // other members as in ¡ì 12.3.2 (p. 487)
};
The only change we made compared to our original class is that we no longer define a
line_no member in QueryResult. The members of QueryResult can access that
name directly from TextQuery, so there is no need to define it again.
  Warning
Until the actual definition of a nested class that is defined outside the class
body is seen, that class is an incomplete type (¡ì 7.3.3, p. 278).
Defining the Members of a Nested Class
In this version, we did not define the QueryResult constructor inside the class body.
To define the constructor, we must indicate that QueryResult is nested within the
scope of TextQuery. We do so by qualifying the nested class name with the name of
its enclosing class:
Click here to view code imag// defining the member named QueryResult for the class named QueryResult
// that is nested inside the class TextQuery
TextQuery::QueryResult::QueryResult(string s,
 shared_ptr<set<line_no>> p,
shared_ptr<vector<string>> f): sought(s), lines(p), file(f) { }
Reading the name of the function from right to left, we see that we are defining the
constructor for class QueryResult, which is nested in the scope of class
TextQuery. The code itself just stores the given arguments in the data members and
has no further work to do.
Nested-Class static Member DefinitionsC++ Primer, Fifth Edition
If QueryResult had declared a static member, its definition would appear outside
the scope of the TextQuery. For example, assuming QueryResult had a static
member, its definition would look something like
Click here to view code image
// defines an int static member of QueryResult
// which is a class nested inside TextQuery
int TextQuery::QueryResult::static_mem = 1024;
Name Lookup in Nested Class Scope
Normal rules apply for name lookup (¡ì 7.4.1, p. 283) inside a nested class. Of course,
because a nested class is a nested scope, the nested class has additional enclosing
class scopes to search. This nesting of scopes explains why we didn¡¯t define line_no
inside the nested version of QueryResult. Our original QueryResult class defined
this member so that its own members could avoid having to write
TextQuery::line_no. Having nested the definition of our results class inside
TextQuery, we no longer need this typedef. The nested QueryResult class can
access line_no without specifying that line_no is defined in TextQuery.
As we¡¯ve seen, a nested class is a type member of its enclosing class. Members of
the enclosing class can use the name of a nested class the same way it can use any
other type member. Because QueryResult is nested inside TextQuery, the query
member of TextQuery can refer to the name QueryResult directly:
Click here to view code image
// return type must indicate that QueryResult is now a nested class
TextQuery::QueryResult
TextQuery::query(const string &sought) const
{
  // we'll return a pointer to this set if we don't find sought
  static shared_ptr<set<line_no>> nodata(new set<line_no>);
  // use find and not a subscript to avoid adding words to wm!
  auto loc = wm.find(sought); if (loc == wm.end())
  return QueryResult(sought, nodata, file); // not found
  else return QueryResult(sought, loc->second, file);
}
As usual, the return type is not yet in the scope of the class (¡ì 7.4, p. 282), so we
start by noting that our function returns a TextQuery::QueryResult value.
However, inside the body of the function, we can refer to QueryResult directly, as
we do in the return statements.
The Nested and Enclosing Classes Are IndependentC++ Primer, Fifth Edition
Although a nested class is defined in the scope of its enclosing class, it is important to
understand that there is no connection between the objects of an enclosing class and
objects of its nested classe(s). A nested-type object contains only the members
defined inside the nested type. Similarly, an object of the enclosing class has only
those members that are defined by the enclosing class. It does not contain the data
members of any nested classes.
More concretely, the second return statement in TextQuery::query
Click here to view code image
return QueryResult(sought, loc->second, file);
uses data members of the TextQuery object on which query was run to initialize a
QueryResult object. We have to use these members to construct the QueryResult
object we return because a QueryResult object does not contain the members of its
enclosing class.
Exercises Section 19.5
Exercise 19.20: Nest your QueryResult class inside TextQuery and
rerun the programs you wrote to use TextQuery in ¡ì 12.3.2 (p. 490).
19.6. union: A Space-Saving Class
A union is a special kind of class. A union may have multiple data members, but at
any point in time, only one of the members may have a value. When a value is
assigned to one member of the union, all other members become undefined. The
amount of storage allocated for a union is at least as much as is needed to contain
its largest data member. Like any class, a union defines a new type.
Some, but not all, class features apply equally to unions. A union cannot have a
member that is a reference, but it can have members of most other types, including,
under the new standard, class types that have constructors or destructors. A union
can specify protection labels to make members public, private, or protected. By
default, like structs, members of a union are public.
A union may define member functions, including constructors and destructors.
However, a union may not inherit from another class, nor may a union be used as
a base class. As a result, a union may not have virtual functions.
Defining a union
unions offer a convenient way to represent a set of mutually exclusive values of
different types. As an example, we might have a process that handles different kinds
Part IV: Advanced Topics
Contents
Chapter 17 Specialized Library Facilities
Chapter 18 Tools for Large Programs
Chapter 19 Specialized Tools and Techniques
Part IV covers additional features that, although useful in the right context, are not
needed by every C++ programmer. These features divide into two clusters: those that
are useful for large-scale problems and those that are applicable to specialized
problems rather than general ones. Features for specialized problems occur both in the
language, the topic of Chapter 19, and in the library, Chapter 17.
In Chapter 17 we cover four special-purpose library facilities: the bitset class and
three new library facilities: tuples, regular expressions, and random numbers. We¡¯ll
also look at some of the less commonly used parts of the IO library.
Chapter 18 covers exception handling, namespaces, and multiple inheritance. These
features tend to be most useful in the context of large-scale problems.
Even programs simple enough to be written by a single author can benefit fromr, Fifth Edition
exception handling, which is why we introduced the basics of exception handling in
Chapter 5. However, the need to deal with run-time errors tends to be more important
and harder to manage in problems that require large programming teams. In Chapter
18 we review some additional useful exception-handling facilities. We also look in more
detail at how exceptions are handled, and show how we can define and use our own
exception classes. This section will also cover improvements from the new standard
regarding specifying that a particular function will not throw.
Large-scale applications often use code from multiple independent vendors.
Combining independently developed libraries would be difficult (if not impossible) if
vendors had to put the names they define into a single namespace. Independently
developed libraries would almost inevitably use names in common with one another; a
name defined in one library would conflict with the use of that name in another
library. To avoid name collisions, we can define names inside a namespace.
Whenever we use a name from the standard library, we are using a name defined
in the namespace named std. Chapter 18 shows how we can define our own
namespaces.
Chapter 18 closes by looking at an important but infrequently used languagfeature: multiple inheritance. Multiple inheritance is most useful for fairly complicated
inheritance hierarchies.
Chapter 19 covers several specialized tools and techniques that are applicable to
particular kinds of problems. Among the features covered in this chapter are how to
redefine how memory allocation works; C++ support for run-time type identification
(RTTI), which let us determine the actual type of an expression at run time; and how
we can define and use pointers to class members. Pointers to class members differ
from pointers to ordinary data or functions. Ordinary pointers only vary based on the
type of the object or function. Pointers to members must also reflect the class to
which the member belongs. We¡¯ll also look at three additional aggregate types:
unions, nested classes, and local classes. The chapter closes by looking briefly at a
collection of features that are inherently nonportable: the volatile qualifier, bitfields, and linkage directives.
Chapter 17. Specialized Library Facilities
Contents
Section 17.1 The tuple Type
Section 17.2 The bitset Type
Section 17.3 Regular Expressions
Section 17.4 Random Numbers
Section 17.5 The IO Library Revisitedr, Fifth Edition
Chapter Summary
Defined Terms
The latest standard greatly increased the size and scope of the library. Indeed, the
portion of the standard devoted to the library more than doubled between the first
release in 1998 and the 2011 standard. As a result, covering every C++ library class is
well beyond the scope of this Primer. However, there are four library facilities that,
although more specialized than other library facilities we¡¯ve covered, are general
enough to warrant discussion in an introductory book: tuples, bitsets, randomnumber generation, and regular expressions. In addition, we will also cover some
additional, special-purpose parts of the IO library.
The library constitutes nearly two-thirds of the text of the new standard. Although we
cannot cover every library facility in depth, there remain a few library facilities that are
likely to be of use in many applications: tuples, bitsets, regular expressions, and
random numbers. We¡¯ll also look at some additional IO library capabilities: format
control, unformatted IO, and random access.
17.1. The tuple Type
A tuple is a template that is similar to a pair (¡ì 11.2.3, p. 426). Each pair type
has different types for its members, but every pair always has exactly two members.
A tuple also has members whose types vary from one tuple type to another, but a
tuple can have any number of members. Each distinct tuple type has a fixed
number of members, but the number of members in one tuple type can differ from
the number of members in another.
A tuple is most useful when we want to combine some data into a single object
but do not want to bother to define a data structure to represent those data. Table
17.1 lists the operations that tuples support. The tuple type, along with its
companion types and functions, are defined in the tuple header.
Table 17.1. Operations on tuplesr, Fifth Edition
  Note
A tuple can be thought of as a ¡°quick and dirty¡± data structure.
17.1.1. Defining and Initializing tuples
When we define a tuple, we name the type(s) of each of its members:
Click here to view code image
tuple<size_t, size_t, size_t> threeD; // all three members set to 0
tuple<string, vector<double>, int, list<int>>
 someVal("constants", {3.14, 2.718}, 42, {0,1,2,3,4,5});
When we create a tuple object, we can use the default tuple constructor, which
value initializes (¡ì 3.3.1, p. 98) each member, or we can supply an initializer for each
member as we do in the initialization of someVal. This tuple constructor is
explicit (¡ì 7.5.4, p. 296), so we must use the direct initialization syntax:r, Fifth Edition
Click here to view code image
tuple<size_t, size_t, size_t> threeD = {1,2,3}; // error
tuple<size_t, size_t, size_t> threeD{1,2,3}; // ok
Alternatively, similar to the make_pair function (¡ì 11.2.3, p. 428), the library
defines a make_tuple function that generates a tuple object:
Click here to view code image
// tuple that represents a bookstore transaction: ISBN, count, price per book
auto item = make_tuple("0-999-78345-X", 3, 20.00);
Like make_pair, the make_tuple function uses the types of the supplied initializers
to infer the type of the tuple. In this case, item is a tuple whose type is
tuple<const char*, int, double>.
Accessing the Members of a tuple
A pair always has two members, which makes it possible for the library to give these
members names (i.e., first and second). No such naming convention is possible for
tuple because there is no limit on the number of members a tuple type can have.
As a result, the members are unnamed. Instead, we access the members of a tuple
through a library function template named get. To use get we must specify an explicit
template argument (¡ì 16.2.2, p. 682), which is the position of the member we want
to access. We pass a tuple object to get, which returns a reference to the specified
member:
Click here to view code image
auto book = get<0>(item); // returns the first member of item
auto cnt = get<1>(item); // returns the second member of item
auto price = get<2>(item)/cnt; // returns the last member of item
get<2>(item) *= 0.8; // apply 20% discount
The value inside the brackets must be an integral constant expression (¡ì 2.4.4, p. 65).
As usual, we count from 0, meaning that get<0> is the first member.
If we have a tuple whose precise type details we don¡¯t know, we can use two
auxilliary class templates to find the number and types of the tuple¡¯s members:
Click here to view code image
typedef decltype(item) trans; // trans is the type of item
// returns the number of members in object's of type trans
size_t sz = tuple_size<trans>::value; // returns 3
// cnt has the same type as the second member in item
tuple_element<1, trans>::type cnt = get<1>(item); // cnt is an
intr, Fifth Edition
To use tuple_size or tuple_element, we need to know the type of a tuple
object. As usual, the easiest way to determine an object¡¯s type is to use decltype (¡ì
2.5.3, p. 70). Here, we use decltype to define a type alias for the type of item,
which we use to instantiate both templates.
tuple_size has a public static data member named value that is the
number or members in the specified tuple. The tuple_element template takes an
index as well as a tuple type. tuple_element has a public type member named
type that is the type of the specified member of the specified tuple type. Like get,
tuple_element uses indices starting at 0.
Relational and Equality Operators
The tuple relational and equality operators behave similarly to the corresponding
operations on containers (¡ì 9.2.7, p. 340). These operators execute pairwise on the
members of the left-hand and right-hand tuples. We can compare two tuples only
if they have the same number of members. Moreover, to use the equality or inequality
operators, it must be legal to compare each pair of members using the == operator;
to use the relational operators, it must be legal to use <. For example:
Click here to view code image
tuple<string, string> duo("1", "2");
tuple<size_t, size_t> twoD(1, 2);
bool b = (duo == twoD); // error: can't compare a size_t and a string
tuple<size_t, size_t, size_t> threeD(1, 2, 3);
b = (twoD < threeD); // error: differing number of members
tuple<size_t, size_t> origin(0, 0);
b = (origin < twoD); // ok: b is true
  Note
Because tuple defines the < and == operators, we can pass sequences of
tuples to the algorithms and can use a tuple as key type in an ordered
container.
Exercises Section 17.1.1
Exercise 17.1: Define a tuple that holds three int values and initialize the
members to 10, 20, and 30.
Exercise 17.2: Define a tuple that holds a string, a vector<string>,
and a pair<string, int>.
Exercise 17.3: Rewrite the TextQuery programs from ¡ì 12.3 (p. 484) to
use a tuple instead of the QueryResult class. Explain which design your, Fifth Edition
think is better and why17.1.2. Using a tuple to Return Multiple Values
A common use of tuple is to return multiple values from a function. For example,
our bookstore might be one of several stores in a chain. Each store would have a
transaction file that holds data on each book that the store recently sold. We might
want to look at the sales for a given book in all the stores.
We¡¯ll assume that we have a file of transactions for each store. Each of these perstore transaction files will contain all the transactions for each book grouped together.
We¡¯ll further assume that some other function reads these transaction files, builds a
vector<Sales_data> for each store, and puts those vectors in a vector of
vectors:
Click here to view code image
// each element in files holds the transactions for a particular store
vector<vector<Sales_data>> files;
We¡¯ll write a function that will search files looking for the stores that sold a given
book. For each store that has a matching transaction, we¡¯ll create a tuple to hold the
index of that store and two iterators. The index will be the position of the matching
store in files. The iterators will mark the first and one past the last record for the
given book in that store¡¯s vector<Sales_data>.
A Function That Returns a tuple
We¡¯ll start by writing the function to find a given book. This function¡¯s arguments are
the vector of vectors just described, and a string that represents the book¡¯s
ISBN. Our function will return a vector of tuples that will have an entry for each
store with at least one sale for the given book:
Click here to view code image
// matches has three members: an index of a store and iterators into that store's vector
typedef tuple<vector<Sales_data>::size_type,
 vector<Sales_data>::const_iterator,
vector<Sales_data>::const_iterator> matches;
// files holds the transactions for every store
// findBook returns a vector with an entry for each store that sold the given book
vector<matches>
findBook(const vector<vector<Sales_data>> &files,
 const string &book)
{
  vector<matches> ret; // initially emptyr, Fifth Edition
  // for each store find the range of matching books, if any
  for (auto it = files.cbegin(); it != files.cend(); ++it)
{
  // find the range of Sales_data that have the same ISBN
  auto found = equal_range(it->cbegin(), it->cend(),  book, compareIsbn);
  if (found.first != found.second) // this store had sales
  // remember the index of this store and the matching range
  ret.push_back(make_tuple(it - files.cbegin(),  found.first,
found.second));
 }
  return ret; // empty if no matches found
}
The for loop iterates through the elements in files. Those elements are themselves
vectors. Inside the for we call a library algorithm named equal_range, which
operates like the associative container member of the same name (¡ì 11.3.5, p. 439).
The first two arguments to equal_range are iterators denoting an input sequence (¡ì
10.1, p. 376). The third argument is a value. By default, equal_range uses the <
operator to compare elements. Because Sales_data does not have a < operator, we
pass a pointer to the compareIsbn function (¡ì 11.2.2, p. 425).
The equal_range algorithm returns a pair of iterators that denote a range of
elements. If book is not found, then the iterators will be equal, indicating that the
range is empty. Otherwise, the first member of the returned pair will denote the
first matching transaction and second will be one past the last.
Using a tuple Returned by a Function
Once we have built our vector of stores with matching transactions, we need to
process these transactions. In this program, we¡¯ll report the total sales results for each
store that has a matching sale:
Click here to view code image
void reportResults(istream &in, ostream &os, const vector<vector<Sales_data>> &files)
{
  string s; // book to look for
  while (in >> s) {
  auto trans = findBook(files, s); // stores that sold this book
  if (trans.empty()) {  cout << s << " not found in any stores" << endl;
  continue; // get the next book to look for
  }
  for (const auto &store : trans) // for every store with a
sale
  // get<n> returns the specified member from the tuple in storer, Fifth Edition
  os << "store " << get<0>(store) << " sales: "  << accumulate(get<1>(store), get<2>(store),  Sales_data(s))  << endl;  }
}
The while loop repeatedly reads the istream named in to get the next book to
process. We call findBook to see if s is present, and assign the results to trans.
We use auto to simplify writing the type of trans, which is a vector of tuples.
If trans is empty, there were no sales for s. In this case, we print a message and
return to the while to get the next book to look for.
The for loop binds store to each element in trans. Because we don¡¯t intend to
change the elements in trans, we declare store as a reference to const. We use
get to print the relevant data: get<0> is the index of the corresponding store,
get<1> is the iterator denoting the first transaction, and get<2> is the iterator one
past the last.
Because Sales_data defines the addition operator (¡ì 14.3, p. 560), we can use
the library accumulate algorithm (¡ì 10.2.1, p. 379) to sum the transactions. We
pass a Sales_data object initialized by the Sales_data constructor that takes a
string (¡ì 7.1.4, p. 264) as the starting point for the summation. That constructor
initializes the bookNo member from the given string and the units_sold and
revenue members to zero.
Exercises Section 17.1.2
Exercise 17.4: Write and test your own version of the findBook function.
Exercise 17.5: Rewrite findBook to return a pair that holds an index and
a pair of iterators.
Exercise 17.6: Rewrite findBook so that it does not use tuple or pair.
Exercise 17.7: Explain which version of findBook you prefer and why.
Exercise 17.8: What would happen if we passed Sales_data() as the
third parameter to accumulate in the last code example in this section?
17.2. The bitset Type
In ¡ì 4.8 (p. 152) we covered the built-in operators that treat an integral operand as a
collection of bits. The standard library defines the bitset class to make it easier to use
bit operations and possible to deal with collections of bits that are larger than the
longest integral type. The bitset class is defined in the bitset header.
17.2.1. Defining and Initializing bitsetsr, Fifth Edition
Table 17.2 (overleaf) lists the constructors for bitset. The bitset class is a class
template that, like the array class, has a fixed size (¡ì 9.2.4, p. 336). When we
define a bitset, we say how many bits the bitset will contain:
Click here to view code image
bitset<32> bitvec(1U); // 32 bits; low-order bit is 1, remaining bits are 0
Table 17.2. Ways to Initialize a bitset
The size must be a constant expression (¡ì 2.4.4, p. 65). This statement defines
bitvec as a bitset that holds 32 bits. Just as with the elements of a vector, the
bits in a bitset are not named. Instead, we refer to them positionally. The bits are
numbered starting at 0. Thus, bitvec has bits numbered 0 through 31. The bits
starting at 0 are referred to as the low-order bits, and those ending at 31 are
referred to as high-order bits.
Initializing a bitset from an unsigned Value
When we use an integral value as an initializer for a bitset, that value is converted
to unsigned long long and is treated as a bit pattern. The bits in the bitset are
a copy of that pattern. If the size of the bitset is greater than the number of bits in
an unsigned long long, then the remaining high-order bits are set to zero. If the
size of the bitset is less than that number of bits, then only the low-order bits from
the given value are used; the high-order bits beyond the size of the bitset object
are discarded:r, Fifth Edition
Click here to view code image
// bitvec1 is smaller than the initializer; high-order bits from the initializer are
discarded
bitset<13> bitvec1 (0xbeef); // bits are 1111011101111
// bitvec2 is larger than the initializer; high-order bits in bitvec2 are set to zero
bitset<20> bitvec2(0xbeef); // bits are 00001011111011101111
// on machines with 64-bit long long 0ULL is 64 bits of 0, so ~0ULL is 64 ones
bitset<128> bitvec3(~0ULL); // bits 0 ... 63 are one; 63 ... 127 are zero
Initializing a bitset from a string
We can initialize a bitset from either a string or a pointer to an element in a
character array. In either case, the characters represent the bit pattern directly. As
usual, when we use strings to represent numbers, the characters with the lowest
indices in the string correspond to the high-order bits, and vice versa:
Click here to view code image
bitset<32> bitvec4("1100"); // bits 2 and 3 are 1, all others are 0
If the string contains fewer characters than the size of the bitset, the high-order
bits are set to zero.
  Note
The indexing conventions of strings and bitsets are inversely related:
The character in the string with the highest subscript (the rightmost
character) is used to initialize the low-order bit in the bitset (the bit with
subscript 0). When you initialize a bitset from a string, it is essential to
remember this difference.
We need not use the entire string as the initial value for the bitset. Instead, we
can use a substring as the initializer:
Click here to view code image
string str("1111111000000011001101");
bitset<32> bitvec5(str, 5, 4); // four bits starting at str[5], 1100
bitset<32> bitvec6(str, str.size()-4); // use last four characters
Here bitvec5 is initialized by the substring in str starting at str[5] and continuing
for four positions. As usual, the right-most character of the substring represents the
lowest-order bit. Thus, bitvec5 is initialized with bit positions 3 through 0 set to
1100 and the remaining bits set to 0. The initializer for bitvec6 passes a stringr, Fifth Edition
and a starting point, so bitvec6 is initialized from the characters in str starting four
from the end of str. The remainder of the bits in bitvec6 are initialized to zero. We
can view these initializations as
Exercises Section 17.2.1
Exercise 17.9: Explain the bit pattern each of the following bitset objects
contains:
(a) bitset<64> bitvec(32);
(b) bitset<32> bv(1010101);
(c) string bstr; cin >> bstr; bitset<8>bv(bstr);
17.2.2. Operations on bitsets
The bitset operations (Table 17.3 (overleaf)) define various ways to test or set one
or more bits. The bitset class also supports the bitwise operators that we covered in
¡ì 4.8 (p. 152). The operators have the same meaning when applied to bitset
objects as the built-in operators have when applied to unsigned operands.
Table 17.3. bitset Operationsr, Fifth Edition
Several operations¡ªcount, size, all, any, and none¡ªtake no arguments and
return information about the state of the entire bitset. Others¡ªset, reset, and
flip¡ªchange the state of the bitset. The members that change the bitset are
overloaded. In each case, the version that takes no arguments applies the given
operation to the entire set; the versions that take a position apply the operation to the
given bit:
Click here to view code image
bitset<32> bitvec(1U); // 32 bits; low-order bit is 1, remaining bits are 0
bool is_set = bitvec.any(); // true, one bit is set
bool is_not_set = bitvec.none(); // false, one bit is set
bool all_set = bitvec.all(); // false, only one bit is set
size_t onBits = bitvec.count(); // returns 1
size_t sz = bitvec.size(); // returns 32
bitvec.flip(); // reverses the value of all the bits in bitvec
bitvec.reset(); // sets all the bits to 0
bitvec.set(); // sets all the bits to 1
The any operation returns true if one or more bits of the bitset object are turned
on¡ªthat is, are equal to 1. Conversely, none returns true if all the bits are zero. Ther, Fifth Edition
new standard introduced the all operation, which returns true if all the bits are on.
The count and size operations return a size_t (¡ì 3.5.2, p. 116) equal to the
number of bits that are set, or the total number of bits in the object, respectively. The
size function is a constexpr and so can be used where a constant expression is
required (¡ì 2.4.4, p. 65).
The flip, set, reset, and test members let us read or write the bit at a
given position:
Click here to view code image
bitvec.flip(0); // reverses the value of the first bit
bitvec.set(bitvec.size() - 1); // turns on the last bit
bitvec.set(0, 0); // turns off the first bit
bitvec.reset(i); // turns off the ith bit
bitvec.test(0); // returns false because the first bit is off
The subscript operator is overloaded on const. The const version returns a bool
value true if the bit at the given index is on, false otherwise. The nonconst
version returns a special type defined by bitset that lets us manipulate the bit value
at the given index position:
Click here to view code image
bitvec[0] = 0; // turn off the bit at position 0
bitvec[31] = bitvec[0]; // set the last bit to the same value as the first bit
bitvec[0].flip(); // flip the value of the bit at position 0
~bitvec[0]; // equivalent operation; flips the bit at position 0
bool b = bitvec[0]; // convert the value of bitvec[0] to bool
Retrieving the Value of a bitseThe to_ulong and to_ullong operations return a value that holds the same bit
pattern as the bitset object. We can use these operations only if the size of the
bitset is less than or equal to the corresponding size, unsigned long for
to_ulong and unsigned long long for to_ullong:
Click here to view code image
unsigned long ulong = bitvec3.to_ulong();
cout << "ulong = " << ulong << endl;
  Note
These operations throw an overflow_error exception (¡ì 5.6, p. 193) if the
value in the bitset does not fit in the specified type.r, Fifth Edition
bitset IO Operators
The input operator reads characters from the input stream into a temporary object of
type string. It reads until it has read as many characters as the size of the
corresponding bitset, or it encounters a character other than 1 or 0, or it
encounters end-of-file or an input error. The bitset is then initialized from that
temporary string (¡ì 17.2.1, p. 724). If fewer characters are read than the size of
the bitset, the high-order bits are, as usual, set to 0.
The output operator prints the bit pattern in a bitset object:
Click here to view code image
bitset<16> bits;
cin >> bits; // read up to 16 1 or 0 characters from cin
cout << "bits: " << bits << endl; // print what we just read
Using bitsets
To illustrate using bitsets, we¡¯ll reimplement the grading code from ¡ì 4.8 (p. 154)
that used an unsigned long to represent the pass/fail quiz results for 30 students:
Click here to view code image
bool status;
// version using bitwise operators
unsigned long quizA = 0; // this value is used as a collection of bits
quizA |= 1UL << 27; // indicate student number 27 passed
status = quizA & (1UL << 27); // check how student number 27 did
quizA &= ~(1UL << 27); // student number 27 failed
// equivalent actions using the bitset library
bitset<30> quizB; // allocate one bit per student; all bits initialized to 0
quizB.set(27); // indicate student number 27 passed
status = quizB[27]; // check how student number 27 did
quizB.reset(27); // student number 27 failed
Exercises Section 17.2.2
Exercise 17.10: Using the sequence 1, 2, 3, 5, 8, 13, 21, initialize a
bitset that has a 1 bit in each position corresponding to a number in this
sequence. Default initialize another bitset and write a small program to
turn on each of the appropriate bits.
Exercise 17.11: Define a data structure that contains an integral object to
track responses to a true/false quiz containing 10 questions. What changes, ifr, Fifth Edition
any, would you need to make in your data structure if the quiz had 100
questions?
Exercise 17.12: Using the data structure from the previous question, write a
function that takes a question number and a value to indicate a true/false
answer and updates the quiz results accordingly.
Exercise 17.13: Write an integral object that contains the correct answers
for the true/false quiz. Use it to generate grades on the quiz for the data
structure from the previous two exercises.
17.3. Regular Expressions
A regular expression is a way of describing a sequence of characters. Regular
expressions are a stunningly powerful computational device. However, describing the
languages used to define regular expressions is well beyond the scope of this Primer.
Instead, we¡¯ll focus on how to use the C++ regular-expression library (RE library),
which is part of the new library. The RE library, which is defined in the regex header,
involves several components, listed in Table 17.4.
Table 17.4. Regular Expression Library Components
  Tip
If you are not already familiar with using regular expressions, you might want
to skim this section to get an idea of the kinds of things regular expressions
can do.
The regex class represents a regular expression. Aside from initialization and
assignment, regex has few operations. The operations on regex are listed in Table
17.6 (p. 731).
The functions regex_match and regex_search determine whether a given character
sequence matches a given regex. The regex_match function returns true if ther, Fifth Edition
entire input sequence matches the expression; regex_search returns true if there
is a substring in the input sequence that matches. There is also a regex_replace
function that we¡¯ll describe in ¡ì 17.3.4 (p. 741).
The arguments to the regex functions are described in Table 17.5 (overleaf). These
functions return a bool and are overloaded: One version takes an additional
argument of type smatch. If present, these functions store additional information
about a successful match in the given smatch object.
Table 17.5. Arguments to regex_search and regex_match
17.3.1. Using the Regular Expression Library
As a fairly simple example, we¡¯ll look for words that violate a well-known spelling rule
of thumb, ¡°i before e except after c¡±:
Click here to view code image
// find the characters ei that follow a character other than c
string pattern("[^c]ei");
// we want the whole word in which our pattern appears
pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*"regex r(pattern); // construct a regex to find pattern
smatch results; // define an object to hold the results of a search
// define a string that has text that does and doesn't match pattern
string test_str = "receipt freind theif receive";
// use r to find a match to pattern in test_str
if (regex_search(test_str, results, r)) // if there is a match
  cout << results.str() << endl; // print the matching word
We start by defining a string to hold the regular expression we want to find. The
regular expression [^c] says we want any character that is not a 'c', and [^c]ei
says we want any such letter that is followed by the letters ei. This pattern describes
strings containing exactly three characters. We want the entire word that contains this
pattern. To match the word, we need a regular expression that will match the letters
that come before and after our three-letter pattern.
That regular expression consists of zero or more letters followed by our originalr, Fifth Edition
three-letter pattern followed by zero or more additional characters. By default, the
regular-expression language used by regex objects is ECMAScript. In ECMAScript, the
pattern [[:alpha:]] matches any alphabetic character, and the symbols + and *
signify that we want ¡°one or more¡± or ¡°zero or more¡± matches, respectively. Thus,
[[:alpha:]]* will match zero or more charactersHaving stored our regular expression in pattern, we use it to initialize a regex
object named r. We next define a string that we¡¯ll use to test our regular
expression. We initialize test_str with words that match our pattern (e.g., ¡°freind¡±
and ¡°theif¡±) and words (e.g., ¡°receipt¡± and ¡°receive¡±) that don¡¯t. We also define an
smatch object named results, which we will pass to regex_search. If a match is
found, results will hold the details about where the match occurred.
Next we call regex_search. If regex_search finds a match, it returns true. We
use the str member of results to print the part of test_str that matched our
pattern. The regex_search function stops looking as soon as it finds a matching
substring in the input sequence. Thus, the output will be
freind
¡ì 17.3.2 (p. 734) will show how to find all the matches in the input.
Specifying Options for a regex Object
When we define a regex or call assign on a regex to give it a new value, we can
specify one or more flags that affect how the regex operates. These flags control the
processing done by that object. The last six flags listed in Table 17.6 indicate the
language in which the regular expression is written. Exactly one of the flags that
specify a language must be set. By default, the ECMAScript flag is set, which causes
the regex to use the ECMA-262 specification, which is the regular expression
language that many Web browsers use.
Table 17.6. regex (and wregex) Operationsr, Fifth Edition
The other three flags let us specify language-independent aspects of the regularexpression processing. For example, we can indicate that we want the regular
expression to be matched in a case-independent manner.
As one example, we can use the icase flag to find file names that have a particular
file extension. Most operating systems recognize extensions in a case-independent
manner¡ªwe can store a C++ program in a file that ends in .cc, or .Cc, or .cC, or
.CC. We¡¯ll write a regular expression to recognize any of these along with other
common file extensions as follows:
Click here to view code image
// one or more alphanumeric characters followed by a '.' followed by "cpp" or "cxx" or
"cc"
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);
smatch results;
string filename;
while (cin >> filename)
 if (regex_search(filename, results, r))
  cout << results.str() << endl; // print the current match
This expression will match a string of one or more letters or digits followed by a
period and followed by one of three file extensions. The regular expression will match
the file extensions regardless of case.r, Fifth Edition
Just as there are special characters in C++ (¡ì 2.1.3, p. 39), regular-expression
languages typically also have special characters. For example, the dot (.) character
usually matches any character. As we do in C++, we can escape the special nature of
a character by preceding it with a backslash. Because the backslash is also a special
character in C++, we must use a second backslash inside a string literal to indicate to
C++ that we want a backslash. Hence, we must write \\. to represent a regular
expression that will match a period.
Errors in Specifying or Using a Regular Expression
We can think of a regular expression as itself a ¡°program¡± in a simple programming
language. That language is not interpreted by the C++ compiler. Instead, a regular
expression is ¡°compiled¡± at run time when a regex object is initialized with or
assigned a new pattern. As with any programming language, it is possible that the
regular expressions we write can have errors.
  Note
It is important to realize that the syntactic correctness of a regular expression
is evaluated at run time.
If we make a mistake in writing a regular expression, then at run time the library
will throw an exception (¡ì 5.6, p. 193) of type regex_error. Like the standard
exception types, regex_error has a what operation that describes the error that
occurred (¡ì 5.6.2, p. 195). A regex_error also has a member named code that
returns a numeric code corresponding to the type of error that was encountered. The
values code returns are implementation defined. The standard errors that the RE
library can throw are listed in Table 17.7.
Table 17.7. Regular Expression Error Conditionsr, Fifth Edition
For example, we might inadvertently omit a bracket in a pattern:
Click here to view code image
try {
  // error: missing close bracket after alnum; the constructor will throw
  regex r("[[:alnum:]+\\.(cpp|cxx|cc)$", regex::icase);
} catch (regex_error e)
 { cout << e.what() << "\ncode: " << e.code() << endl; }
When run on our system, this program generates
regex_error(error_brack):
The expression contained mismatched [ and ].
code: 4
Our compiler defines the code member to return the position of the error as listed
in Table 17.7, counting, as usual, from zero.
Advice: Avoid Creating Unnecessary Regular ExpressionAs we¡¯ve seen, the ¡°program¡± that a regular expression represents is
compiled at run time, not at compile time. Compiling a regular expression can
be a surprisingly slow operation, especially if you¡¯re using the extended
regular-expression grammar or are using complicated expressions. As a
result, constructing a regex object and assigning a new regular expression
to an existing regex can be time-consuming. To minimize this overhead, you
should try to avoid creating more regex objects than needed. In particular,
if you use a regular expression in a loop, you should create it outside the
loop rather than recompiling it on each iteration.
Regular Expression Classes and the Input Sequence Typer, Fifth Edition
We can search any of several types of input sequence. The input can be ordinary
char data or wchar_t data and those characters can be stored in a library string
or in an array of char (or the wide character versions, wstring or array of
wchar_t). The RE library defines separate types that correspond to these differing
types of input sequences.
For example, the regex class holds regular expressions of type char. The library
also defines a wregex class that holds type wchar_t and has all the same operations
as regex. The only difference is that the initializers of a wregex must use wchar_t
instead of char.
The match and iterator types (which we will cover in the following sections) are
more specific. These types differ not only by the character type, but also by whether
the sequence is in a library string or an array: smatch represents string input
sequences; cmatch, character array sequences; wsmatch, wide string (wstring)
input; and wcmatch, arrays of wide characters.
The important point is that the RE library types we use must match the type of the
input sequence. Table 17.8 indicates which types correspond to which kinds of input
sequences. For example:
Click here to view code image
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);
smatch results; // will match a string input sequence, but not char*
if (regex_search("myfile.cc", results, r)) // error: char* input
  cout << results.str() << endl;
Table 17.8. Regular Expression Library Classes
The (C++) compiler will reject this code because the type of the match argument and
the type of the input sequence do not match. If we want to search a character array,
then we must use a cmatch object:
Click here to view code image
cmatch results; // will match character array input sequences
if (regex_search("myfile.cc", results, r))
  cout << results.str() << endl; // print the current match
In general, our programs will use string input sequences and the corresponding
string versions of the RE library components.r, Fifth Edition
Exercises Section 17.3.1
Exercise 17.14: Write several regular expressions designed to trigger
various errors. Run your program to see what output your compiler generates
for each error.
Exercise 17.15: Write a program using the pattern that finds words that
violate the ¡°i before e except after c¡± rule. Have your program prompt the
user to supply a word and indicate whether the word is okay or not. Test
your program with words that do and do not violate the rule.
Exercise 17.16: What would happen if your regex object in the previous
program were initialized with "[^c]ei"? Test your program using that
pattern to see whether your expectations were correct.
17.3.2. The Match and Regex Iterator Types
The program on page 729 that found violations of the ¡°i before e except after c¡±
grammar rule printed only the first match in its input sequence. We can get all the
matches by using an sregex_iterator. The regex iterators are iterator adaptors (¡ì 9.6,
p. 368) that are bound to an input sequence and a regex object. As described in
Table 17.8 (on the previous page), there are specific regex iterator types that
correspond to each of the different types of input sequences. The iterator operations
are described in Table 17.9 (p. 736).
Table 17.9. sregex_iterator Operations
When we bind an sregex_iterator to a string and a regex object, the
iterator is automatically positioned on the first match in the given string. That is,
the sregex_iterator constructor calls regex_search on the given string andr, Fifth Edition
regex. When we dereference the iterator, we get an smatch object corresponding to
the results from the most recent search. When we increment the iterator, it calls
regex_search to find the next match in the input string.
Using an sregex_iterator
As an example, we¡¯ll extend our program to find all the violations of the ¡°i before e
except after c¡± grammar rule in a file of text. We¡¯ll assume that the string named
file holds the entire contents of the input file that we want to search. This version
of the program will use the same pattern as our original one, but will use a
sregex_iterator to do the search:
Click here to view code image
// find the characters ei that follow a character other than c
string pattern("[^c]ei");
// we want the whole word in which our pattern appears
pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
regex r(pattern, regex::icase); // we'll ignore case in doing the match
// it will repeatedly call regex_search to find all matches in file
for (sregex_iterator it(file.begin(), file.end(), r), end_it;
 it != end_it; ++it)
  cout << it->str() << endl; // matched word
The for loop iterates through each match to r inside file. The initializer in the for
defines it and end_it. When we define it, the sregex_iterator constructor
calls regex_search to position it on the first match in file. The empty
sregex_iterator, end_it, acts as the off-the-end iterator. The increment in the
for ¡°advances¡± the iterator by calling regex_search. When we dereference the
iterator, we get an smatch object representing the current match. We call the str
member of the match to print the matching word.
We can think of this loop as jumping from match to match as illustrated in Figure
17.1.
Figure 17.1. Using an sregex_iterator
Using the Match Datar, Fifth Edition
If we run this loop on test_str from our original program, the output would be
freind
theif
However, finding just the words that match our expression is not so useful. If we ran
the program on a larger input sequence¡ªfor example, on the text of this chapter¡ª
we¡¯d want to see the context within which the word occurs, such as
Click here to view code image
hey read or write according to the type
  >>> being <<<
handled. The input operators ignore whi
In addition to letting us print the part of the input string that was matched, the match
classes give us more detailed information about the match. The operations on these
types are listed in Table 17.10 (p. 737) and Table 17.11 (p. 741).
Table 17.10. smatch Operations
Table 17.11. Submatch Operationsr, Fifth Edition
We¡¯ll have more to say about the smatch and ssub_match types in the next section.
For now, what we need to know is that these types let us see the context of a match.
The match types have members named prefix and suffix, which return a
ssub_match object representing the part of the input sequence ahead of and after
the current match, respectively. A ssub_match object has members named str and
length, which return the matched string and size of that string, respectively. We
can use these operations to rewrite the loop of our grammar program:
Click here to view code image
// same for loop header as before
for (sregex_iterator it(file.begin(), file.end(), r), end_it;
 it != end_it; ++it) {
  auto pos = it->prefix().length(); // size of the prefi pos = pos > 40 ? pos - 40 : 0; // we want up to 40
characters
  cout << it->prefix().str().substr(pos) // last part of the
prefix
  << "\n\t\t>>> " << it->str() << " <<<\n" // matched
word
  << it->suffix().str().substr(0, 40) // first part of the
suffix
  << endl;
}
The loop itself operates the same way as our previous program. What¡¯s changed is the
processing inside the for, which is illustrated in Figure 17.2.
Figure 17.2. The smatch Object Representing a Particular Match
We call prefix, which returns an ssub_match object that represents the part of